# Batch 11 결과 (101-110)

**처리 일시**: 2026-01-03
**처리 문서 수**: 10개
**추출된 기법 수**: 76개

---

## 문서별 결과

### 101. Embabel-MCP-Server-Human-in-the-Loop.md (7개 기법)

#### 1. Human-in-the-Loop 확인 패턴
- **카테고리**: AI 에이전트
- **설명**: AI 에이전트가 자율적으로 동작하면서도 중요한 결정 지점에서 `WaitFor.formSubmission()` 메서드를 사용하여 사람의 확인을 받는 패턴이다. 에이전트가 프로세스를 일시 중지하고 Human 응답을 기다린 후 재개할 수 있다.
- **적용 시나리오**: 주문 확인, 승인 워크플로우, 위험한 작업 실행 전 확인이 필요한 경우

#### 2. 선언적 에이전트 정의 (Annotation 기반)
- **카테고리**: AI 에이전트
- **설명**: `@Agent`, `@Action`, `@AchievesGoal` 어노테이션을 통해 에이전트의 역할, 수행 가능한 액션, 최종 목표를 선언적으로 정의한다.
- **적용 시나리오**: Java/Spring Boot 기반 AI 에이전트 개발 시

#### 3. MCP(Model Context Protocol) 서버 구축
- **카테고리**: AI 에이전트 / 도구 활용
- **설명**: `@Export(remote = true)` 어노테이션을 사용하여 에이전트의 메서드를 원격 MCP 도구로 노출한다.
- **적용 시나리오**: AI 에이전트 간 상호 운용성이 필요한 시스템

#### 4. 비동기 프로세스 재개 패턴 (processId 활용)
- **카테고리**: 워크플로우
- **설명**: `processId`를 통해 일시 중지된 AI 에이전트 프로세스를 식별하고, Human 응답을 받은 후 프로세스를 비동기적으로 재개한다.
- **적용 시나리오**: 장시간 대기가 필요한 승인 프로세스

#### 5. LLM을 활용한 자연어 → 구조화 데이터 변환
- **카테고리**: 프롬프트 엔지니어링
- **설명**: 사용자의 자연어 메시지를 LLM 호출을 통해 구조화된 객체로 변환한다.
- **적용 시나리오**: 챗봇 기반 주문 시스템, 자연어 명령을 시스템 액션으로 변환

#### 6. MCP Inspector를 활용한 에이전트 테스트
- **카테고리**: 도구 활용 / 테스트
- **설명**: MCP Inspector 도구를 사용하여 MCP 서버에 SSE로 연결하고 에이전트를 테스트하고 디버깅한다.
- **적용 시나리오**: AI 에이전트 개발 중 빠른 테스트와 디버깅

#### 7. 에이전트 → MCP 서버 지시 패턴
- **카테고리**: AI 에이전트
- **설명**: MCP 서버가 호출자 에이전트에게 다음에 무엇을 해야 하는지 명시적으로 지시하는 응답을 반환한다.
- **적용 시나리오**: 다중 에이전트 시스템에서 에이전트 간 조율

---

### 102. Evil Twin SDLC - AI.md (10개 기법)

#### 1. AI 도구 승인 목록 관리
- **카테고리**: 보안/테스트
- **설명**: 조직 내에서 사용할 수 있는 AI 도구의 승인 목록을 관리합니다. 각 도구의 위험 프로필을 평가하여 적절한 도구만 허용합니다.
- **적용 시나리오**: 조직 차원에서 AI 도구 도입 시

#### 2. 역할 기반 AI 액세스 제어
- **카테고리**: AI-Ops
- **설명**: 개발자 경험 수준에 따라 AI 사용 권한을 차등 부여합니다. 주니어 개발자가 AI로 생성한 보안 관련 코드는 시니어 개발자의 리뷰를 필수로 거치도록 합니다.
- **적용 시나리오**: 신규 개발자 온보딩 시

#### 3. AI 생성 코드 정기 감사
- **카테고리**: 코드 품질
- **설명**: AI 도구가 제안하는 코드의 품질과 수용률을 정기적으로 추적하고 감사합니다.
- **적용 시나리오**: 분기별 코드 품질 리뷰 시

#### 4. AI 의존성 승인 워크플로우
- **카테고리**: 워크플로우
- **설명**: AI가 새로운 패키지나 라이브러리를 추가할 때 자동으로 승인된 의존성 목록과 대조하는 워크플로우를 구축합니다.
- **적용 시나리오**: CI/CD 파이프라인 구축 시

#### 5. 기술 부채 속도 측정
- **카테고리**: AI-Ops
- **설명**: AI 생성 코드로 인한 기술 부채 증가 속도를 측정합니다. 부채 생성 대 해결 비율, AI 코드 리팩터링 빈도 등을 핵심 지표로 추적합니다.
- **적용 시나리오**: 스프린트 회고 시

#### 6. AI 페어 프로그래밍 방식
- **카테고리**: 워크플로우
- **설명**: AI를 최종 검토자가 아닌 제안자로 취급합니다. 개발자가 AI의 제안을 비판적으로 검토하고 최종 결정을 내리는 협업 방식을 채택합니다.
- **적용 시나리오**: 일상적인 코딩 작업 시

#### 7. AI 책임 소재 명확화
- **카테고리**: AI-Ops
- **설명**: "AI가 그렇게 했어요"라는 면책은 인정하지 않습니다. AI가 나쁜 코드를 제안하더라도 최종 수용 결정을 내린 개발자에게 책임이 있음을 명확히 합니다.
- **적용 시나리오**: 팀 가이드라인 수립 시

#### 8. 레거시 시스템용 AI 가드레일
- **카테고리**: 코드 품질
- **설명**: AI는 최신 패턴에 편향되어 있으므로 레거시 시스템에는 별도의 규칙을 적용합니다.
- **적용 시나리오**: 레거시 시스템 유지보수 시

#### 9. 출처 추적 시스템
- **카테고리**: 보안/테스트
- **설명**: AI가 생성하거나 추천한 코드의 출처, 검토자, 마지막 업데이트 시점을 추적합니다.
- **적용 시나리오**: 보안 감사 시

#### 10. AI 정기 교육 프로그램
- **카테고리**: 생산성
- **설명**: AI 도구가 발전함에 따라 모범 사례도 함께 발전합니다. 개발팀에 정기적인 AI 활용 교육을 제공합니다.
- **적용 시나리오**: 분기별 개발자 교육 시

---

### 103. Exploring Generative AI.md (12개 기법)

#### 1. AI 생성 코드 주의 깊은 검토
- **카테고리**: 코드 품질
- **설명**: AI가 생성한 코드를 커밋 전에 항상 꼼꼼히 검토해야 합니다. 무비판적 수용은 금물입니다.
- **적용 시나리오**: AI 코딩 어시스턴트로 코드를 생성한 후, 커밋하기 전

#### 2. AI 세션 압도 시 중단 및 재시작
- **카테고리**: 워크플로우
- **설명**: AI 코딩 세션에서 진행 상황에 압도당한다고 느낄 때 세션을 중단하고, 프롬프트를 수정하여 새 세션을 시작합니다.
- **적용 시나리오**: AI가 토끼굴에 빠지거나 컨텍스트 창이 너무 커져서 혼란스러워질 때

#### 3. AI + 페어 프로그래밍 병행
- **카테고리**: 생산성
- **설명**: AI 코딩 시 페어 프로그래밍을 연습하면 AI의 실수를 더 효과적으로 잡아낼 수 있습니다.
- **적용 시나리오**: 복잡한 기능 구현, 리팩토링, 아키텍처 변경 등 중요한 작업 시

#### 4. AI 코드에 대한 자동화된 품질 검사
- **카테고리**: 도구 활용
- **설명**: SonarQube나 Codescene 같은 도구를 설정하여 코드 냄새에 대해 경고받습니다.
- **적용 시나리오**: AI 어시스턴트를 팀 전체에서 사용하기 시작할 때

#### 5. Shift-Left 검증 전략
- **카테고리**: 워크플로우
- **설명**: 검토, 린트, 보안 검사를 최대한 왼쪽(개발 단계)으로 이동시킵니다.
- **적용 시나리오**: AI 생성 코드의 품질 문제가 PR 리뷰 단계에서 자주 발견될 때

#### 6. AI 코딩 어시스턴트에 커스텀 규칙 설정
- **카테고리**: 프롬프트 엔지니어링
- **설명**: 팀의 좋은 관행을 코드화한 프롬프트 지침을 반복적으로 개선하여 AI의 실수를 완화합니다.
- **적용 시나리오**: 반복적인 AI 실수 패턴이 발견될 때

#### 7. "잘못된 방향" 로그 유지 및 주간 회고
- **카테고리**: AI-Ops
- **설명**: AI 생성 코드가 팀에 마찰을 일으키거나 유지보수성에 영향을 미친 이벤트를 로그로 유지하고, 주간 회고합니다.
- **적용 시나리오**: AI 도구 도입 초기

#### 8. AI의 광범위한 접근 방지
- **카테고리**: 프롬프트 엔지니어링
- **설명**: 기능의 작동하는 수직 조각(vertical slice)으로 시작하도록 프롬프트에서 명시적으로 지시합니다.
- **적용 시나리오**: 프론트엔드 마이그레이션, 대규모 리팩토링 시

#### 9. 무차별 수정 대신 근본 원인 진단 유도
- **카테고리**: 프롬프트 엔지니어링
- **설명**: AI가 문제를 해결할 때 "왜 이 문제가 발생했는지"를 먼저 분석하도록 유도합니다.
- **적용 시나리오**: 빌드 오류, 성능 문제 해결 시

#### 10. AI 테스트 생성 시 중복 검토
- **카테고리**: TDD/개발 방법론
- **설명**: AI는 기존 테스트에 어설션을 추가하는 대신 새 테스트 함수를 만드는 경향이 있습니다. 사용자 지정 지침으로 이를 완화합니다.
- **적용 시나리오**: AI로 테스트 코드를 생성할 때

#### 11. "빠른 해결책"의 유지보수 비용 평가
- **카테고리**: 코드 품질
- **설명**: 현재 잘 작동하지만 미래에 변경하기 어려운 코드인지 판단하는 경험적 안목이 필요합니다.
- **적용 시나리오**: AI가 빠르게 해결책을 제시했을 때

#### 12. AI 도입 시 팀 문화 관리
- **카테고리**: 워크플로우
- **설명**: 높은 신뢰와 심리적 안전성을 가진 팀에서 개발자들은 AI 채택의 과제를 공유하고 더 빨리 배울 수 있습니다.
- **적용 시나리오**: 조직 차원에서 AI 도구를 도입할 때

---

### 104. Fabric.md (13개 기법)

#### 1. 패턴(Pattern) 기반 프롬프트 템플릿화
- **카테고리**: 프롬프트 엔지니어링
- **설명**: 자주 사용하는 프롬프트를 "패턴"으로 저장하여 재사용합니다. CLI에서 `-p` 옵션으로 즉시 호출 가능합니다.
- **적용 시나리오**: 반복적인 AI 작업(코드 리뷰, 요약, 분석 등)을 수행할 때

#### 2. 다중 프롬프트 체이닝 워크플로우
- **카테고리**: 워크플로우
- **설명**: 여러 프롬프트를 파이프(`|`)로 연결하여 복잡한 AI 워크플로우를 구성합니다.
- **적용 시나리오**: 문서 분석 → 요약 → 번역 같은 다단계 처리

#### 3. YouTube 트랜스크립트 자동 분석
- **카테고리**: 도구 활용
- **설명**: `fabric -y [YouTube URL]` 명령으로 영상의 트랜스크립트를 자동 추출하고 AI 패턴과 결합하여 인사이트를 추출합니다.
- **적용 시나리오**: 긴 강의/발표 영상 요약

#### 4. analyze_claims 패턴 활용
- **카테고리**: 프롬프트 엔지니어링
- **설명**: 입력된 주장에 대해 지지 증거, 반박 증거, 논리적 오류를 체계적으로 분석하고 신뢰도를 평가합니다.
- **적용 시나리오**: 기술 논쟁 평가, 의사결정 전 주장 검증

#### 5. 전문가 역할 기반 코드 리뷰 (ask_uncle_duke)
- **카테고리**: 코드 품질
- **설명**: Java/Spring 전문가 페르소나를 가진 패턴이 SOLID, DRY, TDD, 클린 코딩 원칙에 따라 코드를 분석합니다.
- **적용 시나리오**: 코드 리뷰, 리팩토링 제안 받기

#### 6. create_design_document 패턴
- **카테고리**: 생산성
- **설명**: 간단한 프로젝트 설명을 입력하면 비즈니스 포스처, 리스크 분석, 보안 고려사항 등을 포함한 설계 문서를 자동 생성합니다.
- **적용 시나리오**: 신규 프로젝트 시작 시

#### 7. agility_story / create_user_story 패턴
- **카테고리**: 생산성
- **설명**: 기능 요구사항을 입력하면 사용자 스토리 형식과 인수 조건을 자동 생성합니다.
- **적용 시나리오**: 스프린트 계획, 백로그 작성

#### 8. 프롬프트 품질 향상 (improve_prompt)
- **카테고리**: 프롬프트 엔지니어링
- **설명**: 작성한 프롬프트를 입력하면 더 명확하고 효과적인 프롬프트로 개선해줍니다.
- **적용 시나리오**: AI 출력 품질이 낮을 때

#### 9. 학술 콘텐츠 심층 분석 (analyze_paper)
- **카테고리**: 생산성
- **설명**: URL이나 텍스트를 입력하면 논문/기사의 핵심 주장, 방법론, 결론을 체계적으로 분석합니다.
- **적용 시나리오**: 기술 블로그 리뷰, 학술 논문 빠른 파악

#### 10. Multi-Model Integration
- **카테고리**: AI-Ops
- **설명**: OpenAI, Anthropic, Ollama(로컬) 등 다양한 AI 모델을 `-m` 옵션으로 쉽게 전환하여 사용합니다.
- **적용 시나리오**: 비용 최적화, 보안이 중요한 작업

#### 11. PKM 도구와 AI 통합 (Obsidian)
- **카테고리**: 워크플로우
- **설명**: Fabric 출력을 Obsidian 노트로 직접 저장하거나, Obsidian 노트를 Fabric 입력으로 활용합니다.
- **적용 시나리오**: 학습 노트 정리, 연구 자료 요약

#### 12. 재귀적 아웃라인 생성 (create_recursive_outline)
- **카테고리**: 생산성
- **설명**: 주제를 입력하면 UI, 백엔드, 데이터베이스, 보안, 테스트, 배포까지 포괄하는 계층적 프로젝트 아웃라인을 자동 생성합니다.
- **적용 시나리오**: 프로젝트 기획 초기 단계

#### 13. Jina AI 기반 웹 스크래핑
- **카테고리**: 도구 활용
- **설명**: `-u` 옵션으로 웹페이지 URL을 마크다운으로 변환하여 AI 분석의 입력으로 활용합니다.
- **적용 시나리오**: 온라인 기사 요약, 기술 문서 빠른 파악

---

### 105. Feed Knowlege of Any Website to LLM In Seconds.md (5개 기법)

#### 1. Crawl4AI 웹 스크래핑
- **카테고리**: 도구 활용
- **설명**: Crawl4AI를 사용하여 웹페이지의 HTML을 LLM이 이해하기 쉬운 깔끔한 마크다운으로 자동 변환합니다.
- **적용 시나리오**: LLM에 최신 웹 정보를 제공해야 할 때

#### 2. 브라우저 세션 재사용 크롤링
- **카테고리**: 워크플로우
- **설명**: 동일한 브라우저 세션을 재사용하여 여러 URL을 효율적으로 크롤링합니다.
- **적용 시나리오**: 동일 도메인의 여러 페이지를 순차적으로 수집할 때

#### 3. 비동기 병렬 웹 크롤링
- **카테고리**: 생산성
- **설명**: asyncio.gather()를 사용하여 여러 URL을 동시에 크롤링합니다.
- **적용 시나리오**: 대규모 문서 사이트 전체를 빠르게 수집해야 할 때

#### 4. Supabase/PGVector RAG 파이프라인
- **카테고리**: AI 에이전트
- **설명**: 크롤링한 마크다운 콘텐츠를 임베딩으로 변환하여 벡터 데이터베이스에 저장하고 유사도 검색을 수행합니다.
- **적용 시나리오**: 특정 도메인 지식 기반의 AI 챗봇을 구축할 때

#### 5. 실시간 웹 지식베이스 생성
- **카테고리**: AI-Ops
- **설명**: Crawl4AI와 RAG를 결합하여 어떤 웹사이트든 LLM을 위한 동적인 지식베이스로 변환합니다.
- **적용 시나리오**: 기업 내부 문서 기반 AI 어시스턴트 구축 시

---

### 106. From Autocomplete to Agents-Al Coding State of Play.md (12개 기법)

#### 1. 커스텀 인스트럭션(Custom Instructions) 설정
- **카테고리**: 프롬프트 엔지니어링
- **설명**: 프로젝트별로 AI에게 컨텍스트를 제공하는 설정 파일을 작성합니다.
- **적용 시나리오**: 팀에서 일관된 AI 활용 품질을 유지하고 싶을 때

#### 2. 벡터 임베딩 기반 코드베이스 인덱싱
- **카테고리**: 도구 활용
- **설명**: 벡터 임베딩을 사용해 코드베이스 전체를 인덱싱하여 의미론적 코드 탐색이 가능해집니다.
- **적용 시나리오**: 대규모 레거시 코드베이스를 파악해야 할 때

#### 3. 감독된 에이전트(Supervised Agents) 활용
- **카테고리**: AI 에이전트
- **설명**: 에이전트가 파일 읽기/쓰기, 테스트 실행 등을 자동으로 수행하되, 개발자가 각 단계를 승인하는 방식입니다.
- **적용 시나리오**: 반복적인 수정-테스트 사이클을 자동화하고 싶을 때

#### 4. 계획 우선 접근법(Plan-First Approach)
- **카테고리**: 워크플로우
- **설명**: AI에게 코드 작성을 요청하기 전에 먼저 계획 수립을 요청합니다.
- **적용 시나리오**: 복잡한 기능을 구현할 때

#### 5. 영향 범위별 AI 실수 모니터링
- **카테고리**: 코드 품질
- **설명**: AI 실수를 세 가지 수준(커밋/팀/코드베이스)으로 분류하여 모니터링합니다.
- **적용 시나리오**: AI 도입 후 품질 저하를 체계적으로 추적하고 싶을 때

#### 6. Pre-commit 단계 AI 코드 리뷰
- **카테고리**: 코드 품질
- **설명**: AI 코드 리뷰를 PR 단계가 아닌 pre-commit 단계로 이동시킵니다.
- **적용 시나리오**: AI가 생성한 코드의 품질을 조기에 검증하고 싶을 때

#### 7. 코드 품질 메트릭 모니터링
- **카테고리**: 코드 품질
- **설명**: SonarQube, CodeScene 같은 도구로 AI 사용 후 코드 품질 변화를 추적합니다.
- **적용 시나리오**: AI 도입 효과를 객관적으로 측정하고 싶을 때

#### 8. 바이브 코딩의 제한적 활용
- **카테고리**: 워크플로우
- **설명**: 코드를 직접 보지 않고 AI에게 원하는 것만 말하는 "바이브 코딩"은 빠른 프로토타입에만 한정합니다.
- **적용 시나리오**: 아이디어 검증용 빠른 프로토타입이 필요할 때

#### 9. AI 실수 패턴 인식
- **카테고리**: 코드 품질
- **설명**: AI가 자주 저지르는 실수 패턴을 인식합니다: 무차별 대입 수정, 과도한 모킹 등.
- **적용 시나리오**: AI 생성 코드를 리뷰할 때

#### 10. 통제력 상실 시점 인식
- **카테고리**: 워크플로우
- **설명**: AI와의 작업 세션에서 통제력을 잃었다고 느끼는 순간을 인식하고, 그 시점에서 작업을 중단합니다.
- **적용 시나리오**: AI가 예상치 못한 방향으로 코드를 변경할 때

#### 11. MCP 서버 보안 검증
- **카테고리**: 보안/테스트
- **설명**: MCP 서버들은 보안 위험성이 있으므로 검증이 필요합니다.
- **적용 시나리오**: 외부 MCP 서버를 도입할 때

#### 12. 팀 문화 균형 조성
- **카테고리**: 생산성
- **설명**: AI 회의론자와 열광자 모두를 포용하는 문화를 조성합니다. 현실적인 생산성 향상 기대치는 8-13% 수준입니다.
- **적용 시나리오**: 팀에 AI 도구를 도입할 때

---

### 107. From Cursor to Claude Code.md (8개 기법)

#### 1. 하이브리드 도구 통합 (Hybrid Tool Integration)
- **카테고리**: 워크플로우
- **설명**: Claude Code를 Cursor 내 터미널에서 실행하여 두 도구의 장점을 결합합니다.
- **적용 시나리오**: 대규모 프로젝트에서 복잡한 기능 개발과 간단한 버그 수정이 혼재할 때

#### 2. Sequential Thinking MCP 활용
- **카테고리**: AI 에이전트
- **설명**: Sequential Thinking MCP를 통해 복잡한 문제를 작은 단계로 분해하고 체계적으로 해결합니다.
- **적용 시나리오**: 복잡한 비즈니스 로직 구현 시

#### 3. 문제 분해 후 계획 수립 (Problem Decomposition)
- **카테고리**: 프롬프트 엔지니어링
- **설명**: 요구사항을 바로 코드로 변환하지 않고, 먼저 하위 작업을 목록으로 정리한 후 단계별로 진행합니다.
- **적용 시나리오**: 새로운 기능 개발 요청 시

#### 4. 터미널 기반 CLI 통합 워크플로우
- **카테고리**: 도구 활용
- **설명**: Claude Code의 터미널 환경 친화성을 활용하여 CLI 기반 작업을 자연스럽게 통합합니다.
- **적용 시나리오**: DevOps 작업, CI/CD 파이프라인 구성 시

#### 5. 전체 코드베이스 컨텍스트 탐색
- **카테고리**: AI 에이전트
- **설명**: 특정 파일만 지정하는 방식 대신 코드베이스 전체를 탐색하여 숨겨진 의존성까지 파악합니다.
- **적용 시나리오**: 레거시 코드 리팩토링, 영향 분석 시

#### 6. AI 기반 테스트 자동화 사이클
- **카테고리**: TDD/개발 방법론
- **설명**: AI가 테스트 작성, 실행, 실패 원인 분석, 반복 개선까지 전 과정을 지원합니다.
- **적용 시나리오**: TDD 방식의 개발 시

#### 7. MCP 생태계 연동
- **카테고리**: AI 에이전트
- **설명**: 다양한 MCP를 통해 외부 서비스와 AI 도구를 연동하여 개발 워크플로우를 확장합니다.
- **적용 시나리오**: 마이크로서비스 개발, 외부 API 통합 작업 시

#### 8. 도구 비용 대비 가치 평가 프레임워크
- **카테고리**: 생산성
- **설명**: AI 도구 선택 시 생산성 향상, 코드 품질, 무제한 사용 여부 등을 종합적으로 평가합니다.
- **적용 시나리오**: 팀 또는 개인의 AI 도구 선택 시

---

### 108. Geoffrey-Hinton-AI-Warning-Final-Message.md

**해당 없음** - 이 문서는 AI 위험성 경고 및 안전성 논의에 관한 것으로, 실제로 활용 가능한 AI 활용 기법은 포함되어 있지 않습니다.

---

### 109. Get the Cursor AI experience in Neovim with avante nvim.md (4개 기법)

#### 1. IDE 내장 AI 코딩 어시스턴트 통합
- **카테고리**: 도구 활용
- **설명**: Avante.nvim을 통해 Neovim 환경에서 Cursor AI와 유사한 AI 코딩 지원을 받을 수 있습니다.
- **적용 시나리오**: Neovim 사용자가 기존 환경에서 AI 코딩 어시스턴트를 사용하고 싶을 때

#### 2. AI 제안 코드 충돌 해결 워크플로우
- **카테고리**: 워크플로우
- **설명**: AI가 제안한 코드와 기존 코드 간의 충돌을 Git 병합 충돌 방식으로 처리합니다.
- **적용 시나리오**: AI가 제안한 코드 변경사항을 검토하고 선택적으로 적용할 때

#### 3. 사이드바 기반 AI 대화 인터페이스
- **카테고리**: 생산성
- **설명**: Leader 키 조합으로 AI 사이드바를 열고, 코드 작성 흐름을 유지하면서 AI와 상호작용이 가능합니다.
- **적용 시나리오**: 코딩 중 컨텍스트 스위칭 없이 AI에게 질문할 때

#### 4. 코드 블록 네비게이션을 통한 AI 결과 탐색
- **카테고리**: 생산성
- **설명**: `[[`와 `]]` 단축키로 AI가 생성한 코드 블록들 사이를 빠르게 이동할 수 있습니다.
- **적용 시나리오**: AI가 여러 코드 섹션을 제안했을 때 빠르게 검토할 때

---

### 110. Goodbye ChatGPT! Free DeepSeek R1 on Our Computer.md (5개 기법)

#### 1. Ollama를 통한 로컬 AI 모델 실행
- **카테고리**: 도구 활용
- **설명**: Ollama 프레임워크를 사용하여 오픈소스 LLM을 로컬 컴퓨터에서 실행합니다. 인터넷 연결 없이 완전한 오프라인 환경에서 AI 모델을 활용할 수 있습니다.
- **적용 시나리오**: 민감한 데이터를 다룰 때, API 비용을 절감하고 싶을 때

#### 2. Docker 기반 로컬 AI 웹 인터페이스 구축
- **카테고리**: 도구 활용
- **설명**: Docker와 Open Web UI를 결합하여 로컬 AI 모델에 ChatGPT와 유사한 웹 인터페이스를 제공합니다.
- **적용 시나리오**: 팀 내 비개발자도 로컬 AI를 쉽게 사용하도록 할 때

#### 3. 로컬 환경에서의 LLM 모델 비교 평가
- **카테고리**: 워크플로우
- **설명**: Open Web UI의 다중 모델 선택 기능을 활용하여 동일한 프롬프트로 여러 AI 모델의 응답을 동시에 비교합니다.
- **적용 시나리오**: 특정 작업에 가장 적합한 모델을 선정할 때

#### 4. 하드웨어 사양에 맞는 LLM 모델 크기 선택
- **카테고리**: AI-Ops
- **설명**: 7B, 32B, 70B 등 다양한 크기의 모델 중 현재 하드웨어 사양에 맞는 모델을 선택합니다.
- **적용 시나리오**: 개인용 노트북에서 AI를 활용할 때

#### 5. 완전 오프라인 AI 개발 환경 구성
- **카테고리**: 보안/테스트
- **설명**: Ollama + Docker + Open Web UI 조합으로 인터넷 연결 없이 동작하는 AI 환경을 구축합니다.
- **적용 시나리오**: 고객 데이터, 의료 정보 등 민감한 데이터 분석 시

---

## 기법 카테고리별 분포

| 카테고리 | 기법 수 |
|----------|---------|
| 프롬프트 엔지니어링 | 10 |
| 워크플로우 | 15 |
| AI 에이전트 | 11 |
| 도구 활용 | 12 |
| 코드 품질 | 10 |
| 생산성 | 8 |
| 보안/테스트 | 5 |
| TDD/개발 방법론 | 2 |
| AI-Ops | 8 |
| **총계** | **76** |

---

## 핵심 테마

1. **Human-in-the-Loop 패턴**: AI 에이전트가 자율적으로 동작하면서도 중요한 결정 지점에서 사람의 확인을 받는 패턴
2. **AI 거버넌스**: 역할 기반 AI 액세스 제어, 출처 추적, 정기 감사 등 조직 차원의 AI 관리
3. **품질 모니터링**: SonarQube, CodeScene 등 도구를 활용한 AI 생성 코드 품질 추적
4. **Fabric 프레임워크**: 패턴 기반 프롬프트 재사용, 체이닝, 다중 모델 통합
5. **로컬 LLM 배포**: Ollama, Open Web UI를 통한 오프라인 AI 환경 구축
6. **MCP 생태계**: Model Context Protocol을 통한 AI 에이전트 간 상호 운용성
