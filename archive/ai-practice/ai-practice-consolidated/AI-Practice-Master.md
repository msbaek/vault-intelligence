# AI 활용 기법 마스터 문서

**생성일**: 2026-01-04
**원본 문서**: 286개 (29 배치)
**추출 기법**: 1,745개
**중복 제거 후**: 1,403개

---

## 개요

이 문서는 AI 활용 관련 286개 문서에서 추출된 기법들을 통합하고 정리한 마스터 문서입니다.
중복을 제거하고 6개 카테고리로 분류하여 실무에서 활용할 수 있도록 구성했습니다.

## 통계 요약

| 카테고리 | 기법 수 | 비율 |
|----------|--------|------|
| AI-Assisted Development | 574 | 40.9% |
| Prompt Engineering | 272 | 19.4% |
| Agent & Workflow | 187 | 13.3% |
| Tools & Integration | 179 | 12.8% |
| Quality & Security | 122 | 8.7% |
| Learning & Mindset | 69 | 4.9% |
| **합계** | **1403** | **100%** |

### 분포 시각화

```
AI-Assisted Development   ██████████████████████████████████████████████████ 574
Prompt Engineering        ███████████████████████ 272
Agent & Workflow          ████████████████ 187
Tools & Integration       ███████████████ 179
Quality & Security        ██████████ 122
Learning & Mindset        ██████ 69
```

---

## 카테고리별 기법 목록

### AI-Assisted Development (574개)

#### 1. Pr 문서화

**설명**: Claude에게 직접 PR 생성을 요청하면 변경사항, 테스트 세부정보, 잠재적 위험을 포함한 포괄적 PR 생성

**적용 조건**: 식단 관리, 칼로리 추적, 건강한 식습관 형성

*출처: 10개 문서*

---

#### 2. 스펙 주도 개발 (Spec-Driven Development)

**설명**: 코드를 먼저 작성하는 대신 명세서(specification)를 먼저 작성하는 개발 방법론입니다. AI 에이전트가 명확한 문서를 기반으로 작업을 수행하도록 하여 5배의 생산성 향상을 달성할 수 있습니다.

**적용 조건**: AI 코딩 도구를 사용할 때, 단순 프롬프트 대신 명확하고 구조화된 사양을 먼저 작성

*출처: 6개 문서*

---

#### 3. 출력 형식 명시

**설명**: `<format>` 또는 `<output_format>` 태그를 사용하여 원하는 출력 형식을 명확히 지정

**적용 조건**: 문서화 자동화, 다이어그램 생성

*출처: 6개 문서*

---

#### 4. 모델별 역할 분리

**설명**: Plan Mode에는 Opus(추론 강화), Execution Mode에는 Sonnet(실행 효율)을 사용하여 각 모델의 강점을 활용

*출처: 5개 문서*

---

#### 5. Ai 기반 Qa

**설명**: 예측 분석, 테스트 자동 생성, 리스크 기반 테스팅, 자가 치유 테스트

*출처: 5개 문서*

---

#### 6. 계획 우선 접근법

**설명**: SPARC 방법론, Plan Mode, Plan-First Execution (275, 277, 278)

*출처: 5개 문서*

---

#### 7. 세션 연속성 관리

**설명**: `-c`와 `-r` 플래그를 사용해 이전 대화를 이어가거나 특정 세션을 선택하여 문맥을 유지

**적용 조건**: PDF, Excel 등의 문서 분석

**예시**: `claude -c`, `claude -r`

*출처: 4개 문서*

---

#### 8. 문서 청킹 전략

**설명**: RAG 시스템에서 문서를 임베딩 모델이 처리할 수 있는 적절한 크기로 분할하는 기법. 단순 문장 분할, 고정 크기 청킹, 오버래핑 청킹 등

**적용 조건**: RAG 시스템 구축, 대용량 문서 벡터 DB 저장, 검색 정확도 최적화

*출처: 4개 문서*

---

#### 9. 단계적 사고 유도

**설명**: "Take a step back and think step-by-step about how to achieve the best possible results"

*출처: 4개 문서*

---

#### 10. 점진적 도입 전략

**설명**: 작게 시작. 전사적인 미팅에서 발표하지 말고 소규모 파일럿으로 시작.

*출처: 3개 문서*

---

#### 11. 계획 모드(Plan Mode) 활용

**설명**: 중간 난이도 작업에서는 Shift + Tab으로 계획 모드에 진입, Claude와 계획을 먼저 정렬한 후 자동 수락 모드로 구현 진행

*출처: 3개 문서*

---

#### 12. 바이브 코딩의 제한적 활용

**설명**: 코드를 직접 보지 않고 AI에게 원하는 것만 말하는 "바이브 코딩"은 빠른 프로토타입에만 한정합니다.

**적용 조건**: 아이디어 검증용 빠른 프로토타입이 필요할 때

*출처: 3개 문서*

---

#### 13. 반복적·점진적 개발 프로세스

**설명**: 요구사항 → 도메인 모델링 → 유스케이스 → TDD → 통합.

*출처: 3개 문서*

---

#### 14. Sparc 방법론

**설명**: AI 기반 개발을 위한 구조화된 접근법 - Specification(명세) → Pseudocode(의사코드) → Architecture(아키텍처) → Refinement(개선) → Completion(완성)의 단계적 프로세스

*출처: 3개 문서*

---

#### 15. 동적 상호작용 설계

**설명**: 코드베이스와 동적으로 상호작용, 좋은 테스트와 모듈식 코드베이스에서 성능 향상.

*출처: 3개 문서*

---

#### 16. Ai 기술 부채 관리

**설명**: 코드를 이해하지 못하면 AI에게 수정을 요청할 수밖에 없는데, 이는 기술 부채가 축적되는 원인이 됩니다.

*출처: 3개 문서*

---

#### 17. 바이브 코딩 (Vibe Coding) 접근법

**설명**: 자연어로 요구사항을 설명하면 AI가 구현 세부사항을 처리하는 개발 방식입니다. 개발자는 "무엇을 원하는지"를 설명하고, AI가 "어떻게 구현할지"를 담당합니다.

**관련 도구**: Claude, ChatGPT, GitHub Copilot

**적용 조건**: 아이디어 구상부터 MVP 출시까지 빠른 개발이 필요할 때

*출처: 2개 문서*

---

#### 18. Tdd Red-Green-Refactor + Ai 워크플로우

**설명**: (1) 실패하는 테스트 작성(Red), (2) 테스트 통과하는 최소 코드(Green), (3) 코드 정리(Refactor)를 AI와 함께 수행

**관련 도구**: /tdd:go 커스텀 커맨드, Claude Code

*출처: 2개 문서*

---

#### 19. 점진적 복잡성 증가 프롬프팅

**설명**: "Explain with gradually increasing complexity" 패턴으로 단계별 이해.

**관련 도구**: Claude, ChatGPT

*출처: 2개 문서*

---

#### 20. 3: Claude Taskmaster를 통한 작업 분해

**설명**: 복잡한 기능 명세를 PRD와 단계별 실행 가능한 태스크로 자동 분해

*출처: 2개 문서*

---

#### 21. 출력 형식 최적화

**설명**: `--output-format json/text/stream-json`

*출처: 2개 문서*

---

#### 22. 출력 구조 사전 정의

**설명**: 8개 섹션(아키텍처, 백엔드, 프론트엔드, DB, 테스트, 문서 등)의 결과물 구조 미리 정의.

*출처: 2개 문서*

---

#### 23. 반복적 Ddd 기반 개발

**설명**: 유비쿼터스 언어, 엔티티 등 DDD 개념을 명확히 AI에 전달.

*출처: 2개 문서*

---

#### 24. 구체적 예시 요청

**설명**: 실제 코드 예시나 의사코드 포함 지시로 실무 적용 가능성 향상.

*출처: 2개 문서*

---

#### 25. 단계적 작업 분해 요청

**설명**: 복잡한 기능 요청 시 Claude가 스스로 작업을 분해하여 "Thinking.." 과정에서 단계별로 계획을 수립하도록 유도

*출처: 2개 문서*

---

#### 26. 스크린샷 직접 입력

**설명**: `Ctrl+V`로 스크린샷을 직접 붙여넣어 시각적 맥락을 제공하는 멀티모달 입력 방식

**예시**: "look at the header navbar this is how it looks please fix it" (스크린샷 첨부)

*출처: 2개 문서*

---

#### 27. 다중 파일 동시 수정

**설명**: 관련된 여러 파일을 한 번의 요청으로 일관되게 수정하여 코드 일관성 유지

*출처: 2개 문서*

---

#### 28. 비용 최적화 전략

**설명**: 종량제에서 정액제(Max)로 전환하여 비용 걱정 없이 다양한 시도가 가능

*출처: 2개 문서*

---

#### 29. Xml 구조화 프롬프팅

**설명**: Claude가 XML 형식의 구조화된 데이터로 훈련되었으므로, XML 태그를 사용하면 Claude의 "네이티브 언어"로 소통

*출처: 2개 문서*

---

#### 30. 점진적 설정 검증 워크플로우

**설명**: 설치 → 다운로드 → 서버 활성화 → 플러그인 연결 → 테스트 순차 검증.

*출처: 2개 문서*

---

#### 31. Ai 기반 브레인스토밍

**설명**: 기존 노트와 아이디어를 AI에게 제공하고 새로운 콘텐츠 제안, 관련 주제 탐색, 문서 구조화 제안을 받습니다.

**적용 조건**: 마이크로서비스 분해, 시스템 모듈화 설계

**예시**: "이 주제와 관련된 다른 관점은 뭐가 있을까?", "이 3개 문서의 공통점과 차이점을 분석해줘"

*출처: 2개 문서*

---

#### 32. Ai 거버넌스

**설명**: 역할 기반 AI 액세스 제어, 출처 추적, 정기 감사 등 조직 차원의 AI 관리

*출처: 2개 문서*

---

#### 33. Faafo 프레임워크

**설명**: Fast, Ambitious, Autonomous, Fun, Optionality의 5가지 가치 체계.

*출처: 2개 문서*

---

#### 34. 로컬 Llm 배포

**설명**: Ollama, Open Web UI를 통한 오프라인 AI 환경 구축

*출처: 2개 문서*

---

#### 35. Ai 생성 코드 주의 깊은 검토

**설명**: AI가 생성한 코드를 커밋 전에 항상 꼼꼼히 검토해야 합니다. 무비판적 수용은 금물입니다.

**적용 조건**: AI 코딩 어시스턴트로 코드를 생성한 후, 커밋하기 전

*출처: 2개 문서*

---

#### 36. Ai 행동 지침 프롬프트 커스터마이징

**설명**: 글로벌 규칙 파일에 SOLID 원칙, 클린 아키텍처, TDD 등의 개발 원칙을 명시하여 AI가 일관된 품질의 코드를 생성하도록 지시.

*출처: 2개 문서*

---

#### 37. 씽킹 모드 활용

**설명**: `"think"`, `"think harder"`, `"ultra think"` 명령어

*출처: 2개 문서*

---

#### 38. 대량 피드백 처리

**설명**: - AI로 대량의 피드백과 분석을 처리하여 숨겨진 상관관계 발견

*출처: 2개 문서*

---

#### 39. Ai 린터로 활용

**설명**: `claude -p 'you are a linter...'` 형태로 빌드 스크립트에 AI 린팅 추가

*출처: 2개 문서*

---

#### 40. 사용자 정의 슬래시 명령어

**설명**: `.claude/commands/` 디렉토리에 Markdown 파일로 재사용 가능한 명령어 생성, `$ARGUMENTS` 플레이스홀더로 인수 전달 가능

*출처: 2개 문서*

---

#### 41. 식사 계획 전문가

**설명**: 선호도와 영양 목표 기반 식단 계획 수립

**적용 조건**: 건강 관리, 다이어트, 식사 준비

*출처: 2개 문서*

---

#### 42. 아티팩트 형식 지정

**설명**: 최종 결과물을 마크다운 형식으로 출력하도록 명시적 지시.

*출처: 2개 문서*

---

#### 43. 네이밍 규칙 상세화

**설명**: 변수명, 메서드명이 "문장처럼 읽혀야 한다"는 원칙과 구체적 예시 제시.

*출처: 2개 문서*

---

#### 44. Dsl 기반 테스트 작성

**설명**: Fluent Interface로 테스트 코드를 비즈니스 언어 수준으로 작성.

*출처: 2개 문서*

---

#### 45. Vibe Coding 스펙트럼 활용

**설명**: Vibe coding은 코드 이해도에 따른 스펙트럼입니다. 자신의 기술 수준에 맞게 AI 의존도를 조절해야 합니다.

*출처: 2개 문서*

---

#### 46. 패턴 기반 아키텍처 리팩토링

**설명**: PoEAA 같은 검증된 설계 패턴 활용하여 극적 성능 향상.

*출처: 2개 문서*

---

#### 47. 이중 리팩토링 주기

**설명**: "r"-efactor(로컬 경량 리팩토링)와 "R"-efactor(시스템 전체 광범위 리팩토링) 구분.

*출처: 2개 문서*

---

#### 48. 벡터 임베딩 기반 의미 검색

**설명**: 단어나 문장을 벡터로 변환하여 의미적 관계를 수학적으로 계산하는 기법. 코사인 유사도, 유클리디안 거리, 내적 사용

**적용 조건**: 키워드가 정확히 일치하지 않아도 관련 문서를 찾고 싶을 때, 다국어 검색

*출처: 2개 문서*

---

#### 49. Tokentextsplitter를 활용한 문서 분할

**설명**: 대용량 텍스트를 토큰 기반으로 적절한 크기로 분할하여 임베딩 생성 및 검색 효율성 향상

**적용 조건**: 긴 문서를 벡터 데이터베이스에 저장할 때, LLM 컨텍스트 윈도우 제한 고려 시

*출처: 2개 문서*

---

#### 50. 자연어 기반 테스트 케이스 생성

**설명**: 자연어 시나리오를 설명하면 AI가 자동으로 Playwright 스크립트를 생성합니다. 비개발자도 테스트 자동화에 참여 가능합니다.

**적용 조건**: 테스트 커버리지 빠른 확보, 새로운 기능 개발 시 단위 테스트 생성, 레거시 코드에 테스트 추가

*출처: 2개 문서*

---

#### 51. 자가 치유 테스트 (Self-Healing Tests)

**설명**: MCP로 구동되는 GenAI가 DOM을 실시간으로 분석하여 UI 변경사항에 자동으로 적응합니다.

**적용 조건**: 빈번한 UI 변경이 있는 프로젝트, E2E 테스트 유지보수 비용 절감, 지속적 배포 환경

*출처: 2개 문서*

---

#### 52. Iterative Spec Refinement

**설명**: Agile 방식으로 각 이터레이션마다 명확한 사양을 정의하고 검증하는 접근법

**적용 조건**: 대규모 기능 개발 시 작은 단위로 나누어 각 단계마다 사양을 명확히 하고 검증

*출처: 2개 문서*

---

#### 53. Ai As Pair Programmer

**설명**: AI를 검색 엔진처럼 대하지 않고 페어 프로그래머로 활용. 개발자는 방향 설정, AI는 코드 작성 담당.

**적용 조건**: 반복적인 구현 작업이 많을 때, 개발자가 설계와 아키텍처에 더 집중

*출처: 2개 문서*

---

#### 54. Tdd 기반 Ai 코드 생성

**설명**: AI 에이전트에게 "using TDD in Python"이라고 지시하여 테스트 주도 개발 방식으로 코드를 생성합니다.

*출처: 2개 문서*

---

#### 55. Ai 논리 설명 요청

**설명**: 변경사항 이해 못할 때 AI에게 논리 설명 요청

---

#### 56. 체크포인트 (Checkpoints)

**설명**: 작업 진행 상황을 자동 저장하고 이전 상태로 즉시 롤백할 수 있는 기능

**예시**: `Esc` 두 번: 직전 체크포인트로 이동, `/rewind`: 원하는 체크포인트 선택

---

#### 57. Generator 패턴 (생성기 스킬)

**설명**: 사용자 설명으로부터 콘텐츠를 생성하는 스킬 패턴

---

#### 58. 스크립트 자동 생성 (Script Auto-Generation)

**설명**: AI에게 원하는 기능을 설명하면 컬러 출력, 체크마크 등을 포함한 정교한 쉘 스크립트를 자동 생성합니다.

**예시**: "모든 컨테이너가 건강하게 실행 중인지 확인하는 쉘 스크립트를 작성해줘"

---

#### 59. 결정론적 스크립트

**설명**: LLM 대신 확정적 결과가 필요한 단계에서 셸 스크립트 활용

---

#### 60. 의도 내장 커밋 메시지

**설명**: - "무엇이 변경되었나?" 대신 "왜 변경되었나?"에 답하는 커밋 메시지

---

#### 61. Specification의 코드화 (Specification As Code)

**설명**: - Markdown 기반 살아있는 문서(living document)로 관리

---

#### 62. Deliberative Alignment 기법

**설명**: - Specification과 도전적 입력 프롬프트 세트를 준비

---

#### 63. 피드백 루프 순환

**설명**: 계획 → 비판 → 테스트 → 구현 → 검토의 순환적 과정.

---

#### 64. 단계별 가이드 요청

**설명**: "프로젝트 생성부터 단계별로" 복잡한 작업 체계적 분해.

---

#### 65. Openapi Schema 자동 생성 기법

**설명**: GPT에게 API curl 명령어를 제공하고 OpenAPI 스키마를 자동 생성하도록 요청

**적용 조건**: GPT Actions에 API를 연결할 때 스키마를 수동 작성하기 어려운 경우

---

#### 66. 체인 오브 쏘트(Chain Of Thought) - 단계별 사고

**설명**: "단계별로 생각해서 문제를 풀어줘" 지시로 복잡한 문제 해결

**적용 조건**: 수학 문제, 로직 설명, 계획 및 전략 설계

**예시**: "Let's think step by step."

---

#### 67. 역할 기반 전문가

**설명**: 영양사, 피트니스 코치, 번역가 등 20가지 활용 사례

**적용 조건**: 다음 읽을 책 찾기, 독서 계획 수립

---

#### 68. Markdown-First 양방향 문서 생성

**설명**: Markdown을 진실의 원천으로 두고, AI/스크립트가 Java 코드와 Excel 보고서 모두 자동 생성

**적용 조건**: 공식 승인이나 비기술 이해관계자를 위해 Excel 형식이 필요한 기업 환경

---

#### 69. Test-Driven Generation (Tdg)

**설명**: 개발자가 먼저 테스트를 작성하고, AI가 해당 테스트를 통과하는 구현 코드 생성. Red-Green-Refactor에서 Green 단계를 AI가 담당

**적용 조건**: 새로운 기능 구현 시 명확한 요구사항(테스트)이 있고, 구현 코드 작성 시간 단축

---

#### 70. 마크다운 네이티브 작업 관리

**설명**: 모든 작업을 순수 마크다운 파일로 관리하여 AI가 쉽게 읽고 수정할 수 있는 구조 제공 (AI 친화적 데이터 포맷)

---

#### 71. Prd 기반 자동 작업 분해 (Prd-To-Task Decomposition)

**설명**: 자연어로 작성된 제품 요구사항 문서(PRD)를 AI가 파싱하여 실행 가능한 작업 목록으로 자동 변환하는 기법입니다. 작업 종속성 매핑과 일관된 작업 생성이 포함됩니다.

---

#### 72. 업무/생활 패턴 변화 수준의 Ai 활용

**설명**: 본인의 업무나 생활 패턴이 바뀔 정도로 AI를 활용하는 것

**적용 조건**: 80% 사용 → 40-50% 실무 적용 → 8%만 "잘 사용" 단계

---

#### 73. Ai 대체 가능성 자가 진단법

**설명**: 업무의 AI 대체 가능성을 "조직이 대체하려는 의지를 가질 만큼 단순한가"를 기준으로 판단

**적용 조건**: 정형화된 패턴, 문서화 가능한 판단 기준

---

#### 74. 업무 가치 네트워크 분석법

**설명**: 내 업무의 "카운터파티"를 파악하여 업무의 가치와 지속 가능성을 평가

**예시**: "내가 만드는 보고서를 누가 읽는가?"

---

#### 75. 이식 가능한 스킬 포트폴리오 구축법

**설명**: 조직 밖에서도 통용되는 역할과 스킬을 개발

**예시**: "우리 회사 시스템" → "업계 표준"으로 전환

---

#### 76. 100X Employee 영향력 확대 기법

**설명**: AI 리터러시가 높은 개발자가 조직 전체를 돕고 가이드하여 전체 생산성 향상

---

#### 77. Tdd + Ai 통합 워크플로우 (Kent Beck 스타일)

**설명**: 테스트를 의사소통 수단으로 활용. 테스트 먼저 작성, AI가 구현, 테스트로 검증

**관련 도구**: Cursor, Claude Code

---

#### 78. 계획 수립 후 실행 패턴

**설명**: "이 버그를 고쳐줘" 대신 "주변을 검색해서 원인을 파악하고 어떻게 고칠지 계획을 알려줘"로 요청

**관련 도구**: Claude Code

**적용 조건**: 복잡한 버그 수정이나 기능 구현 시

---

#### 79. 스마트한 페어 코딩 (Tdd + 정기 커밋)

**설명**: 테스트 주도 개발, 작은 변경 후 테스트 실행, TypeScript/린팅 검사, 정기적 커밋으로 문제 시 롤백 가능

**관련 도구**: Claude Code, Git

---

#### 80. 여러 Claude 인스턴스 동시 실행

**설명**: tmux나 다른 탭에서 4개까지 Claude 인스턴스를 동시 실행하며 오케스트레이션

**관련 도구**: Claude Code, tmux

**적용 조건**: 복잡한 프로젝트 병렬 처리 시

---

#### 81. Escape 키 활용

**설명**: Claude가 잘못된 방향으로 갈 때 Escape로 중단하고 개입, 두 번 누르면 대화에서 뒤로 이동

**관련 도구**: Claude Code

---

#### 82. 코드는 부채, 기능성이 자산 (Code As Liability)

**설명**: 코드 자체를 자산으로 보지 않고, 기능성(Functionality)만을 진정한 자산으로 인식. 한 줄도 작성하지 않고 기능을 달성할 수 있다면 더욱 좋음

**관련 도구**: 모든 AI 코딩 도구

**적용 조건**: AI 코드 생성 시대의 개발 마인드셋

---

#### 83. Ai 기반 노트 참조 및 수정

**설명**: @ 기호로 다른 노트나 폴더를 참조하여 AI가 여러 문서 맥락을 이해하고 응답 생성

**관련 도구**: Obsidian, Smart Composer 플러그인

---

#### 84. 커스텀 Ai 모델 추가

**설명**: 기본 제공되지 않는 최신 AI 모델(예: Gemini 2.5)을 사용자 정의로 추가하여 활용

**관련 도구**: Obsidian, Smart Composer, Google AI Studio

---

#### 85. Implementation Detail 구조화

**설명**: 아키텍처 결정, 설계 패턴, 구현 제약사항을 상세히 명세하여 LLM의 정확한 코드 생성 유도

**관련 도구**: Claude, Cursor

**예시**: Framework, Database, Security, 코드 커버리지 기준 등 명시

---

#### 86. Constraint(제약 조건) 명시

**설명**: DO NOT(금지 사항)과 MUST DO(필수 사항)를 명확히 정의하여 할루시네이션 방지

**관련 도구**: 모든 LLM

**예시**: "절대 하드코딩된 비밀번호 사용 금지", "모든 메서드에 Javadoc 작성"

---

#### 87. 아규먼티드 코딩 (Augmented Coding)

**설명**: 단순히 작동하는 코드가 아닌 "작동하는 깔끔한 코드(Working Clean Code)"를 목표로 AI와 협업

**관련 도구**: Claude Code

**적용 조건**: AI 코딩 도구 사용 시 품질 유지

---

#### 88. Ai 잘못된 방향 신호 감지

**설명**: 코드 반복, 요청하지 않은 기능 구현, 테스트 삭제/비활성화 등이 AI가 잘못 가는 신호

**관련 도구**: 모든 AI 코딩 도구

---

#### 89. Claude 커스텀 커맨드로 Tdd 자동화

**설명**: /tdd:go 명령어로 Red-Green-Refactor 사이클 자동 실행, plan.md로 진행 상황 추적

**관련 도구**: Claude Code

---

#### 90. Self-Pr과 피드백 요청

**설명**: 매니저에게 승진/보상 욕구를 명확히 표현하고 피드백을 적극적으로 요청

**적용 조건**: 커리어 성장 시

**예시**: "승진하고 싶은데 피드백 주세요", "제 어떤 부분이 부족합니까?"

---

#### 91. 명확한 No + 대안 제시

**설명**: "그때까지 힘들지만, 이 기능 중 정말 중요한 것이 무엇인지 알려주시면 그것은 먼저 해볼 수 있습니다"

**적용 조건**: 일정/리소스 협상 시

---

#### 92. 영향력 = 곱하기와 빼기

**설명**: 혼자 일하기(더하기) 대신 함께 일하기(곱하기)와 불필요한 일 안 하기(빼기)로 영향력 확대

**적용 조건**: 시니어→리더 성장 시

---

#### 93. 올바른 산 확인 후 효율적 노력

**설명**: 엉뚱한 산을 열심히 오르지 말고, 먼저 어느 산으로 갈지 확인한 후 효율적으로 노력

**적용 조건**: 프로젝트/커리어 방향 설정 시

---

#### 94. 리퍼럴 기반 채용 네트워크

**설명**: 이력서 AI 필터링 시대에 컨퍼런스, 해커톤, 채용 담당자 만남 등 인간관계 투자가 핵심

**적용 조건**: 취업/이직 준비 시

---

#### 95. 테스트 스위트 생성기

**설명**: 기능적 정확성, 성능 특성, 통합 지점, 보안 고려 사항 등 카테고리별 포괄적 테스트 생성

**관련 도구**: ChatGPT, Claude

---

#### 96. 코드 마이그레이션 프레임워크

**설명**: 비즈니스 로직 유지, 모범 사례 준수, 타입 매핑 등을 명시하여 레거시 코드를 새 언어/프레임워크로 마이그레이션

**관련 도구**: ChatGPT, Claude

---

#### 97. 터미널 Cmd K

**설명**: 터미널에서 Ctrl/⌘ + K로 원하는 작업을 자연어로 설명하면 명령어 생성

**관련 도구**: Cursor AI

**예시**: "100MB보다 큰 모든 파일 찾아 크기순 나열"

---

#### 98. 웹 브라우저 자동화 (Puppeteer-Mcp)

**설명**: 웹 스크래핑, 자동화 테스트, 스크린샷 캡처

---

#### 99. Ddd/Tdd에서의 Mcp 활용

**설명**: 바운디드 컨텍스트 통합 및 테스트 환경 Mock 제공

---

#### 100. Deliverables 명시 기법

**설명**: 생성해야 할 결과물 명확히 정의

---

#### 101. Refactoring Methodology

**설명**: 테스트 → 점진적 변경 → 메트릭 추적 프로세스

---

#### 102. Ci/Cd 통합 품질 게이트

**설명**: 린팅, 테스트 커버리지 파이프라인 통합

---

#### 103. Rag (Retrieval-Augmented Generation)

**설명**: 외부 데이터를 통해 실시간 정보 활용

---

#### 104. 지식 증류(Knowledge Distillation)

**설명**: Teacher→Student 모델로 지식 전달

---

#### 105. Unsloth를 활용한 효율적 Fine Tuning

**설명**: Colab에서 DeepSeek R1 파인튜닝

---

#### 106. Api 연결 사전 검증

**설명**: Apidog 등으로 통합 전 API 테스트

---

#### 107. Claude-Command-Suite 활용

**설명**: 추가 명령어 기능 확장

---

#### 108. Pngpaste 스크린샷 활용

**설명**: 스크린샷 쉽게 전달

---

#### 109. 사이드 패널 모드 사용

**설명**: CC 아이콘으로 사이드 패널 열기

---

#### 110. 커뮤니티 지식 활용

**설명**: Medium 등에서 실용적 팁 수집

---

#### 111. 의존성 및 환경 확인하기

**설명**: Python 버전, OS 호환성 등 사전 요청

---

#### 112. Ai를 활용한 Mvp 개발 후 전문가 투입

**설명**: 로우코드/AI로 MVP 후 전문가 발전

---

#### 113. Ai 증강(Augmentation) 접근법

**설명**: AI를 대체가 아닌 증강 관점에서 활용

---

#### 114. 다중 솔루션 요청 기법

**설명**: "세 가지 다른 버전" 요청으로 이중 시야 효과

---

#### 115. 설계 개선 도전 기법

**설명**: "더 나은 테스트가 가능하도록 5가지 아이디어" 요청

---

#### 116. "Sleepwalking Through Greens" 경고

**설명**: AI 테스트 생성의 안티패턴 인식

---

#### 117. 작업 유형별 모델 선택 전략

**설명**: 작업 특성에 맞게 AI 모델 선택 (알고리즘: O4-Mini-High, 유틸리티: Gemini, 프로토타이핑: Claude)

---

#### 118. Rag를 통한 도메인 전문 Ai 구축

**설명**: 오픈소스 LLM + 기업 전문 문서를 벡터 DB에 인덱싱하여 전문가 AI 구축

---

#### 119. 스케일 업 접근법 (모델 크기 확장)

**설명**: 모델 규모, 데이터량, 연산량 확장을 통한 성능 향상

---

#### 120. 완벽함을 기다리지 않고 먼저 사용하기

**설명**: "오늘 쓰는 AI가 가장 후진 AI" 인식으로 경쟁자보다 먼저 경험

---

#### 121. 자신의 강점 분야에서 Ai 활용 극대화

**설명**: 자신이 가장 잘하는 분야에 AI를 결합하여 시너지 창출

---

#### 122. 마이크로서비스 구조화

**설명**: 작은 코드베이스가 AI와 더 잘 작동

---

#### 123. 기능 테스트 우선

**설명**: AI 워크플로우에서는 단위 테스트보다 기능 테스트가 효과적

---

#### 124. Thinking 모델 전용 사용

**설명**: 개발에는 고급 모델(Opus, Sonnet 등) 사용

---

#### 125. Llm 응답의 자동 타입 변환

**설명**: Spring AI로 LLM JSON 응답을 Java 객체로 자동 변환

---

#### 126. 스트리밍 응답 구현

**설명**: Flux<String>으로 LLM 응답 실시간 스트리밍

---

#### 127. Llm 독립적 추상화 계층 활용

**설명**: Spring AI 추상화로 LLM 벤더 교체 시 설정만 변경

---

#### 128. 벡터 데이터베이스를 이용한 시맨틱 검색

**설명**: PGVector 등으로 의미 기반 문서 검색

---

#### 129. 로컬 Llm 활용 (Ollama)

**설명**: 프라이버시/비용 문제 해결을 위한 로컬 모델 활용

---

#### 130. 재시도 로직 구현

**설명**: API 호출 실패 시 자동 재시도

---

#### 131. Http 클라이언트 재사용

**설명**: 클라이언트 싱글톤 관리로 연결 오버헤드 감소

---

#### 132. Ai + 도메인 데이터 결합 전략

**설명**: 범용 LLM + 도메인 특화 RAG 시스템

---

#### 133. 지적인 정직함

**설명**: 모르는 것은 인정, 잘못된 결정은 빠르게 방향 수정

---

#### 134. 카니발라이제이션 혁신

**설명**: 자사 기존 제품을 AI 기반으로 스스로 대체

---

#### 135. 주관성 제거 보고서 작성

**설명**: 형용사/부사 제거, 정량 데이터 중심 문서화

---

#### 136. 도메인 지식 레이어드 접근

**설명**: Domain + Functional + Disciplinary Knowledge 위에 AI 활용

---

#### 137. 전용 Ai 작업 공간 설정

**설명**: 코딩 환경과 AI 브레인스토밍 환경 분리

---

#### 138. 컴포넌트 분석 요청

**설명**: 프로젝트를 관리 가능한 컴포넌트로 분해 요청

---

#### 139. 기술 선택 비교 요청

**설명**: 기술 옵션의 장단점 비교 분석 요청

---

#### 140. 디자인 패턴 탐색 요청

**설명**: 기능에 적합한 디자인 패턴 추천 및 구현 방법 요청

---

#### 141. Ai 코딩 워크플로우 7단계

**설명**: 사양 → 생성 → 검토 → 반복 → 테스트 → 최적화 → 문서화

---

#### 142. Ai 의존 시 4가지 함정

**설명**: 큰 그림, 복잡한 솔루션, 기본 개념, 성능 주의

---

#### 143. 살아있는 문서화 전략

**설명**: 문서 버전 관리, 코드 변경 시 업데이트, 주기적 검토

---

#### 144. 고무오리 디버깅 효과

**설명**: AI에게 설명하면서 코드 개선점 발견

---

#### 145. Ai-Dlc (Ai-Driven Development Lifecycle)

**설명**: AWS 제안 방법론

---

#### 146. Bolt-Based Rapid Iteration

**설명**: Sprint 대신 시간/일 단위 빠른 반복

---

#### 147. 코드베이스 탐색 → 이해 → 수정 패턴

**설명**: 프로젝트 구조 설명 요청으로 시작하여, 최상위 파일부터 점진적으로 깊이 탐색한 후 코드를 수정하는 단계적 접근법

---

#### 148. 원커맨드 커밋

**설명**: `claude commit` 명령으로 변경사항 분석, 커밋 메시지 생성, 커밋 실행을 한 번에 처리

---

#### 149. Aws Bedrock 연동

**설명**: 환경 변수 설정을 통해 AWS Bedrock에서 Claude 모델을 사용하는 엔터프라이즈 배포 패턴

---

#### 150. 자동화된 테스트 생성 요청

**설명**: 구현한 기능에 대해 구체적인 검증 포인트를 명시하여 테스트 코드 생성을 요청

---

#### 151. 프로젝트 기능 활용 (Project Feature Utilization)

**설명**: Claude Desktop의 Projects 기능을 사용하여 관련 파일과 채팅을 함께 관리

---

#### 152. 사용량 모니터링 및 피크 시간 관리

**설명**: 피크 시간대에는 제한이 더 엄격할 수 있으므로, 중요한 작업은 비피크 시간에 수행

---

#### 153. 다중 Ai 백업 전략 (Multi-Ai Backup Strategy)

**설명**: Claude 한도 도달 시를 대비하여 ChatGPT, DeepSeek 등 다른 AI를 백업으로 준비

---

#### 154. 이중 구독 전략 (Dual Subscription Rotation)

**설명**: 2개의 Claude 구독을 유지하여 한 계정의 한도에 도달하면 다른 계정으로 전환

---

#### 155. Plan Mode (Opus Mode) 활용

**설명**: 구체적인 방법(How)을 지시하는 대신, 원하는 결과(What)만 기술하고 Claude가 계획을 제시하면 대화를 통해 방향을 조정

**예시**: Plan을 문서로 저장 후 다음 세션에서 검토/보완 요청

---

#### 156. 사전 결과 상(像) 기반 접근법

**설명**: 결과에 대한 명확한 이미지가 있는지 여부에 따라 AI 활용 전략을 다르게 적용

---

#### 157. 인덱싱 및 문맥 최적화

**설명**: 대량의 문서에서 효율적인 토큰 사용을 위해 hierarchical tag를 생성하고 분석

---

#### 158. Hot Key 활용

**설명**: `Ctrl-C`로 작업 중단/취소 등 빠른 제어를 위한 단축키 활용

---

#### 159. Imagine With Claude 실시간 소프트웨어 생성

**설명**: Claude가 실시간으로 소프트웨어를 생성하고 사용자 요청에 응답하며 적응하는 실험적 기법

---

#### 160. 훅 (Hooks) 자동 실행

**설명**: 테스트/린트 등을 자동으로 실행하여 코드 품질을 유지하면서 장기 작업을 수행

---

#### 161. 다단계 추론 및 코드 이해력

**설명**: 복잡한 코드베이스 전반의 작업을 더 잘 처리할 수 있는 다단계 추론 능력

---

#### 162. 네스티드 제약조건

**설명**: `<constraints>` 태그 내에 여러 하위 태그를 중첩하여 복잡한 제약조건을 계층적으로 정의

---

#### 163. 빠른 테스트 주도 개발 사이클

**설명**: 렌더링 성능 개선으로 고빈도 상호작용 세션에서 TDD 사이클을 가속화

---

#### 164. Todo 시스템을 통한 작업 추적

**설명**: ToDo.md 파일을 자동 생성하여 개발 진행 상황 추적 방식을 지식관리에 적용

---

#### 165. Moc(Map Of Contents) 기반 지식 구조화

**설명**: MOC 시스템을 구축하여 지식 간의 연결과 전체적인 구조를 시각화

---

#### 166. 연결 아이디어 자동 제안

**설명**: AI가 문서 내용을 분석하여 관련된 아이디어들을 자동으로 제안

---

#### 167. Progressive Disclosure Architecture (Pda)

**설명**: 전체 문서를 한 번에 로드하는 대신, 필요한 참조 문서만 온디맨드로 로드하여 80-95% 토큰 절약

---

#### 168. 5Kb/10Kb 규칙

**설명**: 스킬 크기에 따른 설계 가이드라인. 10KB 초과 시 PDA 적용 고려

---

#### 169. 세 가지 스킬 활성화 방법

**설명**: 명시적 커맨드, 자연어 인식, CLAUDE.md 사전 가이드의 세 가지 방법

---

#### 170. 잘 설계된 스킬 파일 구조

**설명**: 스킬 파일의 표준 구조: YAML frontmatter → 제목 → 설명 → 활성화 조건 → 단계별 프로세스

---

#### 171. 단일 책임 원칙

**설명**: 스킬은 하나의 잘 정의된 작업에 집중해야 함

---

#### 172. 스크립트 분리 및 테스트 가능성

**설명**: API 호출, 데이터 처리 등 기계적 작업은 외부 스크립트로 분리

---

#### 173. 탐색적 프로젝트 분석 (Exploratory Project Analysis)

**설명**: Goose는 탐색적 방식으로 작동하여 프로젝트 구조와 기능을 스스로 파악합니다. REST API 분석, 엔티티 구조 파악, 환경 설정 방법 탐지 등을 자동으로 수행하여 새로운 코드베이스에 빠르게 적응할 수 있습니다.

**예시**: `goose session` 실행 후 "이 프로젝트의 REST API 구조를 설명해줘"라고 요청하면, AI가 자동으로 코드를 분석하여 엔드포인트, 요청 형식, 상태 코드 등을 설명

---

#### 174. 점진적 대화형 개발 (Iterative Conversational Development)

**설명**: 테스트 생성 후 결과를 확인하고, 원하는 동작과 다른 부분을 발견하면 추가 요청을 통해 코드를 수정합니다.

**예시**: 테스트 생성 → 실행 → 동작 수정 요청 → 프로덕션+테스트 코드 수정

---

#### 175. 엣지 케이스 자동 식별 (Automatic Edge Case Identification)

**설명**: AI 에이전트는 테스트 케이스 생성 시 다양한 긍정적, 부정적 사례와 엣지 케이스를 자동으로 식별합니다.

**예시**: 문자열 대문자화 테스트 시 일반/대문자/소문자/혼합/단일/빈/null 케이스 자동 생성

---

#### 176. 자동 다이어그램 생성 (Automatic Diagram Generation)

**설명**: AI가 `@Entity` 어노테이션 등 코드 패턴을 검색하여 엔티티와 관계를 파악하고, ER 다이어그램이나 아키텍처 다이어그램을 자동 생성합니다.

**예시**: "please create an ER diagram showing the database entities and their relationships"

---

#### 177. Llm 백엔드 최적 선택 (Llm Backend Selection)

**설명**: 다양한 LLM 제공업체를 시도해 보고, 현재 작업에 가장 적합한 모델을 선택합니다.

**예시**: `goose configure` 명령으로 Anthropic Claude를 백엔드로 설정

---

#### 178. 추상화 발견 시 Llm 브레인스토밍 파트너 활용

**설명**: 추상화 발견과 안정화 과정은 창의적 활동으로, LLM에 통제권을 넘기지 않고 개발자가 주도권을 유지하면서 브레인스토밍 파트너로 활용합니다.

**예시**: "이 도메인에서 어떤 추상화가 적절할지 몇 가지 옵션을 제안해줘" 요청 후 개발자가 최종 결정

---

#### 179. 안정된 추상화의 기계적 작업 위임

**설명**: 추상화가 안정된 후에는 새로운 사용 사례나 변형 구현과 같은 반복적이고 기계적인 코딩 작업을 LLM에 위임합니다.

**예시**: Repository 패턴이 확립된 후, 새로운 엔티티에 대한 Repository 구현은 LLM에 맡기고 개발자는 리뷰만 수행

---

#### 180. 피드백 루프 기반 점진적 개발

**설명**: 컴파일러와의 상호작용처럼 LLM도 피드백 메커니즘으로 활용합니다. 첫 번째 명세는 가설로 취급하고 반복적 개선을 통해 발전시킵니다.

**예시**: 초기 구현을 LLM과 함께 빠르게 만들고, 실행 결과와 피드백을 바탕으로 설계를 점진적으로 개선

---

#### 181. 검색 모드 전환 (R @, Rr @)

**설명**: `R @`(짧은 글)와 `RR @`(긴 글) 접두어를 사용하여 검색 결과의 상세 수준을 조절합니다.

**예시**: 빠른 개요: `R @TDD 핵심 원칙`, 상세 분석: `RR @TDD 테스트 작성 방법론`

---

#### 182. Maps Of Content (Moc) 관리

**설명**: Obsidian의 폴더 구조(Inbox → Notes → Assets → MOC)와 AI를 결합하여 지식을 체계적으로 조직화합니다.

**예시**: Inbox에 빠르게 노트 작성 → AI에게 "이 노트가 어떤 MOC에 포함되어야 할지 분석해줘" 요청

---

#### 183. 코드 구조화 요청 패턴

**설명**: 코드 구조화 시 사용하는 프레임워크(Next.js 14), 라우터 방식(App Router), 언어(TypeScript) 등을 명시적으로 지정합니다.

**예시**: "please use nextjs 14 standards not the pages router but app router"

---

#### 184. 프레임워크 특화 요청

**설명**: shadcn/ui, Tailwind CSS 등 특정 UI 라이브러리 스타일을 명시하여 일관된 디자인 언어로 컴포넌트를 생성합니다.

**예시**: "please make them look more shadcn ui's... minimalistic feel but premium startup"

---

#### 185. 모달/인터랙션 동적 추가

**설명**: 정적 UI를 먼저 완성한 후, 클릭 이벤트, 모달, 애니메이션 등 동적 기능을 별도 요청으로 추가합니다.

**예시**: "When you click on one of the table elements, open a modal with the information inside each row editable"

---

#### 186. 피드백 메커니즘 구축

**설명**: LLM에게 적절한 피드백을 제공하는 메커니즘(타입 에러, 임시 스크립트, 유닛 테스트, e2e 테스트 등)을 구축합니다.

**예시**: AI가 생성한 코드를 즉시 타입 체커로 검증, 유닛 테스트 결과를 AI에게 피드백

---

#### 187. Ai 강점/약점 영역 구분

**설명**: AI가 잘하는 영역과 실패하는 영역을 명확히 구분하여 적재적소에 활용합니다.

**예시**: - AI에게 맡기기 좋은 작업: 새 앱 스캐폴딩, 기본 테스트 작성, 리팩토링

---

#### 188. 아키텍처 수준 유지

**설명**: AI와 작업할 때 너무 세부적인 버그 수정에 빠지지 않고 높은 수준의 아키텍처 관점을 유지합니다.

**예시**: 특정 버그 수정을 여러 번 요청하기보다, "이 모듈의 전체 구조를 검토하고 개선 방안을 제안해줘"로 수준을 높임

---

#### 189. Ooda 루프 기반 동적 재계획

**설명**: 각 Action 완료 후 시스템이 조건을 재평가하고 새로운 정보에 적응하여 재계획합니다.

**예시**: 에이전트가 데이터 수집 후 예상치 못한 결과를 발견하면 자동으로 대안 경로를 선택

---

#### 190. 하이브리드 계획 시스템 (Non-Llm Ai)

**설명**: 계획 단계에서 LLM이 아닌 전통적인 AI 알고리즘을 사용하여 정교한 계획을 수립합니다.

**예시**: 새로운 Action을 추가하면 플래너가 자동으로 기존 워크플로우에 통합

---

#### 191. 다중 Llm 조합 활용 (Llm Mixing)

**설명**: 서로 다른 LLM의 강점을 활용하여 작업별로 최적의 모델을 혼합 사용합니다.

**예시**: 단순 분류 작업에는 경량 모델, 복잡한 추론에는 고성능 모델을 자동 선택

---

#### 192. 에이전트 테스트 용이성 설계

**설명**: 처음부터 테스트 용이성을 고려하여 설계되었습니다. 단위 테스트와 종단간 테스트 모두 쉽게 수행할 수 있습니다.

**예시**: 개별 Action을 모킹하여 단위 테스트, 전체 에이전트 플로우를 시뮬레이션하여 통합 테스트

---

#### 193. 비Llm Ai 알고리즘 기반 자동 계획 (Goap)

**설명**: LLM에 의존하지 않는 AI 알고리즘을 사용하여 계획을 수립합니다. 결정론적이고 설명 가능한 계획을 제공합니다.

**예시**: 복잡한 비즈니스 워크플로우에서 상태 머신을 수동으로 연결하지 않고 시스템이 자동으로 최적 경로를 계획

---

#### 194. 작업별 최적 모델 선택 (Model Mixing)

**설명**: 단일 "신과 같은" 모델에 의존하지 않고, 작업 특성에 따라 로컬, 저렴한, 프라이빗 모델을 혼합하여 사용합니다.

**예시**: 민감하지 않은 텍스트 분류는 로컬 모델로, 복잡한 추론은 클라우드 LLM으로 라우팅

---

#### 195. Llm을 활용한 자연어 → 구조화 데이터 변환

**설명**: 사용자의 자연어 메시지를 LLM 호출을 통해 구조화된 객체로 변환한다.

**적용 조건**: 챗봇 기반 주문 시스템, 자연어 명령을 시스템 액션으로 변환

---

#### 196. Mcp Inspector를 활용한 에이전트 테스트

**설명**: MCP Inspector 도구를 사용하여 MCP 서버에 SSE로 연결하고 에이전트를 테스트하고 디버깅한다.

**적용 조건**: AI 에이전트 개발 중 빠른 테스트와 디버깅

---

#### 197. 기술 부채 속도 측정

**설명**: AI 생성 코드로 인한 기술 부채 증가 속도를 측정합니다. 부채 생성 대 해결 비율, AI 코드 리팩터링 빈도 등을 핵심 지표로 추적합니다.

**적용 조건**: 스프린트 회고 시

---

#### 198. Ai 책임 소재 명확화

**설명**: "AI가 그렇게 했어요"라는 면책은 인정하지 않습니다. AI가 나쁜 코드를 제안하더라도 최종 수용 결정을 내린 개발자에게 책임이 있음을 명확히 합니다.

**적용 조건**: 팀 가이드라인 수립 시

---

#### 199. 레거시 시스템용 Ai 가드레일

**설명**: AI는 최신 패턴에 편향되어 있으므로 레거시 시스템에는 별도의 규칙을 적용합니다.

**적용 조건**: 레거시 시스템 유지보수 시

---

#### 200. 출처 추적 시스템

**설명**: AI가 생성하거나 추천한 코드의 출처, 검토자, 마지막 업데이트 시점을 추적합니다.

**적용 조건**: 보안 감사 시

---

#### 201. 무차별 수정 대신 근본 원인 진단 유도

**설명**: AI가 문제를 해결할 때 "왜 이 문제가 발생했는지"를 먼저 분석하도록 유도합니다.

**적용 조건**: 빌드 오류, 성능 문제 해결 시

---

#### 202. Ai 테스트 생성 시 중복 검토

**설명**: AI는 기존 테스트에 어설션을 추가하는 대신 새 테스트 함수를 만드는 경향이 있습니다. 사용자 지정 지침으로 이를 완화합니다.

**적용 조건**: AI로 테스트 코드를 생성할 때

---

#### 203. "빠른 해결책"의 유지보수 비용 평가

**설명**: 현재 잘 작동하지만 미래에 변경하기 어려운 코드인지 판단하는 경험적 안목이 필요합니다.

**적용 조건**: AI가 빠르게 해결책을 제시했을 때

---

#### 204. Youtube 트랜스크립트 자동 분석

**설명**: `fabric -y [YouTube URL]` 명령으로 영상의 트랜스크립트를 자동 추출하고 AI 패턴과 결합하여 인사이트를 추출합니다.

**적용 조건**: 긴 강의/발표 영상 요약

---

#### 205. 전문가 역할 기반 코드 리뷰 (Ask_Uncle_Duke)

**설명**: Java/Spring 전문가 페르소나를 가진 패턴이 SOLID, DRY, TDD, 클린 코딩 원칙에 따라 코드를 분석합니다.

**적용 조건**: 코드 리뷰, 리팩토링 제안 받기

---

#### 206. Agility_Story / Create_User_Story 패턴

**설명**: 기능 요구사항을 입력하면 사용자 스토리 형식과 인수 조건을 자동 생성합니다.

**적용 조건**: 스프린트 계획, 백로그 작성

---

#### 207. 학술 콘텐츠 심층 분석 (Analyze_Paper)

**설명**: URL이나 텍스트를 입력하면 논문/기사의 핵심 주장, 방법론, 결론을 체계적으로 분석합니다.

**적용 조건**: 기술 블로그 리뷰, 학술 논문 빠른 파악

---

#### 208. 재귀적 아웃라인 생성 (Create_Recursive_Outline)

**설명**: 주제를 입력하면 UI, 백엔드, 데이터베이스, 보안, 테스트, 배포까지 포괄하는 계층적 프로젝트 아웃라인을 자동 생성합니다.

**적용 조건**: 프로젝트 기획 초기 단계

---

#### 209. Jina Ai 기반 웹 스크래핑

**설명**: `-u` 옵션으로 웹페이지 URL을 마크다운으로 변환하여 AI 분석의 입력으로 활용합니다.

**적용 조건**: 온라인 기사 요약, 기술 문서 빠른 파악

---

#### 210. Crawl4Ai 웹 스크래핑

**설명**: Crawl4AI를 사용하여 웹페이지의 HTML을 LLM이 이해하기 쉬운 깔끔한 마크다운으로 자동 변환합니다.

**적용 조건**: LLM에 최신 웹 정보를 제공해야 할 때

---

#### 211. 브라우저 세션 재사용 크롤링

**설명**: 동일한 브라우저 세션을 재사용하여 여러 URL을 효율적으로 크롤링합니다.

**적용 조건**: 동일 도메인의 여러 페이지를 순차적으로 수집할 때

---

#### 212. Supabase/Pgvector Rag 파이프라인

**설명**: 크롤링한 마크다운 콘텐츠를 임베딩으로 변환하여 벡터 데이터베이스에 저장하고 유사도 검색을 수행합니다.

**적용 조건**: 특정 도메인 지식 기반의 AI 챗봇을 구축할 때

---

#### 213. 실시간 웹 지식베이스 생성

**설명**: Crawl4AI와 RAG를 결합하여 어떤 웹사이트든 LLM을 위한 동적인 지식베이스로 변환합니다.

**적용 조건**: 기업 내부 문서 기반 AI 어시스턴트 구축 시

---

#### 214. 벡터 임베딩 기반 코드베이스 인덱싱

**설명**: 벡터 임베딩을 사용해 코드베이스 전체를 인덱싱하여 의미론적 코드 탐색이 가능해집니다.

**적용 조건**: 대규모 레거시 코드베이스를 파악해야 할 때

---

#### 215. 계획 우선 접근법(Plan-First Approach)

**설명**: AI에게 코드 작성을 요청하기 전에 먼저 계획 수립을 요청합니다.

**적용 조건**: 복잡한 기능을 구현할 때

---

#### 216. Ai 실수 패턴 인식

**설명**: AI가 자주 저지르는 실수 패턴을 인식합니다: 무차별 대입 수정, 과도한 모킹 등.

**적용 조건**: AI 생성 코드를 리뷰할 때

---

#### 217. 통제력 상실 시점 인식

**설명**: AI와의 작업 세션에서 통제력을 잃었다고 느끼는 순간을 인식하고, 그 시점에서 작업을 중단합니다.

**적용 조건**: AI가 예상치 못한 방향으로 코드를 변경할 때

---

#### 218. 문제 분해 후 계획 수립 (Problem Decomposition)

**설명**: 요구사항을 바로 코드로 변환하지 않고, 먼저 하위 작업을 목록으로 정리한 후 단계별로 진행합니다.

**적용 조건**: 새로운 기능 개발 요청 시

---

#### 219. Ai 기반 테스트 자동화 사이클

**설명**: AI가 테스트 작성, 실행, 실패 원인 분석, 반복 개선까지 전 과정을 지원합니다.

**적용 조건**: TDD 방식의 개발 시

---

#### 220. 사이드바 기반 Ai 대화 인터페이스

**설명**: Leader 키 조합으로 AI 사이드바를 열고, 코드 작성 흐름을 유지하면서 AI와 상호작용이 가능합니다.

**적용 조건**: 코딩 중 컨텍스트 스위칭 없이 AI에게 질문할 때

---

#### 221. 코드 블록 네비게이션을 통한 Ai 결과 탐색

**설명**: `[[`와 `]]` 단축키로 AI가 생성한 코드 블록들 사이를 빠르게 이동할 수 있습니다.

**적용 조건**: AI가 여러 코드 섹션을 제안했을 때 빠르게 검토할 때

---

#### 222. Ollama를 통한 로컬 Ai 모델 실행

**설명**: Ollama 프레임워크를 사용하여 오픈소스 LLM을 로컬 컴퓨터에서 실행합니다. 인터넷 연결 없이 완전한 오프라인 환경에서 AI 모델을 활용할 수 있습니다.

**적용 조건**: 민감한 데이터를 다룰 때, API 비용을 절감하고 싶을 때

---

#### 223. Docker 기반 로컬 Ai 웹 인터페이스 구축

**설명**: Docker와 Open Web UI를 결합하여 로컬 AI 모델에 ChatGPT와 유사한 웹 인터페이스를 제공합니다.

**적용 조건**: 팀 내 비개발자도 로컬 AI를 쉽게 사용하도록 할 때

---

#### 224. 하드웨어 사양에 맞는 Llm 모델 크기 선택

**설명**: 7B, 32B, 70B 등 다양한 크기의 모델 중 현재 하드웨어 사양에 맞는 모델을 선택합니다.

**적용 조건**: 개인용 노트북에서 AI를 활용할 때

---

#### 225. 완전 오프라인 Ai 개발 환경 구성

**설명**: Ollama + Docker + Open Web UI 조합으로 인터넷 연결 없이 동작하는 AI 환경을 구축합니다.

**적용 조건**: 고객 데이터, 의료 정보 등 민감한 데이터 분석 시

---

#### 226. "코드는 저렴하지만, 사고는 그렇지 않다"

**설명**: AI가 코드 작성 비용을 낮췄기 때문에 설계와 아키텍처에 대한 사고력이 더 중요

---

#### 227. Planning Spectrum

**설명**: 작업 복잡도에 따라 계획 수준 조절 (바이브 코딩 ↔ 철저한 계획)

---

#### 228. 해당 없음 문서

**설명**: 0개 (모든 문서에서 기법 추출 성공)

---

#### 229. 아키텍처 브레인스토밍에 활용

**설명**: 구현 전에 AI와 아키텍처 접근 방식을 브레인스토밍하여 더 나은 설계 결정.

---

#### 230. 테스트 케이스 자동 생성

**설명**: 복사-붙여넣기 테스팅에서 벗어나 AI를 통해 다양한 시나리오와 엣지 케이스를 포함한 테스트 생성.

---

#### 231. @Achievesgoal로 최종 목표 지정

**설명**: 최종 목표 액션에 어노테이션을 붙여 GOAP이 자동으로 액션 시퀀스 계획

---

#### 232. Record 클래스를 활용한 도메인 모델

**설명**: Java record로 간결하게 LLM 응답 구조 정의

---

#### 233. Rest Api 생성 프롬프트 패턴

**설명**: `Implement REST API for CRUD operations with [entity]. For testing purpose, create and run seed...` - API 구현, 시드 데이터, 테스트까지 자동화

---

#### 234. Ai 에이전트의 반복적 작업 패턴 이해

**설명**: 계획 수립 → 코드 생성 → 구성 파일 변경 → 테스트 실행 → 결과 검증 → 코드 수정

---

#### 235. 승인 기반 작업 제어

**설명**: 파일 편집이나 명령 실행 전 diff 미리보기로 확인 후 수락/거부

---

#### 236. Decline(거부) 기능 활용

**설명**: 제안이 마음에 들지 않으면 decline하여 다른 접근 방식 요청

---

#### 237. Openai 호환 Api로 Bedrock 사용하기

**설명**: 환경변수 `OPENAI_API_KEY=bedrock`과 `OPENAI_BASE_URL` 설정으로 OpenAI SDK로 AWS Bedrock 모델 호출

---

#### 238. Aws Bedrock Rag 구축 워크플로우

**설명**: S3 생성 → RAG 파일 업로드 → Knowledge Base 구성 → S3 chunking → Embedding 모델 설정 → Vector DB 구성 → Knowledge Base Sync → Test

---

#### 239. 사고적 글쓰기 Vs 귀찮은 글쓰기 구분

**설명**: AI는 정형화된 '귀찮은 글쓰기'에 적합, 사고력 필요한 작업은 직접 수행

---

#### 240. 보일러플레이트 작업에 Ai 활용

**설명**: 반복적이고 기계적인 작업에만 AI 사용, 창의적 판단 필요한 영역은 직접 수행

---

#### 241. 전사적 마스터플랜 우선 접근법

**설명**: 개별 부서 PoC가 아닌 전체 조직의 데이터 지도, 모델 책임 경계선, 변경 관리 로드맵 먼저 설계

---

#### 242. 외부 파트너십 활용 전략

**설명**: 내부 빌드(성공률 33%)보다 외부 파트너십(성공률 67%) 적극 활용

---

#### 243. Poc 함정 회피 체크리스트

**설명**: 트렌드 추종 경계, 미스얼라인먼트 점검, 내부 빌드의 오만 경계

---

#### 244. 종단 간(End-To-End) 지표 관리

**설명**: 부서별 KPI가 아닌 회사 전체 성과를 측정하는 종단 간 지표 관리

---

#### 245. 메타인지 기반 역할 정의

**설명**: "나는 도시 아키텍트인가, 건물 설계사인가, 배관공인가?" 파악

---

#### 246. 변화 관리와 온보딩 중심 접근

**설명**: 기술적으로 완벽한 시스템도 사용자가 채택하지 않으면 무의미

---

#### 247. Plan 모드와 @Symbol 참조

**설명**: 복잡한 작업 전 계획 검토, 코드 심볼 직접 참조로 정확성 향상

---

#### 248. 작은 단계(Small Steps) 원칙 적용

**설명**: - AI에게 한 번에 하나씩 사용자 스토리와 테스트 케이스 작성 요청

---

#### 249. 첫 테스트로 패턴 확립

**설명**: - 첫 번째 테스트를 수동으로 작성하여 스타일과 컨벤션 확립

---

#### 250. 시스템 지시문과 특수 주석 활용

**설명**: - AI의 행동을 제어하기 위한 시스템 지시문 설정

---

#### 251. 우발적 복잡성 Ai 위임

**설명**: - 도메인/유스케이스 레이어는 TDD로 직접 작성

---

#### 252. Tdd 통합 방안

**설명**: - AI에게 명시적으로 테스트 작성을 먼저 요청하여 Red-Green-Refactor 유도

---

#### 253. 아키텍처 설계 역할 강화

**설명**: - AI가 단순 구현 담당, 인간은 시스템 설계와 아키텍처 결정에 집중

---

#### 254. Ai를 "영혼 없는 필사자(Scriber)"로 활용하기

**설명**: - AI에게 루틴한 코드 생성을 위임, 인간은 의미와 맥락의 "왜(Why)"를 보유

---

#### 255. Why.Md 파일 작성

**설명**: - 모든 모듈의 루트에 존재 이유를 설명하는 문서 추가

---

#### 256. Adr(Architecture Decision Records) 유지

**설명**: - "무엇"뿐만 아니라 "왜"를 설명하는 의사결정 기록 유지

---

#### 257. Ai를 조종사 보조 모델로 활용

**설명**: - AI가 분석을 담당하고, 인간이 최종 판단과 의사결정을 책임

---

#### 258. 패턴 분석 작업에 Ai 활용

**설명**: - 사용자 피드백 분석으로 반복되는 테마 발견

---

#### 259. 회고(Retrospective) 노트 분석

**설명**: - AI를 사용해 회고 노트의 패턴 발견

---

#### 260. Ai 결과물을 시작점으로 활용

**설명**: - AI가 생성한 텍스트나 초안을 완성된 작업이 아닌, 인간이 개선하기 위한 시작점으로 취급

---

#### 261. 모호성 제거 도구 활용 (Integrated Thought Clarifier)

**설명**: - Specification 작성 시 모호성을 끌어내고 명확히 하는 도구 활용

---

#### 262. 다중 이해관계자 정렬 (Multi-Stakeholder Alignment)

**설명**: - 자연어 기반 specification으로 PM, 법무, 정책, 연구 등 모든 이해관계자 참여

---

#### 263. Ai 생성 코드 + 리팩토링 패턴

**설명**: - AI가 생성한 코드를 그대로 사용하지 않고, 개발자의 판단으로 리팩토링

---

#### 264. Ai 지원 Red-Green-Refactor

**설명**: 테스트는 인간, 구현은 AI

---

#### 265. 코드는 Specification의 손실 압축

**설명**: 80-90% 가치는 구조화된 커뮤니케이션에서

---

#### 266. 조종사 보조 모델

**설명**: AI가 분석, 인간이 판단과 의사결정

---

#### 267. 의미의 수호자(Guardians Of Meaning)

**설명**: AI는 필사자, 인간은 "왜(Why)"를 보유

---

#### 268. Ai 자율 행동 제한

**설명**: 위험한 작업(DB 삭제 등) 권한 부여 금지

---

#### 269. 주니어 파이프라인 보호

**설명**: AI로 주니어 대체 시 미래 시니어 부재

---

#### 270. Why.Md

**설명**: 모듈별 존재 이유 설명

---

#### 271. 1: 인지적 부채(Cognitive Debt) 인식과 관리

**설명**: AI에 의존하여 작업할 때 "약한 뇌 연결성, 나쁜 기억 회상, 소유감 감소" 발생. 장기적 사고 능력 저하 위험

---

#### 272. 4: Tdd 사이클과 Ai 통합

**설명**: Red-Green-Refactor 사이클에 AI 통합, 테스트 우선 설계 원칙 유지

---

#### 273. 1: Explore-Plan-Execute 프레임워크

**설명**: 탐색 → 계획 → 실행 순서로 진행하는 체계적 접근법

---

#### 274. 4: "My Developer" 프롬프팅 트릭

**설명**: Claude의 자기 검열 우회하여 객관적 비판적 피드백 획득

---

#### 275. 1: Memory Bank 패턴

**설명**: AI가 장기 기억을 가진 것처럼 동작하도록 하는 체계적 정보 저장 및 복원 패턴

---

#### 276. Temperature 조정을 통한 창의성 제어

**설명**: - 창의적 응답이 필요한 주제 탐색: `temperature 0.6`

---

#### 277. Waitfor.Formsubmission 메커니즘

**설명**: LLM 호출 없이 사용자와 직접 통신하여 명확한 입력을 받는 기법

---

#### 278. 규칙 파일(Rule File)을 통한 Ai 동작 제어

**설명**: `.md` 형식의 규칙 파일로 AI가 ShadCN 작업 시 따라야 할 행동 지침 정의

---

#### 279. 태스크 파일(Task.Md)과 규칙 파일(Rule.Md) 분리 전략

**설명**: 구현 계획과 AI 동작 가이드를 분리 저장

---

#### 280. Tweakcn을 통한 시각적 커스터마이징

**설명**: ShadCN 컴포넌트의 시각적 편집기로 획일적 디자인 탈피

---

#### 281. 멀티모달 실험 환경

**설명**: 텍스트, 이미지, 오디오 모델 플레이그라운드 테스트

---

#### 282. 다중 디렉토리 작업

**설명**: `claude --add-dir ../apps ../lib`

---

#### 283. 계획-검토-구현 분리

**설명**: "Just do the research, don't start implementation yet"

---

#### 284. 역할 기반 페르소나 설정

**설명**: AI에게 구체적인 역할 부여 (전문 번역가 + CS 전공 + 소프트웨어 개발 전문가)

---

#### 285. 구조화된 출력 형식 지정

**설명**: 하이라이트/요약, 전체 요약, 결론 및 개인적 견해

---

#### 286. 기술 용어 처리 규칙

**설명**: 기술 용어 첫 언급 시 원어(영어) 괄호 표기

---

#### 287. 제약 조건 명확화

**설명**: 스크립트에 없는 내용 추가 금지, 타임라인 보존

---

#### 288. 상세한 구조 가이드라인 제공

**설명**: README 포함 섹션 구체적 명시

---

#### 289. 톤 및 스타일 가이드

**설명**: "friendly, natural and educational tone"

---

#### 290. 코드 포맷팅 규칙 명시

**설명**: import문 생략, 일관된 들여쓰기, 의미 있는 변수명

---

#### 291. Artifact 활용 지시

**설명**: `text/markdown` 형식으로 문서 생성

---

#### 292. 시각적 강조 가이드

**설명**: 굵은 글씨와 인용문(> 마크업)을 활용하여 중요 내용을 구조화하도록 명시합니다.

---

#### 293. 실무 적용 내용 강제 포함

**설명**: 체크리스트, 실천적 지침 등 실무에 직접 영향을 주는 내용 누락 금지.

---

#### 294. 점진적 사고 유도 (Cot)

**설명**: "Take a deep breath and let's work this out in a step-by-step way" 문구로 체계적 사고 유도.

---

#### 295. 계층화된 추상화 명시

**설명**: "Step Down Rule"을 구체적으로 설명하여 코드 조직 방식 지시.

---

#### 296. 도메인 주도 설계 통합

**설명**: DDD의 Value Object 개념으로 Primitive Obsession 제거 기준 제시.

---

#### 297. Protocol Driver Layer 분리

**설명**: 테스트 DSL과 SUT 호출을 분리하여 가독성과 유지보수성 향상.

---

#### 298. 부정/긍정 예시 비교

**설명**: Before/After 예시를 나란히 제시하여 변환 방향 명확화.

---

#### 299. Builder 패턴 활용 지시

**설명**: 구체적 클래스명과 구현 제시로 정확한 구현 유도.

---

#### 300. Approval Test 대체 방안

**설명**: DSL이 복잡해지는 경우 ApprovalTest 사용 제안.

---

#### 301. 다이어그램 생성 요청

**설명**: class, sequence, activity, object diagram 포함 요청.

---

#### 302. 대상 독자 정의 (Audience Profiling)

**설명**: 사용자의 배경, 경험, 관심 분야를 구체적으로 명시하여 응답 수준 맞춤.

---

#### 303. 전문 용어 사용 강조

**설명**: 소프트웨어 개발 관점에서 전문적 용어 사용 반복 강조.

---

#### 304. 코드 완성 기능 ("탭/탭/탭") 활용

**설명**: 주석 작성으로 LLM이 다음 단계 코드를 예측하도록 유도.

---

#### 305. 점진적 청크 단위 개발

**설명**: 대규모 사양을 작은 단위로 분할하여 접근.

---

#### 306. Youtube 콘텐츠 경쟁 분석

**설명**: 여러 유튜브 링크로 공통 주제, 훅, 아웃트로 패턴 추출 및 차별화 관점 분석.

---

#### 307. 경쟁사 웹사이트 메시징 분석

**설명**: 경쟁사 URL들로 공통 메시지, 타겟 오디언스, 톤 분석 및 포지셔닝 갭 도출.

---

#### 308. Seo 기반 콘텐츠 주제 추출

**설명**: 검색 결과 페이지의 여러 링크를 수집하여 핵심 주제와 시맨틱 키워드 추출.

---

#### 309. 포드캐스트 스크립트 톤 변환

**설명**: 다중 진행자 대화를 1인칭 관점으로 변환하는 프롬프팅 기법.

---

#### 310. Vault Qa 참조 기반 질의

**설명**: `[[노트명]]` 링크 문법으로 특정 노트 기반 답변 수집.

---

#### 311. 프라이버시-성능 트레이드오프 최적화

**설명**: 로컬(데이터 보호) vs 클라우드(성능) 상황별 선택.

---

#### 312. 임베딩 모델 설정 조정

**설명**: similarity 임계값과 검색 청크 수 조정으로 정확도 균형.

---

#### 313. 비용-기능 균형 분석

**설명**: 클라우드 월 비용 vs 로컬 하드웨어 투자 체계적 비교.

---

#### 314. 검증 가능성과 투명성 원칙

**설명**: AI 작업 요약, 테스트 결과, PR 설명을 함께 제시하여 신뢰와 검토 가능.

---

#### 315. 스타일 기반 코드 최적화

**설명**: 코드 댓글, 코드 스타일을 고려한 모델 최적화.

---

#### 316. Ai + Tdd 패턴

**설명**: AI에게 실패하는 테스트를 먼저 작성하게 한 후, 테스트를 통과시키는 코드 구현 요청.

---

#### 317. 아키텍처 결정은 인간 담당

**설명**: AI는 구현/스캐폴딩/리팩터링만, 설계와 아키텍처는 인간이 담당.

---

#### 318. Ai 페어의 장점 활용

**설명**: 자존심 없음, 무한 인내심, 완벽한 기억력을 전략적으로 활용.

---

#### 319. Ai를 통한 복잡한 코드 이해 및 문서화

**설명**: 복잡한 함수를 AI에게 설명하도록 요청하여 비즈니스 규칙 파악.

---

#### 320. Ai를 활용한 벤치마크 자동 생성

**설명**: 성능 테스트 코드 생성 요청으로 측정 기준선 설정.

---

#### 321. 테스트 데이터 가독성 개선

**설명**: TDD 기반 Builder 패턴으로 테스트 데이터를 읽기 쉬운 형식으로 변환.

---

#### 322. 점진적 이해 구축을 통한 반복적 리팩토링

**설명**: 테스트 케이스를 하나씩 추가하며 AI에게 구현 요청.

---

#### 323. 아이디어 제시 및 Ai 협력 패턴

**설명**: 개발자가 먼저 개선 아이디어 제안 후 AI에게 타당성 검토 및 구현 의뢰.

---

#### 324. 필요시 Ai 생성물 폐기 및 수동 재작성

**설명**: AI가 엣지 케이스에서 실패할 때 개발자가 직접 재작성.

---

#### 325. Ai와의 효과적인 협력의 원칙

**설명**: 도메인 이해와 최종 의사결정은 개발자 책임, 번거로운 작업은 AI에 위임.

---

#### 326. 역할 정의(Role Definition) 프롬프팅

**설명**: "시니어 풀스택 개발자이자 소프트웨어 아키텍트"로 명확히 정의하여 응답 수준 통제.

---

#### 327. 기술 스택 명시를 통한 일관성 보장

**설명**: 프론트엔드부터 배포까지 모든 계층 기술 구체적 정의.

---

#### 328. 아키텍처 우선 개발 패턴

**설명**: 구현 전 다이어그램, API 계약, 스키마 먼저 작성 후 검토.

---

#### 329. Er 및 시퀀스 다이어그램 자동 생성

**설명**: 데이터 계층, 메시지 플로우 시각화 요청.

---

#### 330. 전문 영역 명시 (Domain Expertise Declaration)

**설명**: CSS, JavaScript, React 등 전문 분야를 시작에서 선언.

---

#### 331. 단계적 변경 분해 (Discrete Changes Breakdown)

**설명**: 큰 작업을 작은 단위로 분해, 각 단계마다 테스트.

---

#### 332. 코드 불필요성 우선 (Code Minimization Principle)

**설명**: 코드 없이 답변 가능하면 코드 작성 피하기.

---

#### 333. 변수명/문자열 보존 원칙

**설명**: 코드 재현 시 변수명과 문자열 리터럴 유지.

---

#### 334. 일반성과 유연성 균형

**설명**: 즉각적 문제 해결과 재사용 가능한 일반적 솔루션 사이 균형 유지.

---

#### 335. 명확성 추구와 토론 촉진

**설명**: 불명확한 부분에서 명확화 요청, 트레이드오프 논의 유도.

---

#### 336. 구조화된 요구사항 분석

**설명**: 요구사항 명세서, 용어 사전, 이해관계자 목록 정리로 모호함 제거.

---

#### 337. 유비쿼터스 언어 기반 모델링

**설명**: 도메인 전문가/개발자 공유 언어로 개념적 도메인 모델 구축.

---

#### 338. 이벤트 스토밍 워크샵

**설명**: 핵심 도메인 이벤트 식별, Aggregate/Command/Event 패턴 도출.

---

#### 339. 테스트 시나리오 기반 개발 준비

**설명**: TDD 이전 유스케이스별 테스트 시나리오 리스트 작성.

---

#### 340. 역할 부여(Act As Pattern)

**설명**: AI에 특정 역할(PM, 마케터, 면접관 등) 부여하여 맥락 명확화.

---

#### 341. 인터랙티브 반복 개선

**설명**: 초기 답변 후 "더해줘", "간단하게" 등으로 지속 개선.

---

#### 342. 하이퍼파라미터 튜닝

**설명**: Temperature, Top-P, Max Length 등 조정으로 출력 특성 제어.

---

#### 343. 타겟 채널/대상 명시

**설명**: "블로그용", "페이스북용" 등 최종 사용처 명시.

---

#### 344. 따옴표로 강조

**설명**: 중요한 키워드를 따옴표로 감싸서 강조.

---

#### 345. 코드 리뷰 및 설명 요청

**설명**: "설명해줘", "버그 찾아줘", "리팩토링해줘" 패턴.

---

#### 346. 에러 메시지 활용

**설명**: 에러 메시지 전체 복사하여 정확한 해결책 획득.

---

#### 347. 언어 간 코드 변환

**설명**: Python → JavaScript, SQL → VBA 등 다른 언어로 변환.

---

#### 348. 주제별 문서 수집 활용

**설명**: 특정 주제의 배경, 장단점, 글로벌 사례 다차원 조사.

---

#### 349. 작성 스타일 파라미터

**설명**: Academic, Analytical, Creative, Technical 등 스타일 지정.

---

#### 350. 문서 요약 및 추출

**설명**: URL로 웹 문서 요약, 긴 텍스트에서 핵심 정보 추출.

---

#### 351. 아티팩트를 통한 대화형 개발

**설명**: Artifact 기능으로 코드 작성 실시간 확인 및 미리보기.

---

#### 352. Claude Vs Gpt 선택 기준

**설명**: 장문 작성(3000자)은 Claude가 우수, 용도별 모델 선택 중요.

---

#### 353. 프로젝트 기능을 활용한 맞춤형 봇 개발

**설명**: Claude Pro의 프로젝트 기능으로 특화된 봇 구축.

---

#### 354. 비기술자 친화적 설명 요청

**설명**: "non-technical users" 표현으로 코드 가독성 확보.

---

#### 355. 접근성 및 성능 기준 명시

**설명**: WCAG AA 표준, 색맹 고려, 모바일 반응형 명시.

---

#### 356. 제약 조건 예상 및 명시

**설명**: Artifacts 환경 제약 인식하고 placeholder 제시 유도.

---

#### 357. 직접 답변 우선 전략 (Zero Preamble)

**설명**: 설명/인사 없이 즉시 해결책부터 제시.

---

#### 358. 부동태 모드 진입 기준 정의

**설명**: 매우 엄격한 기준으로 불필요한 비활성 응답 방지.

---

#### 359. 응답 포맷 표준화

**설명**: 헤드라인(≤6단어) + 메인 불릿(1-2개) + 서브 불릿 계층 구조.

---

#### 360. 정의 우선순위(Term Definition)

**설명**: 마지막 10-15 단어의 회사명, 기술 용어 자동 감지 정의.

---

#### 361. 마크다운 포맷 제약 (No Headers)

**설명**: #, ##, ### 없이 굵은 텍스트와 불릿만 사용.

---

#### 362. Latex 수학 렌더링 표준화

**설명**: 모든 수학 표현을 LaTeX 형식으로 통일.

---

#### 363. 역할 명확화 (Speaker Label)

**설명**: me(사용자), them(상대방), assistant(AI) 명확히 구분.

---

#### 364. Role/Label 기반 요소 선택

**설명**: XPath/CSS 대신 `getByRole()`, `getByLabel()` 접근성 기반 선택 우선.

---

#### 365. 문제 인식 및 개선 체크리스트

**설명**: 생성 코드 한계점 명시적 인정, 검토/보완 단계 필수.

---

#### 366. Knowledge 파일 업로드 기법

**설명**: GPT에 참고 문서를 업로드하여 도메인 특화 지식 제공

**적용 조건**: 특정 프로젝트 문서, 기술 스펙 기반 응답이 필요할 때

---

#### 367. Code Interpreter 활성화

**설명**: GPT가 코드를 생성하고 실행하며, 결과 파일을 다운로드 가능하게 하는 기능

**적용 조건**: 웹앱, 스크립트, 데이터 분석 코드를 즉시 생성하고 테스트해야 할 때

---

#### 368. 유튜브 검색 Gpt 생성 패턴

**설명**: SerpAPI를 활용하여 YouTube 검색 기능을 가진 GPT 생성

**적용 조건**: 특정 플랫폼(유튜브, 네이버 등) 검색 자동화 챗봇 구축

---

#### 369. 입출력 예시 기반 생성 (Example-Driven Generation)

**설명**: GraphQL 쿼리와 예상 응답 데이터를 함께 제공하여 AI가 정확한 스키마와 구현을 생성하도록 유도

**적용 조건**: API 스펙이 명확히 정의되어 있을 때, 데이터 구조가 복잡할 때

---

#### 370. 테스트 우선 요구사항 (Test-First Requirement)

**설명**: AI에게 코드와 함께 테스트 코드를 동시에 생성하도록 요청하여 검증 가능한 코드를 얻는 기법

**적용 조건**: TDD/BDD 방법론을 따를 때, 생성된 코드의 즉시 검증이 필요할 때

---

#### 371. 기술 스택 명시 기법 (Tech Stack Specification)

**설명**: 사용할 프레임워크, 라이브러리, 언어 버전, 데이터 타입 등을 구체적으로 명시

**적용 조건**: 멀티 버전 지원이 필요한 기술을 사용할 때, 특정 타입 시스템을 준수해야 할 때

---

#### 372. 최소 출력 제약 (Minimal Output Constraint)

**설명**: "부연 설명 없이 코드만 작성"처럼 AI의 장황한 설명을 제거하고 실행 가능한 코드만 받도록 요청

**적용 조건**: 빠른 프로토타이핑이 필요할 때, 설명보다 구현이 우선일 때

---

#### 373. 어노테이션 화이트리스트 기법 (Annotation Whitelisting)

**설명**: 사용 가능한 어노테이션을 명시적으로 제한하여 불필요한 의존성이나 설정이 추가되는 것을 방지

**적용 조건**: 프레임워크 사용이 제한적일 때, 보일러플레이트 코드를 최소화하고 싶을 때

---

#### 374. 스토리 개발을 위한 단계적 프롬프팅

**설명**: 소설이나 스토리 작성 시 배경 지식을 먼저 제공하고, 단계적으로 세부 사항을 요청하는 방식으로 플롯을 발전

**적용 조건**: 소설, 시나리오, 창작 글쓰기에서 줄거리를 개발할 때

---

#### 375. 다중 제목 생성 및 선택 기법

**설명**: 원본 제목의 의미를 유지하면서 클릭률을 높일 수 있는 여러 대안 제목을 생성

**적용 조건**: 블로그 포스트, 기사, 영상 등의 제목을 최적화할 때

---

#### 376. Local History를 이용한 Ai 변경사항 확인

**설명**: AI가 수정한 코드를 Local History 기능을 활용하여 검토하고 추적

**적용 조건**: AI 코딩 어시스턴트가 코드를 변경했을 때, 변경 내역을 정확히 파악하고 싶은 경우

---

#### 377. 에러 로그 우클릭 설명 기능

**설명**: 에러가 발생했을 때 에러 로그를 선택하고 우클릭하여 "Explain..." 기능을 사용

**적용 조건**: 복잡한 에러 메시지나 스택 트레이스를 빠르게 이해하고 해결책을 찾고 싶을 때

---

#### 378. 브랜치 생성 전제 조건 명시

**설명**: 중요한 작업 전 새 브랜치를 생성하도록 명시적으로 요청

**적용 조건**: 실험적 기능 추가나 대규모 변경 작업 시 안전성 확보

---

#### 379. 기술 선택에 대한 Ai와의 대화

**설명**: 특정 기술 선택(예: UUID vs Long ID)에 대해 AI와 토론하고 의견을 구한 후 결정

**적용 조건**: 아키텍처 결정이나 기술 선택 시 다양한 관점 고려

---

#### 380. Testcontainers 자동 추가 요청

**설명**: 특정 기술 스택(PostgreSQL, Spring Boot)에 대한 테스트 환경을 AI에게 자동으로 설정하도록 요청

**적용 조건**: 통합 테스트 환경 구축 시

---

#### 381. 단순하고 명확하게 지시하기

**설명**: 주관적 표현 대신 구체적이고 측정 가능한 지시 사용

**적용 조건**: 일관된 답변이 필요한 모든 경우

**예시**: "2-3개의 문장을 사용해서 고등학생에게 알려주는 것과 같이 설명해줘"

---

#### 382. 해야 할 것에 집중하기 (부정 지시 회피)

**설명**: "하지 말아야 할 것"보다 "해야 할 것"으로 지시

**적용 조건**: 원하는 행동을 명확히 정의할 때

---

#### 383. 셀프 크리틱(Self-Critique) 요청

**설명**: AI가 자신의 답변을 검토하도록 요청

**적용 조건**: 정확성이 중요한 업무

---

#### 384. 역할 부여(Role Assignment)

**설명**: GPT에게 특정 역할 부여 (비서, 전문가 등)

**적용 조건**: 특정 도메인의 전문성 필요 시

---

#### 385. 조건부 검색 및 필터링

**설명**: 특정 조건(날짜, 위치 등)을 만족하는 정보만 검색

**적용 조건**: 최신 뉴스 검색, 지역 기반 추천

---

#### 386. 최적화 알고리즘 적용

**설명**: 여러 옵션 중 최적의 경로나 선택을 계산

**적용 조건**: 여행 일정, 경로 최적화

---

#### 387. 이력서 기술 분석 및 정렬

**설명**: AI에게 이력서를 분석시켜 원격 근무 역할에 부합하는 핵심 이전 가능 기술, 강점, 경험을 강조

**적용 조건**: 원격 근무 지원 준비, 이력서 최적화 시

---

#### 388. 맞춤형 커리어 패스 제안

**설명**: 자신의 기술, 경험, 관심사를 제공하면 AI가 원격 친화적 커리어 패스와 구체적 역할을 제안

**적용 조건**: 커리어 전환 고려 시, 원격 직무 탐색 시

---

#### 389. 원격 근무 최적화 이력서 작성

**설명**: 특정 역할/산업에 맞춘 전문적인 원격 근무 최적화 이력서 작성

**적용 조건**: 원격 직무 지원 시 이력서 작성

---

#### 390. Linkedin 프로필 최적화

**설명**: 원격 직무 기회를 끌어들이기 위한 LinkedIn 프로필 최적화

**적용 조건**: 원격 직무 탐색 시 LinkedIn 프로필 개선

---

#### 391. 직무 플랫폼 탐색 전략

**설명**: 특정 산업/역할의 원격 직무를 찾을 수 있는 상위 웹사이트 및 플랫폼 목록 제공

**적용 조건**: 원격 직무 검색 시작 시

---

#### 392. 맞춤형 지원서 작성

**설명**: 특정 직무 공고를 분석하여 요구사항에 가장 잘 맞는 이력서 및 커버레터 맞춤화

**적용 조건**: 각 직무 지원 시

---

#### 393. 면접 후 후속 조치

**설명**: 원격 직무 면접 후 전문적인 후속 이메일 작성

**적용 조건**: 면접 후 24-48시간 내

---

#### 394. 급여 및 혜택 협상

**설명**: 원격 직무 제안에 대한 급여 및 혜택 협상을 위한 정중하고 전문적인 협상 이메일 작성

**적용 조건**: 원격 직무 제안 수락 전 협상 시

---

#### 395. 구조화된 규칙 제공 (Structured Rule Definition)

**설명**: AI가 따라야 할 구체적인 규칙들을 계층적으로 명확히 정의

**적용 조건**: 코드 품질 기준을 명확히 하고 일관된 리팩터링 결과를 얻고자 할 때

---

#### 396. Dsl 기반 테스트 작성 프롬프트 (Dsl-Driven Test Design)

**설명**: 테스트 코드를 DSL(Domain Specific Language)과 Protocol Driver Layer로 분리하여 가독성과 유지보수성 향상

**적용 조건**: 테스트 코드의 가독성을 높이고 비즈니스 의도를 명확히 표현하고자 할 때

---

#### 397. 패턴 기반 리팩터링 가이드 (Pattern-Based Refactoring)

**설명**: 구체적인 리팩터링 패턴과 원칙을 명시하여 일관된 코드 개선 유도

**적용 조건**: 코드 품질을 체계적으로 개선하고자 할 때

**예시**: Slide Statements, Split Variable, Extract Value Object, Split by Abstraction Layer

---

#### 398. Soc 기반 설계 원칙 적용 (Separation Of Concerns)

**설명**: 관심사의 분리 원칙을 명시하여 모듈화된 코드 구조 유도

**적용 조건**: 복잡한 시스템의 모듈 분리나 레이어 아키텍처 설계 시

---

#### 399. 문서화 요구사항 명시 (Documentation Requirements)

**설명**: AI에게 다이어그램이나 설명 문서 작성을 요구하여 이해도 향상

**적용 조건**: 복잡한 로직을 시각화하거나 팀원과 공유할 문서가 필요할 때

---

#### 400. Cqs(Command-Query Separation) 원칙 적용

**설명**: Command 메서드와 Query 메서드를 명확히 분리하도록 AI에게 지시

**적용 조건**: 부수 효과를 명확히 하고 코드의 예측 가능성을 높이고자 할 때

---

#### 401. 신중함 및 정확성 강조 기법

**설명**: AI가 서두르지 않고 신중하게 정보를 처리하고 답변하도록 유도

**적용 조건**: 오류가 잦거나 민감한 정보를 다룰 때

---

#### 402. 전문가 관점 및 역할 부여

**설명**: 특정 분야 최고 전문가의 심층적이고 체계적인 사고방식과 지식 체계를 적용하도록 유도

**적용 조건**: 고난이도 전문분야 질문, 특정 역할의 관점에서 문제 해결 필요 시

---

#### 403. 심층 분석 및 다각적 고려

**설명**: 단일 관점에서 벗어나 여러 각도에서 문제를 종합적으로 분석

**적용 조건**: 사회적 이슈 분석, 정책 결정, 복잡한 딜레마 상황

---

#### 404. 자기 비판 및 개선

**설명**: AI가 스스로 생성한 답변을 비판적으로 검토하고 개선

**적용 조건**: 보고서 초안 작성, 주장 개발, 창의적 글쓰기, 코드 생성 후 디버깅

---

#### 405. 문제 분해 및 구조화

**설명**: 큰 문제를 작고 다루기 쉬운 부분으로 나누어 체계적으로 접근

**적용 조건**: 프로젝트 계획, 대규모 시스템 설계, 복잡한 연구 질문 해결

---

#### 406. 손글씨 메모 디지털화

**설명**: GPT-4o의 비전 기능을 활용하여 손으로 쓴 메모를 디지털 텍스트로 변환

**적용 조건**: 회의록, 필기 노트, 아이디어 스케치를 디지털화할 때

---

#### 407. 색상 매칭 컨설팅

**설명**: 이미지 분석을 통한 색상 조합 추천 및 디자인 가이드

**적용 조건**: 의상 코디네이션, 인테리어 디자인, UI/UX 색상 선택

---

#### 408. 복잡한 개념 설명 전문가

**설명**: 어려운 주제를 쉬운 언어로 설명하고 시각적 자료 분석

**적용 조건**: 학습, 연구, 새로운 분야 이해

---

#### 409. 피트니스 코치

**설명**: 운동 자세 분석 및 맞춤형 운동 프로그램 제공

**적용 조건**: 홈 트레이닝, 운동 자세 교정, 운동 계획 수립

---

#### 410. 내비게이션 및 경로 계획 전문가

**설명**: 지도나 경로 이미지 분석 및 최적 경로 제안

**적용 조건**: 여행 계획, 경로 최적화, 장소 탐색

---

#### 411. 스킨케어 및 헤어케어 전문가

**설명**: 피부/모발 상태 분석 및 맞춤형 케어 조언

**적용 조건**: 뷰티 루틴 개선, 제품 선택

---

#### 412. 로컬 Llm을 활용한 무료 Ai 코딩 지원

**설명**: Ollama 플랫폼을 통해 오픈소스 LLM을 로컬에서 실행하여 API 비용 없이 코딩 작업 지원

**적용 조건**: API 비용을 줄이고 싶을 때, 데이터 프라이버시가 중요한 프로젝트

---

#### 413. 하드웨어 리소스 최적화를 위한 모델 양자화(Quantization)

**설명**: 모델 크기를 줄이면서 성능 저하를 최소화하는 양자화 기법 활용

**적용 조건**: 제한된 GPU 메모리 환경, 비용 효율적인 하드웨어 구성 필요

---

#### 414. 로컬 Llm과 상용 모델 성능 비교 방법론

**설명**: 동일한 작업을 여러 모델로 테스트하여 비용 대비 성능 평가

**적용 조건**: 프로젝트에 적합한 LLM 선택 시, 오픈소스와 상용 모델 간 trade-off 분석

---

#### 415. Slow Think 기법

**설명**: CoT 대비 4-10% 정확도 향상

---

#### 416. Gpt Actions

**설명**: Zapier, SerpAPI 등 외부 서비스 연동

---

#### 417. Ollama + Qwen 2.5 Coder

**설명**: API 비용 없는 코딩 지원

---

#### 418. Rag 기반 시스템 설계

**설명**: 벡터 검색, 문서 청킹, 하이브리드 검색, 캐싱 전략

---

#### 419. Xp + Ai 하이브리드

**설명**: Vibe Coding 한계 인식, 피드백 루프 강화, 검증 속도 맞추기

---

#### 420. 하이브리드 검색

**설명**: 벡터 검색(의미 기반)과 키워드 검색(정확한 매칭)을 결합하여 검색 정확도를 높이는 기법

**적용 조건**: RAG 시스템 검색 정확도 향상, 의미적 검색만으로 부족한 경우

---

#### 421. 도메인 특화 지식베이스 구축

**설명**: DDD, TDD 같은 개발 방법론이나 기업 내부 지식을 RAG 시스템에 통합하여 도메인 특화 응답 생성

**적용 조건**: 기업별 내부 지식 기반 AI 시스템, 개발 문서화 자동화

---

#### 422. 벡터 유사성 검색

**설명**: 텍스트를 벡터(임베딩)로 변환하여 저장하고, 쿼리와 유사도가 높은 문서를 검색

**적용 조건**: FAQ 시스템, 문서 검색 시스템, 지식 베이스 구축

---

#### 423. 임베딩 캐싱 및 재사용

**설명**: 한 번 생성된 벡터 스토어를 파일로 저장하고, 애플리케이션 재시작 시 로드하여 재사용

**적용 조건**: 문서가 자주 변경되지 않는 경우, 임베딩 생성 비용 최적화

---

#### 424. Planning-Only Mode (계획 전용 모드)

**설명**: AI가 라이브 코드베이스에 실제 변경을 가하지 않고, 샌드박스 환경에서 계획만 수립하도록 설정. 사용자가 계획을 검토하고 명시적으로 승인한 후에만 실제 변경 적용

**적용 조건**: 프로덕션 환경과 연결된 AI 코딩 도구 사용, 데이터베이스 조작이나 중요 시스템 변경 작업 전

---

#### 425. Ai Action Logging & Monitoring

**설명**: AI가 실행하는 모든 명령을 로깅하고, 이상 행동 패턴을 탐지하는 모니터링 시스템 구축

**적용 조건**: AI 에이전트가 지속적으로 코드 변경을 수행하는 환경, 자동화된 작업 파이프라인

---

#### 426. Pre-Defined Rollback Plan

**설명**: AI 도구 사용 전에 자동 백업 및 복구 시스템을 구축하고, 롤백 절차를 문서화하여 정기적으로 테스트

**적용 조건**: AI 코딩 도구 도입 초기, 데이터베이스나 중요 시스템에 AI가 접근하는 모든 상황

---

#### 427. Symbol-Based Code Navigation

**설명**: `find_symbol`을 사용하여 클래스 전체 구조를 파악하고, `name_path`로 특정 클래스/메서드에 직접 접근. 필요한 심볼만 선택적으로 탐색

**적용 조건**: 대규모 코드베이스에서 특정 클래스나 메서드를 빠르게 찾아야 할 때, 토큰 사용량 최소화

---

#### 428. Hierarchical Symbol Overview

**설명**: `get_symbols_overview`로 파일의 최상위 심볼들(클래스, 메서드, 패키지 등)을 확인. 파일 전체를 읽지 않고도 코드의 구조적 개요 파악

**적용 조건**: 처음 접하는 코드베이스의 구조 이해, 어떤 클래스/메서드가 있는지 먼저 파악하고 싶을 때

---

#### 429. Selective Body Inclusion

**설명**: `include_body=true` 옵션으로 필요한 메서드 본문만 선택적으로 가져옴. 전체 파일을 읽지 않아 토큰 절약

**적용 조건**: 대용량 파일에서 특정 메서드만 분석해야 할 때, AI 토큰 비용 절약

---

#### 430. Ast-Based Relationship Mapping

**설명**: AST 기반으로 코드의 의미론적 구조를 이해하여 클래스 간 연결 관계 파악

**적용 조건**: 복잡한 코드베이스에서 클래스/모듈 간의 의존 관계 파악, 수정의 영향 범위 분석

---

#### 431. 예측 분석 (Predictive Analytics)

**설명**: AI가 버그 리포트와 코드 수정의 과거 데이터를 분석하여 발생할 수 있는 결함을 예측

**적용 조건**: 레거시 코드베이스 분석, 고위험 코드 영역 식별, 릴리스 전 품질 예측

---

#### 432. 테스트 갭 분석 (Test Gap Analysis)

**설명**: AI를 활용하여 테스트 스위트 내에서 보이지 않는 커버리지 구멍 발견

**적용 조건**: 테스트 커버리지 감사, 릴리스 전 품질 점검, 리팩토링 후 테스트 완전성 검증

---

#### 433. 이상 탐지 기반 결함 식별 (Anomaly Detection)

**설명**: 머신러닝 알고리즘이 시스템 기능의 이상 패턴을 탐지하여 숨겨진 결함의 지표로 활용

**적용 조건**: 런타임 버그 탐지, 성능 저하 조기 발견, 복잡한 시스템의 예상치 못한 동작 감지

---

#### 434. Ai 기반 리스크 기반 테스팅 (Risk-Based Testing)

**설명**: AI가 결함이 발생하기 쉽고 가장 큰 영향을 미치는 고우선순위 영역을 식별하여 테스팅 리소스 집중

**적용 조건**: 촉박한 릴리스 일정, 제한된 테스팅 리소스, 핵심 비즈니스 기능 우선순위 결정

---

#### 435. Nlp 기반 요구사항 분석 (Requirements Analysis With Nlp)

**설명**: NLP가 사용자 스토리와 수락 기준을 검토하여 모호성을 식별하고, 초기 단계에서 예비 테스팅 프레임워크 제안

**적용 조건**: 스프린트 플래닝 시 사용자 스토리 검토, 요구사항 명세서 품질 검증, 수락 기준 완전성 확인

---

#### 436. Ci/Cd 파이프라인 Ai 통합 (Ai-Enhanced Ci/Cd)

**설명**: AI가 운영하는 테스트를 CI/CD 파이프라인에 통합하여 코드 제출 후 자동 실행

**적용 조건**: DevOps 환경에서 지속적 통합, 자동화된 코드 리뷰, 배포 전 품질 게이트 구현

---

#### 437. Ai 테스트 우선순위 최적화 (Test Prioritization)

**설명**: AI 테스트 관리 시스템이 리스크 평가에 따라 자동으로 테스트 케이스 우선순위 선택

**적용 조건**: 대규모 테스트 스위트 관리, 회귀 테스트 최적화, 빠른 피드백 사이클

---

#### 438. Ai 기반 코드 분석 (Ai-Powered Code Analysis)

**설명**: 정적 코드 분석 기법을 AI와 결합하여 워크플로우 내에서 직접 코드 테스트

**적용 조건**: 코드 리뷰 자동화, 코딩 표준 준수 검증, 보안 취약점 조기 발견

---

#### 439. Ai 기반 도메인 용어집 자동 생성

**설명**: DDD 전문가 역할을 부여하고 문서 분석을 통해 도메인 특화 용어 100개의 용어집을 CSV 형식으로 생성

**적용 조건**: 새 도메인 온보딩, 팀 간 공통 언어 수립

---

#### 440. 계산 위임 분리 원칙 (Calculation Delegation Principle)

**설명**: 결정론적으로 계산할 수 있는 답변을 LLM에게 직접 계산하도록 요청하지 말고, 계산하는 코드를 생성하도록 요청

**적용 조건**: 수학 계산, 날짜 계산, 통계 분석 등 정확한 계산 필요 시

---

#### 441. Llm 출력 필수 검증 규칙 (Mandatory Output Verification)

**설명**: LLM이 "모든 테스트가 통과했다"고 보고해도 반드시 직접 실행하여 검증

**적용 조건**: 테스트 실행 결과, 코드 동작 확인, 배포 전 검증 등

---

#### 442. 비결정론 허용 오차 설계 (Non-Deterministic Tolerance Design)

**설명**: LLM 기반 시스템에서도 비결정론적 출력에 대한 허용 오차를 설계에 반영. LLM의 출력 변동성을 예상하고 관리하는 메커니즘 구축

**적용 조건**: LLM을 포함한 파이프라인 설계, AI 기반 자동화 워크플로우 구축

---

#### 443. Kent Beck의 Ai 협업 원칙

**설명**: 지니 메타포, 빠른 테스트 피드백, 고수준 비전에 집중

---

#### 444. Tests As Executable Specs

**설명**: TDD에서 테스트가 실행 가능한 사양이라는 개념을 AI 개발에 적용. 테스트를 사양으로 제공하여 검증 가능한 결과물 획득

**적용 조건**: AI에게 코드 생성 요청 시, 먼저 테스트 케이스를 작성하고 이를 사양으로 제공

---

#### 445. Expressive Pattern Specification

**설명**: Commands, Queries, Events 같은 명시적이고 표현력 있는 패턴을 사용하여 시스템의 의도를 코드로 표현

**적용 조건**: AI와 협업하여 아키텍처를 설계할 때, CQRS, DDD 패턴을 활용한 명확한 경계와 네이밍 규칙 정의

---

#### 446. Cynefin-Based Ai Approach

**설명**: 문제의 복잡성 유형에 따라 AI 활용 전략을 달리하는 접근법. 명확한 사양이 가능한 영역과 탐색이 필요한 영역 구분

**적용 조건**: 해당 문제가 complicated인지 complex인지 판단하고 이에 맞는 프롬프팅 전략 선택

---

#### 447. 문서 메타데이터 활용

**설명**: Document 객체에 메타데이터(소스, 날짜, 카테고리 등)를 포함시켜 검색 시 필터링/정렬 가능

**적용 조건**: 특정 기간의 문서만 검색, 특정 출처의 정보만 필터링

---

#### 448. Chat Model과 Embedding Model 분리 선택

**설명**: RAG 구현 시 대화형 Chat Model과 별도로 임베딩 생성을 위한 Embedding Model을 별도 선택

**적용 조건**: RAG 시스템 아키텍처 설계, 로컬 LLM(Ollama) 환경에서 RAG 구현

---

#### 449. Cot(Chain Of Thought) 추론 모듈

**설명**: `dspy.ChainOfThought` 모듈을 사용하여 LLM이 답변 전에 추론 과정을 포함하도록 함

**적용 조건**: 수학 문제, 논리적 추론, 다단계 분석이 필요한 질문 응답

---

#### 450. Bootstrapfinetune 자동 미세조정

**설명**: `dspy.BootstrapFinetune`으로 훈련 데이터셋 자동 구축 및 LLM 가중치 미세조정

**적용 조건**: 특정 도메인 맞춤화 모델 필요 시, 비용 효율적 모델 커스터마이징

---

#### 451. 모듈 조합을 통한 파이프라인 구축

**설명**: Predict, ChainOfThought, ReAct, ProgramOfThought 등 모듈들을 조합하여 복잡한 다단계 AI 파이프라인 구성

**적용 조건**: RAG 시스템, 복합 에이전트, 다단계 추론 시스템 구축

---

#### 452. 타입 힌트 기반 시그니처 정의

**설명**: `"text -> sentiment: Literal['positive', 'negative', 'neutral']"`와 같이 입출력 타입 명시로 LLM 응답 구조 강제

**적용 조건**: 분류 작업, 정보 추출, 구조화된 응답이 필요한 AI 작업

---

#### 453. 구조화 텍스트에서 다이어그램 자동 생성

**설명**: 표준화된 Markdown 헤더를 스캔하여 Mermaid.js 클래스 다이어그램 자동 생성

**적용 조건**: 시스템 아키텍처 시각화, 다이어그램 도구 유지 관리 부담 감소

---

#### 454. Spec-First Development (명세 우선 개발)

**설명**: TDD처럼 구현 전에 Markdown 명세를 먼저 작성. 명세 변경 시 Markdown 업데이트 후 코드 재생성

**적용 조건**: 설계 의도와 구현 코드의 일관성 강제, Code Drift 방지

---

#### 455. Immutable Annotation Testing

**설명**: AI가 코드를 생성할 때 테스트를 "불변의 주석"으로 활용. AI가 테스트를 변경/삭제하려는 시도 차단

**적용 조건**: AI 코딩 도우미가 생성한 코드의 정확성 검증, AI가 기존 기능을 깨뜨리는 것 방지

---

#### 456. Fast Test Suite Monitoring

**설명**: 300밀리초 만에 실행되는 대규모 테스트 스위트를 유지하여 AI가 코드 변경할 때마다 즉각 검증

**적용 조건**: AI와 협업하여 코드 작성할 때, 복잡한 리팩토링이나 대규모 코드 변경 작업

---

#### 457. Language-Agnostic Experimentation

**설명**: 특정 언어에 대한 감정적 애착을 버리고 다양한 언어로 프로젝트 시작. AI가 대부분의 언어를 정확하게 작성 가능

**적용 조건**: 새로운 프로젝트 시작, 익숙하지 않은 언어로 빠른 프로토타입

---

#### 458. Test Deletion Prevention

**설명**: AI가 "이 테스트만 제거하면 모든 게 작동해요"라고 제안할 때 단호히 거절. 테스트 불변성 강제

**적용 조건**: AI가 테스트 실패를 해결하기 위해 테스트 자체를 수정하려 할 때

---

#### 459. Anti-Vibe Coding Discipline

**설명**: AI 도구 사용 시 "vibe coding"(코드 품질을 신경 쓰지 않는 작업) 경계. 진지한 작업 태도 유지

**적용 조건**: AI와 장시간 코딩 세션, AI가 생성한 코드를 무비판적으로 수용하려는 유혹이 있을 때

---

#### 460. Human Design Oversight

**설명**: AI는 결합도 감소와 응집도 증가에 능숙하지 않음. 인간이 설계 결정을 주도하고, AI는 구현 세부사항 담당

**적용 조건**: 아키텍처 결정이나 코드 구조 설계, AI가 생성한 코드 리팩토링

---

#### 461. Dual-Purpose Testing

**설명**: 테스트 코드를 AI 입력(프롬프트)으로 사용하면서 동시에 AI 생성 구현의 정확성 검증 도구로 활용

**적용 조건**: AI 생성 코드의 신뢰성 검증 필요 시, AI 출력물에 대한 검증 체계 필요

---

#### 462. Model Escalation Strategy

**설명**: 로컬/저성능 모델로 시작하여 실패할 경우 점진적으로 상위 모델로 전환. 비용 효율성과 성능 균형

**적용 조건**: 비용 절감하면서 다양한 복잡도의 코드 생성. 간단한 POJO는 로컬 모델, 복잡한 코드는 상위 모델

---

#### 463. 태스크 파일 기반 작업 관리

**설명**: tasks/todo.md에 체크박스 형태의 할 일 목록을 작성하고, AI가 완료할 때마다 체크 표시하도록 하여 진행 상황을 투명하게 추적

---

#### 464. Ui 스크린샷 활용

**설명**: 원하는 UI 디자인의 스크린샷을 Claude에 전송하여 해당 UI를 구현하도록 요청하는 방식으로 비주얼 레퍼런스 활용

---

#### 465. 버그 수정을 위한 이미지 활용

**설명**: 에러 화면이나 버그 상황을 스크린샷으로 캡처하여 AI에게 전달, 시각적 맥락과 함께 문제 해결

---

#### 466. /Clear 명령어 활용

**설명**: 하나의 세션을 몇 시간씩 지속하지 않고, 적당한 크기의 작업(태스크 파일 하나)을 완료할 때마다 /clear로 세션을 초기화하여 할루시네이션 감소 및 비용 절약

---

#### 467. Ai 대기 시간 활용법 (둠스크롤 해킹)

**설명**: Claude가 코드를 생성하는 동안 소셜 미디어를 보는 대신, 별도의 AI 챗에서 아이디어 브레인스토밍, 프로젝트 성찰, 다음 단계 계획을 수행

---

#### 468. 파일럿-승객 마인드셋

**설명**: AI 코딩 도구 사용 시 개발자는 '승객'이 아닌 '파일럿'이어야 함. AI가 생성한 코드는 시작점으로 삼고, 검토/수정/테스트 책임은 개발자에게 있음

---

#### 469. Ai 에이전트의 자율적 계획 수립 활용

**설명**: 복잡한 작업 요청 시 AI가 자율적으로 계획(프로젝트 탐색 → 모델 생성 → 서비스 생성 → 컨트롤러 생성 → 설정 → 테스트)을 수립하도록 하고, 개발자가 단계별로 승인/거부 결정

---

#### 470. 스택 트레이스 모드 조절

**설명**: `stackMode: 'condensed'` 옵션으로 AI에게 제공할 디버깅 정보의 상세도를 조절. AI가 노이즈 없이 핵심 정보에 집중할 수 있도록 지원

---

#### 471. 소스 위치 힌트 제공

**설명**: 로그에 `file:line:col` 정보를 포함시켜 AI가 문제 발생 위치를 정확히 파악하고 관련 코드를 찾아갈 수 있게 함

---

#### 472. 파일 로깅을 통한 Ai 분석 지원

**설명**: 로그를 파일로 저장하여 나중에 AI가 세션 전체를 분석할 수 있게 함. 실시간 디버깅뿐 아니라 사후 분석도 가능

---

#### 473. 확장된 사고 유도 (Extended Thinking)

**설명**: 복잡한 문제에서 "think", "think harder", "think deeply" 등의 강화 구문을 사용하여 Claude의 추론 깊이를 조절할 수 있음

---

#### 474. 실행 흐름 추적 (Trace)

**설명**: "trace the login process from front-end to database"처럼 실행 흐름을 추적하여 시스템 이해

---

#### 475. # 단축키로 빠른 메모리 추가

**설명**: 입력을 `#`로 시작하면 메모리에 빠르게 규칙/정보 추가 가능

---

#### 476. 테스트 주도 버그 수정

**설명**: 오류 재현 명령어, 스택 트레이스, 재현 단계를 Claude에게 제공하여 효율적 디버깅

---

#### 477. 리팩토링 검증

**설명**: 리팩토링 후 테스트 실행을 함께 요청하여 동작 유지 검증

---

#### 478. Test-Aware Refactoring

**설명**: TDD 러너 모드와 통합하여 코드 변경 시 실시간으로 테스트를 실행하여 변경사항을 즉각 검증하는 방식

---

#### 479. 17가지 전문 모드 활용

**설명**: 개발 시나리오에 맞는 전문화된 모드 선택 - Architect(아키텍처 설계), Coder(구현), TDD(테스트 주도), Security(보안), DevOps(배포) 등으로 역할에 맞는 AI 행동 유도

---

#### 480. 개발자 주도 페어 프로그래밍

**설명**: 어려운 작업에서는 개발자가 운전대를 잡고, Claude는 코드 기반 연구, 프로토타입 작성, 아이디어 검토, 단위 테스트 작성 용도로 활용

---

#### 481. "바이브 코딩" 방식

**설명**: 시스템의 경계와 잘 작동하는 것을 이해하기 위해 Claude를 활용한 탐색적 프로토타이핑 진행

---

#### 482. 코드보다 아이디어 중심 사고

**설명**: 코드 자체는 더 이상 "소중한" 자산이 아니며, 아이디어와 최종 결과물에 집중. 코드는 언제든 다시 작성 가능한 것으로 인식

---

#### 483. 빠른 피드백 사이클 구축

**설명**: 단일 피드백 채널을 만들고, 피드백을 받으면 가능한 한 빨리 문제를 해결한 후 즉시 알려주는 루프 형성으로 지속적 피드백 유도

---

#### 484. 실제 사용 기반 평가("바이브" 테스트)

**설명**: 공식 벤치마크보다는 실제 업무에서 하루 종일 사용해보는 "바이브" 검사가 가장 중요한 모델/기능 평가 지표

---

#### 485. 테스트 작성 위임

**설명**: 어려운 작업에서 핵심 구현은 직접 하되, 단위 테스트는 Claude에게 작성하게 하여 시간 절약

---

#### 486. 마이크로서비스 패턴의 Ai 적용

**설명**: 단일 모놀리식 에이전트 대신 각 에이전트가 특정 책임을 가진 서비스처럼 작동. MSA(Microservice Architecture)의 AI 버전으로 DDD 원칙 적용 가능

---

#### 487. 역할 기반 에이전트 분리

**설명**: 전용 플래너(planner), 테스터(tester), 옵티마이저(optimizer) 등 역할에 따른 에이전트 분리로 단일 책임 원칙(SRP) 구현

---

#### 488. 시크릿 모드 활용 (Incognito Mode For Sensitive Work)

**설명**: 메모리에 지속되지 않는 임시 대화 세션을 사용하여 실험적 쿼리, 기밀 브레인스토밍, 민감한 정보 처리.

**적용 조건**: 경쟁 분석, 실험적 아키텍처 탐색, 보안 취약점 테스트

---

#### 489. 인라인 메모리 편집 (Inline Memory Editing)

**설명**: 대화 중에 메모리를 직접 추가/업데이트/삭제. "TypeScript를 선호한다는 것을 기억해줘"

**적용 조건**: 실시간 선호도 업데이트, 프로젝트 요구사항 변경 즉시 반영

---

#### 490. 메모리 내보내기/백업 (Memory Export/Backup)

**설명**: 주기적으로 AI 메모리를 내보내어 백업하고 감사. 월별 내보내기, 분기별 백업 권장.

**적용 조건**: 지식 손실 방지, 프로젝트 인수인계, AI 도구 전환

---

#### 491. 하이브리드 메모리 관리 (Hybrid Memory Management)

**설명**: 24시간 자동 합성과 즉시 수동 업데이트를 결합. 중요한 기술 결정은 즉시 메모리에 추가.

**적용 조건**: 긴급 프로젝트, 빠르게 진화하는 요구사항

---

#### 492. Tdd 페어 프로그래밍 메모리 (Tdd Pair Programming Memory)

**설명**: 테스트 패턴, 코딩 표준, 아키텍처 결정을 세션 간에 지속시켜 AI 페어 프로그래밍을 지속적인 멘토십으로 전환.

**적용 조건**: TDD 실천, 페어 프로그래밍, 아키텍처 결정 기록(ADR) 관리

---

#### 493. 계층적 콘텐츠 분류 시스템

**설명**: CSV 기반으로 콘텐츠를 Kind/SubKind로 이중 분류하고 메타데이터를 체계화.

**적용 조건**: 개인 포트폴리오 관리, 학습 자료 관리

---

#### 494. 자동 콘텐츠 발견 및 인덱싱

**설명**: YouTube 플레이리스트, 블로그 RSS 등에서 콘텐츠를 자동으로 발견하고 인덱싱.

**적용 조건**: 정기적 콘텐츠 업데이트, 대량 마이그레이션

---

#### 495. Todo 리스트 기반 태스크 실행 및 추적

**설명**: AI가 복잡한 작업을 여러 단계로 분해하여 Todo 리스트로 관리하고 실시간 상태 업데이트.

**적용 조건**: 복잡한 프로젝트 설정, 마이그레이션 작업

---

#### 496. 배치 콘텐츠 요약 파이프라인

**설명**: 대량의 콘텐츠를 자동으로 처리하고 요약하여 구조화된 형태로 저장.

**적용 조건**: 강의 자료 정리, 논문/기술 문서 리뷰

---

#### 497. 모듈형 프로세서 아키텍처

**설명**: 콘텐츠 타입별로 전용 프로세서를 개발하고, 메인 빌드 스크립트가 적절한 프로세서를 자동 선택.

**적용 조건**: 확장 가능한 시스템 설계, 멀티 포맷 지원

---

#### 498. 문서 내용 분석 기반 Hierarchical Tagging

**설명**: AI가 문서의 내용을 분석하여 계층적 구조의 태그를 자동으로 설계하고 적용.

**적용 조건**: 문서의 주제가 다층적일 때, 체계적인 지식 분류

---

#### 499. Ai 기반 디렉토리 구조 분석 및 최적 배치

**설명**: AI가 전체 vault의 디렉토리 구조를 분석하고 문서의 내용에 따라 가장 적절한 디렉토리를 자동 선택.

**적용 조건**: 새로운 문서를 어느 폴더에 넣어야 할지 고민될 때

---

#### 500. `/Undo`, `/Redo`를 활용한 Ai 출력 반복 개선

**설명**: AI가 수행한 변경사항을 `/undo` (Ctrl+X+U)로 즉시 되돌리고 `/redo` (Ctrl+X+R)로 다시 실행.

**적용 조건**: AI가 생성한 코드의 품질을 검증하면서 작업

---

#### 501. 다중 Ai 모델 선택 및 전환

**설명**: Claude, OpenAI 등 다양한 AI 모델을 자유롭게 선택하고 전환. `opencode.json`에서 설정.

**적용 조건**: 특정 AI 모델에 종속되지 않고 최적의 모델 선택

---

#### 502. `:Bufdo E!`를 통한 Ai 변경사항 즉시 반영

**설명**: AI가 파일을 수정한 경우 Neovim에서 모든 열린 버퍼를 새로고침하여 변경사항 확인.

**적용 조건**: AI가 다수의 파일을 수정했을 때

---

#### 503. Specification-Based Task Decomposition

**설명**: AI가 명세와 계획을 받아 작은, 검토 가능한 덩어리로 분해. 각 작업은 독립적으로 구현/테스트 가능.

**적용 조건**: 복잡한 기능을 AI와 함께 구현할 때

---

#### 504. Living Specification Document

**설명**: 명세서를 프로젝트와 함께 진화하는 실행 가능한 아티팩트로 재정의. 진실의 원천(Source of Truth) 역할.

**적용 조건**: 장기적 유지보수성이 중요한 프로젝트

---

#### 505. Iterative Specification Update

**설명**: 명세 업데이트만으로 계획 재생성과 구현이 가능하여 요구사항 변경에 유연하게 대응.

**적용 조건**: 요구사항이 자주 변경되는 애자일 환경

---

#### 506. Legacy System Intent Restoration

**설명**: 레거시 시스템을 재구축할 때 "왜 이렇게 만들어졌는지"를 명세서로 복원.

**적용 조건**: 레거시 시스템 현대화, 마이그레이션

---

#### 507. Paradigm Shift - From Code To Intent As Source Of Truth

**설명**: "코드가 진실의 원천"에서 "의도가 진실의 원천"으로의 패러다임 전환.

**적용 조건**: AI 기반 개발 환경으로 전환하는 조직

---

#### 508. Spec-Kit 3단계 명령어 체계

**설명**: `/specify`로 아이디어를 구조화된 명세로, `/plan`으로 기술 구현 계획, `/tasks`로 실행 가능한 작업 목록 생성.

**적용 조건**: 아이디어를 빠르게 구조화된 프로젝트로 전환

---

#### 509. Constitution.Md를 통한 불변 원칙 강제

**설명**: 헌법(constitution.md) 파일에 9개 조항의 개발 원칙 정의. 라이브러리 우선, CLI 인터페이스 의무, 테스트 우선 등 강제.

**적용 조건**: 팀 전체의 코드 품질 기준 통일, AI 생성 코드의 아키텍처 일관성

---

#### 510. Ops-To-Spec 양방향 피드백

**설명**: 운영 메트릭, 인시던트, 성능 데이터가 명세 업데이트에 반영되는 양방향 피드백 체계.

**적용 조건**: 운영 중 발견된 문제 체계적 해결, 지속적 개선

---

#### 511. Ai 기반 독립 작업 분석 및 `[P]` 마커

**설명**: `/tasks` 명령어가 생성한 작업 목록에서 독립적 작업을 자동 식별하고 `[P]` 마커로 표시.

**적용 조건**: 대규모 기능 개발 시 작업 분배

---

#### 512. 구현 전 테스트 시나리오 및 계약 정의

**설명**: 명세 단계에서 API 계약, 데이터 모델, 테스트 시나리오를 먼저 정의. "테스트 없이는 코드 없음" 원칙.

**적용 조건**: TDD 실천, API 설계 초기 단계

---

#### 513. 레거시 코드베이스의 명세 추출

**설명**: 기존 레거시 시스템의 동작을 분석하여 명세로 역공학한 후 현대적인 코드를 재생성.

**적용 조건**: 레거시 시스템 리팩토링, 기술 스택 마이그레이션

---

#### 514. Article I - 모든 기능을 독립형 라이브러리로 시작

**설명**: 모든 기능을 처음부터 독립형 라이브러리로 설계하여 재사용성과 테스트 용이성 확보.

**적용 조건**: 재사용 가능한 컴포넌트 개발, 마이크로서비스

---

#### 515. 심각도 기반 Ai 행동 제어

**설명**: 1-10 척도의 심각도 등급으로 AI 행동을 계층적으로 구조화. CRITICAL[10] 등급은 절대 차단.

**적용 조건**: 보안, 코드 품질, 운영 안전성이 중요한 환경

---

#### 516. 18가지 명령어 시스템

**설명**: /user:build, /user:design, /user:analyze 등 18가지 전문 명령어. --tdd, --ddd 플래그로 방법론 지정.

**적용 조건**: 표준화된 개발 워크플로우, TDD/DDD 적용

---

#### 517. 작업별 최적 Ai 모델 선택

**설명**: 간단한 작업에는 Sonnet, 중요한 재설계에는 Opus 사용. 작업 복잡도에 따라 자동 선택.

**적용 조건**: AI 비용 최적화

---

#### 518. 상용구 없는 간결한 코드 생성

**설명**: AI가 기본적으로 간결하고 상용구 없는, 주석 없는 코드를 생성.

**적용 조건**: 불필요한 코드를 최소화

---

#### 519. Graduated Thinking Depth Flags

**설명**: `--think` (~4K), `--think-hard` (~10K), `--ultrathink` (~32K) 3단계 사고 깊이 제어.

**적용 조건**: 토큰 사용량 최적화, 복잡한 문제에 충분한 사고 공간

---

#### 520. Ultra-Compressed Output Mode

**설명**: `--uc` 플래그로 출력을 60-80% 압축. 핵심 정보 유지, 장황함 제거.

**적용 조건**: API 비용 절감, 빠른 응답 필요 시

---

#### 521. Build System Auto-Detection

**설명**: `/build` 명령이 프로젝트의 빌드 시스템(npm, gradle 등)을 자동 감지하고 최적 전략 적용.

**적용 조건**: 다양한 기술 스택의 프로젝트에서 빌드 자동화

---

#### 522. Safe Mode Execution

**설명**: `--safe-mode` 플래그로 프로덕션 환경에서 안전한 실행 보장. 파괴적 변경 방지.

**적용 조건**: 프로덕션 코드, 위험도 높은 리팩토링

---

#### 523. Automated Technical Debt Cleanup

**설명**: `/cleanup --safe` 명령이 기술 부채를 안전하게 식별하고 정리. 사용하지 않는 코드, 중복 제거.

**적용 조건**: 레거시 코드베이스의 점진적 개선

---

#### 524. Cognitive Personas For Domain-Specific Ai Assistance

**설명**: 9가지 전문가 페르소나(Architect, Frontend, Backend, Security 등)를 부여하여 도메인별 전문성 활용. 플래그 시스템으로 일관되게 사용.

**적용 조건**: 복잡한 시스템 설계, 보안 분석, 성능 최적화, 코드 리뷰

---

#### 525. Specialized Command Framework For Development Lifecycle

**설명**: 개발 생명주기를 19개 전문 명령어로 구조화. 일관된 AI 협업 패턴 제공.

**적용 조건**: 팀 내 AI 활용 방식 표준화

---

#### 526. Introspection Mode For Framework Improvement

**설명**: `--introspect` 플래그로 AI가 자신의 동작을 분석하고 개선점 찾기.

**적용 조건**: AI 프롬프트/설정 디버깅, AI 협업 워크플로우 개선

---

#### 527. Multi-Stage Architecture Flow With Specialized Commands

**설명**: DDD 설계 → 리소스 추정 → 보안 검토 → TDD 구현을 순차적으로 실행하는 체계적인 워크플로우.

**적용 조건**: 대규모 기업 프로젝트의 설계부터 구현까지

---

#### 528. 역할 기반 모델 할당 (Role-Based Model Assignment)

**설명**: AI 모델을 역할별로 분리 배치하는 전략입니다. 메인 모델(주요 작업), 리서치 모델(정보 수집), 백업 모델(대체용)로 구분하여 각 모델의 강점을 최적화하고 비용을 효율화합니다.

---

#### 529. 모델 믹스 전략 (Model Mix Strategy)

**설명**: YAML 설정을 통해 상황별로 다른 AI 모델 조합 전략을 정의하고 전환하는 기법입니다. 기본(default), 성능(performance) 등 다양한 전략을 사전 정의하여 필요에 따라 적용합니다.

---

#### 530. Ai 작업 종속성 시각화 및 분석

**설명**: 작업 간 종속성을 자동으로 분석하고 시각화하여 순환 종속성 감지, 작업 우선순위 결정을 지원하는 기법입니다. `--depth` 매개변수로 하위 작업 생성 깊이를 제어할 수 있습니다.

---

#### 531. 4계층 문서화 시스템 (4-Layer Documentation System)

**설명**: AI와 협업하기 위한 계층적 문서 구조로, 헌법(Constitution: 불변 규칙), 명세서(Specification: 무엇을 왜), 계획(Plan: 기술적 제약), 작업(Tasks: 구체적 실행 항목)의 4단계로 구성됩니다.

---

#### 532. Ai를 위한 헌법(Constitution) 문서 작성

**설명**: 프로젝트 전체에서 AI가 반드시 따라야 할 불변의 규칙들을 문서화하는 기법입니다. 예: "모든 API 응답에는 에러 코드 포함", "함수는 50줄 초과 불가".

---

#### 533. Github Spec Kit을 활용한 자동 작업 생성

**설명**: `spec-kit plan` 명령을 실행하면 AI가 헌법, 명세서, 계획을 읽고 완벽한 순서로 작업 목록을 자동 생성합니다. 각 작업은 작고, 테스트 가능하며, 명확한 성공 기준을 가집니다.

---

#### 534. 재개 가능한 진행 (Resumable Progress)

**설명**: 모든 결정을 마크다운 파일에 문서화하여 세션 종료 후에도 AI가 정확히 중단된 지점에서 재개할 수 있게 하는 기법입니다.

---

#### 535. 작업별 커밋 전략 (Task-Based Commit Strategy)

**설명**: AI가 생성한 각 작업(15-30분 단위) 완료 후 즉시 커밋하는 전략입니다. 무언가 잘못되었을 때 롤백이 간단해집니다.

---

#### 536. 추측 제거 원칙 (Elimination Of Guesswork Principle)

**설명**: AI는 코드를 작성함으로써 속도를 높이는 것이 아니라 추측을 제거함으로써 속도를 높입니다. 명세서는 항상 올바른 문제를 해결하고 있음을 보장합니다.

---

#### 537. V0 기반 Ui 시작점 생성

**설명**: Vercel의 v0를 사용하여 UI 개발의 시작점을 빠르게 생성하는 기법. 대화형 채팅 인터페이스를 통해 초기 UI 프로토타이핑 시간을 크게 단축할 수 있습니다.

---

#### 538. 살아있는 문서(Living Document) 유지 기법

**설명**: 계획 문서를 정적인 사양서가 아닌 구현 과정 전반에 걸쳐 지속적으로 업데이트되는 살아있는 문서로 관리합니다.

---

#### 539. Brain Dump 분석 및 마인드맵 생성

**설명**: brain dump 파일들을 분석하여 철학, 정체성, 전략 등으로 매핑된 마인드맵 시각화를 생성합니다.

---

#### 540. 사용자 데이터 기반 개인화 프로파일링

**설명**: 공개된 데이터를 수집하여 10분 만에 사용자 프로파일을 완성하는 기법입니다.

---

#### 541. Ai 기반 성과 측정 객관화

**설명**: AI를 활용하여 조직원의 성과를 객관적으로 측정하고 분석하는 방식.

---

#### 542. 도메인 특화 Ai 시스템 개발

**설명**: 물류 센터라는 특정 영역에 특화된 AI 시스템 개발 전략.

---

#### 543. 데이터베이스 스키마를 Single Source Of Truth로 활용

**설명**: AI 기반 개발에서 데이터베이스 스키마를 명확하게 정의하여 프론트엔드와 백엔드 간의 일관성을 보장하는 기법입니다.

---

#### 544. Custom Commands 정의

**설명**: .claude/commands/ 디렉토리에 마크다운 파일로 사용자 정의 슬래시 명령어를 정의합니다.

---

#### 545. Superclaude 패키지 활용

**설명**: 고급 명령어 모음을 제공하는 오픈소스 패키지입니다.

---

#### 546. Bash Mode 활용

**설명**: 느낌표(!)로 시작하여 Bash 명령어를 직접 실행하는 모드.

---

#### 547. Ai 기반 엣지 케이스 테스트 제안

**설명**: GenAI가 애플리케이션의 동작을 분석하여 엣지 케이스나 실패 가능성이 높은 영역에 대한 테스트 케이스를 자동으로 제안합니다.

---

#### 548. 인지 부하 전환 (Cognitive Load Shifting)

**설명**: 개발자의 인지 부하를 구문 수준에서 시스템 사고 수준으로 전환하는 접근법.

---

#### 549. 자율적 개발 루프 (Autonomous Development Loop)

**설명**: AI 에이전트가 코드 작성 → 테스트 → 반복의 루프를 자율적으로 실행합니다.

---

#### 550. Ai 페르소나를 통한 콘텐츠 생성

**설명**: "virtual adrianco"라는 작가 페르소나를 만들어 특정 주제에 관한 콘텐츠를 자동으로 생성합니다.

---

#### 551. 대화형 장치 검색 시스템

**설명**: 자연어를 통해 IoT 장치를 검색하고 구성하는 시스템입니다.

---

#### 552. Ai 코드 생성의 레거시 코드 인식

**설명**: Vibe coding으로 생성된 코드는 본질적으로 레거시 코드가 된다는 인식이 필요합니다.

---

#### 553. 프로토타입/일회성 프로젝트에 Vibe Coding 집중

**설명**: Vibe coding은 프로토타입이나 일회성 프로젝트에 완벽하게 적합합니다.

---

#### 554. Ai를 "짧은 목줄"로 통제하기

**설명**: AI를 "과도하게 열정적인 주니어 인턴 천재"로 대하고 매우 짧은 목줄을 유지해야 합니다.

---

#### 555. 이론 구축(Theory Building) 중심 접근

**설명**: 프로그래밍의 본질은 코드 라인을 생산하는 것이 아니라 이론 구축입니다.

---

#### 556. 실행 가능한 명세(Executable Specification) 기반 Ai 프롬프팅

**설명**: AI를 프롬프팅할 때 자연어 대신 "실행 가능한 명세"를 사용합니다.

---

#### 557. Ai 프로그래밍의 세 가지 핵심 문제 프레임워크

**설명**: 원하는 것을 정확히 명시하는 방법, 원하는 결과를 얻었는지 확인하는 방법, 점진적 개선을 유지하는 방법.

---

#### 558. 점진적 개선(Incremental Development) 유지 전략

**설명**: AI가 코드를 처음부터 다시 생성하는 경향을 경계하고, 문제를 구획화합니다.

---

#### 559. 의도 명세 중심의 Ai 활용

**설명**: 구현 세부사항을 명시하는 것에서 의도를 더 명확하게 명시하는 방향으로 전환합니다.

---

#### 560. 작업 분할 및 체크리스트 생성

**설명**: AI에게 작업을 체크리스트로 분할하고 커밋 지점을 명시하도록 요청하여 롤백 가능한 단위로 작업을 관리.

---

#### 561. Svg 와이어프레임 생성

**설명**: 설계 문서의 UI 디자인을 SVG를 사용한 와이어프레임으로 변환 요청.

---

#### 562. Ai Tdd 강제 적용

**설명**: "비즈니스 로직 구현 작업은 반드시 테스트를 먼저 작성하고 구현하세요"라는 지침을 AI에게 제공.

---

#### 563. 리팩토링 허락 프로세스

**설명**: AI가 리팩토링이 필요할 때 계획을 설명하고 사용자의 허락을 받은 후 진행하도록 지시.

---

#### 564. 디버깅 설명 및 승인 프로세스

**설명**: 디버깅 시 AI가 원인과 해결책을 설명하고 허락을 받은 후 진행하도록 지시.

---

#### 565. 최신 기술 문서 제공 기법

**설명**: AI가 1-2년 전의 라이브러리나 기술을 사용하는 경향이 있으므로, 최신 기술 문서를 직접 제공.

---

#### 566. 마이크로서비스 기반 바이브 코딩

**설명**: 마이크로서비스 아키텍처가 바이브 코딩과 잘 맞는 이유는 작은 단위로 분할하여 개발할 수 있기 때문.

---

#### 567. 시니어-Ai 시너지 활용

**설명**: 시니어 개발자들이 축적한 경험과 패턴 인식 능력을 AI와 결합하여 더 높은 생산성을 발휘.

---

#### 568. Tdd-Guard

**설명**: TDD 프로세스에 가드레일을 사용한 에이전틱 코딩 접근법.

---

#### 569. Ai 위임을 통한 개발 속도 향상 (Fast)

**설명**: 시간이 많이 걸리는 작업을 AI에 위임하여 개발 속도를 극적으로 향상.

---

#### 570. Ai 기반 범위 확장 전략 (Ambitious)

**설명**: AI의 생산성 향상을 활용하여 원래 요청된 범위보다 더 넓은 기능을 구현.

---

#### 571. Ai 코딩 지원의 현실적 효과 평가

**설명**: AI 코딩 어시스턴트가 주니어와 시니어 개발자에게 미치는 영향이 다를 수 있다는 점을 인지.

---

#### 572. 키보드 입력이 병목이 아님

**설명**: 실제 개발의 병목은 키보드 입력이 아니라 문제 이해와 설계에 있음.

---

#### 573. Llm 기반 문헌 요약

**설명**: 복합적인 연구 영역에서 다양한 과학 문헌을 LLM을 활용하여 요약.

---

#### 574. 아이디어 브레인스토밍 및 작가의 블록 극복

**설명**: LLM을 초기 아이디어 발전 단계에서 브레인스토밍 파트너로 활용.

---

### Prompt Engineering (272개)

#### 1. Mcp 생태계 확장

**설명**: Context7, Taskmaster, Knowledge Graph, Code Context, Spring AI MCP 등 다양한 MCP 서버 활용

**관련 도구**: Supabase, Context7, ShadCN, Playwright

**적용 조건**: AI 워크플로우에 GitHub, Notion, Obsidian, DB 등 외부 도구 연동 필요 시

**예시**: `claude mcp add-from-claude-desktop`

*출처: 10개 문서*

---

#### 2. Rag 패턴

**설명**: 사용자 질문과 관련된 정보를 지식 데이터베이스에서 검색하여 프롬프트에 추가함으로써 생성형 AI의 환각 현상, 최신 정보 부재, 도메인 지식 부족 문제를 해결하는 기법

**적용 조건**: 기업 내부 문서 기반 Q&A 시스템, 최신 정보가 필요한 AI 응답, 도메인 지식이 필요한 경우

*출처: 6개 문서*

---

#### 3. Ddd + Ai 통합

**설명**: 용어집 자동 생성, 도메인 분해, Bounded Context 설계, Event Storming

*출처: 6개 문서*

---

#### 4. 프롬프트 체이닝

**설명**: `echo "input" | fabric -p pattern1 | fabric -p pattern2`

*출처: 5개 문서*

---

#### 5. Claude.Md 파일로 컨텍스트 제공

**설명**: 루트 디렉토리나 하위 디렉토리에 CLAUDE.md 파일을 배치하여 프로젝트별 설정, 코딩 컨벤션, 기술 스택 정보 등을 Claude Code에 전달

*출처: 4개 문서*

---

#### 6. Vibe Coding 리스크 관리

**설명**: LLM의 컨텍스트 윈도우가 길어질수록 정확도가 떨어진다는 한계 인식. LLM은 컨텍스트 윈도우의 시작과 끝에서 가장 잘 수행되며, 중간 부분은 오류 발생 가능

**적용 조건**: AI 코드 생성 도구를 장기간 사용하거나 큰 컨텍스트로 작업할 때

*출처: 4개 문서*

---

#### 7. 컨텍스트 체이닝 (Context Chaining)

**설명**: 특정 과거 대화를 명시적으로 참조하여 이전 작업을 기반으로 구축. "지난 화요일 데이터베이스 스키마 논의를 기반으로..."

**관련 도구**: Claude, ChatGPT, Cursor

**적용 조건**: 멀티데이 프로젝트에서 연속성 유지, TDD 사이클에서 이전 테스트 기반으로 확장

**예시**: 100턴 웹 검색 시나리오에서 토큰 소비 84% 감소 달성

*출처: 3개 문서*

---

#### 8. 동적 테스트 적응

**설명**: MCP를 통해 GenAI가 사용자 컨텍스트에 따른 애플리케이션의 동적 동작 변화를 이해하고 테스트 플로우를 자동으로 조정합니다.

**관련 도구**: Obsidian, Smart Composer

**예시**: 코드 블록 드래그 선택 → Cmd+K로 개선 요청 → 원하는 변경사항만 Accept

*출처: 3개 문서*

---

#### 9. 롱 컨텍스트 채팅

**설명**: Cursor 설정 > 베타 > 롱 컨텍스트 채팅 활성화, Ctrl/⌘ + .로 모드 전환

**관련 도구**: Cursor AI

*출처: 3개 문서*

---

#### 10. 역할 기반 프롬프트 설정

**설명**: "You are an expert technical writer specializing in writing documentation for software projects."

*출처: 3개 문서*

---

#### 11. 대화 지속 기법

**설명**: `claude -c` - 이전 컨텍스트 유지하며 연속 작업

**적용 조건**: 해외 여행, 다문화 커뮤니케이션, 문화 이해

*출처: 3개 문서*

---

#### 12. 프롬프트 우선 개발 방식

**설명**: GPT 생성 시 Instructions를 직접 작성하지 않고, Create 탭에서 대화형으로 GPT에게 프롬프트를 생성하도록 요청

**적용 조건**: 프롬프트 작성 경험이 부족하거나 빠른 반복 개발이 필요할 때

*출처: 3개 문서*

---

#### 13. 컨텍스트 엔지니어링의 중요성

**설명**: 3층 컨텍스트 아키텍처, Memory Bank, Context Pipeline 등으로 AI 효과 극대화

*출처: 3개 문서*

---

#### 14. 컨텍스트 청크 분할

**설명**: 128k 컨텍스트 윈도우라도 주의력(attention) 문제로 청크로 나누어 제공.

**적용 조건**: 문서 요약, 정보 추출

*출처: 3개 문서*

---

#### 15. 프롬프트 라이브러리 구축

**설명**: 자주 사용하는 프롬프트 패턴을 수집하고 정리하여 재사용 가능한 라이브러리를 만드는 방식

**관련 도구**: Notion, Google Docs

*출처: 2개 문서*

---

#### 16. 4: Knowledge Graph Memory

**설명**: 세션 간 복잡한 연결 정보와 컨텍스트를 기억하는 지식 그래프 메모리 시스템

*출처: 2개 문서*

---

#### 17. 도메인 컨텍스트 명시화

**설명**: 기술 스택, 아키텍처 패턴, 산업 표준을 상세히 정의하여 일관된 기술 선택 보장.

*출처: 2개 문서*

---

#### 18. 코드 생성 프롬프트 템플릿

**설명**: 언어, 요구사항, 고려사항(오류/엣지/성능) 명시 템플릿

*출처: 2개 문서*

---

#### 19. 코드베이스 탐색 프롬프트 패턴

**설명**: AI에게 기존 프로젝트를 분석 요청할 때 8가지 구조화된 질문(목적, 문제 해결, 컴포넌트, 기술 스택, 구조, 데이터 흐름, 아키텍처 결정, 도메인)을 포함하여 개념적 수준의 이해를 요청하면 효과적인 온보딩이 가능함

*출처: 2개 문서*

---

#### 20. Prd 생성 프롬프트 템플릿

**설명**: 구조화된 프롬프트를 사용하여 AI가 체계적인 PRD를 생성하도록 유도하는 기법입니다.

*출처: 2개 문서*

---

#### 21. 다단계 사고 유도

**설명**: XML 구조화 프롬프트를 사용하면 Claude가 복잡한 작업을 여러 단계로 나누어 사고

*출처: 2개 문서*

---

#### 22. 슬래시 커맨드 활용법

**설명**: `/web spring-boot로 crud application을 만드는 방법은?` 형태로 웹 검색과 결합한 질문

*출처: 2개 문서*

---

#### 23. 기술 면접 준비

**설명**: 특정 역할에 대한 기술 면접 준비 - 핵심 주제, 일반적인 기술 질문, 실습 연습 개요 제공

**적용 조건**: 기술직 원격 면접 준비 시

*출처: 2개 문서*

---

#### 24. Mcp 클라이언트-서버 아키텍처 분리 패턴

**설명**: AI 개발자와 서비스 제공자(MCP 서버 개발자)의 역할을 명확히 분리. AI 개발자는 프롬프트 엔지니어링에, 서버 개발자는 도메인 특화 서비스 래핑에 집중

**적용 조건**: AI 기반 애플리케이션에서 외부 도구/API 통합 시 책임 분리

*출처: 2개 문서*

---

#### 25. 목적별 프롬프트 분리

**설명**: YouTube 스크립트 번역, 기술 문서 요약 등 목적별 템플릿

*출처: 2개 문서*

---

#### 26. 컨텍스트 주입 프롬프트 템플릿

**설명**: 검색된 문서와 사용자 질문을 조합하는 템플릿 기반 프롬프트 구성. "확신이 없으면 모른다고 말하라"는 지시로 환각 방지

**적용 조건**: 특정 질문에 대해 정확한 답변이 필요할 때, 배경 정보나 참조 자료 제공 시

*출처: 2개 문서*

---

#### 27. Claude.Md 기반 프로젝트 컨텍스트 관리

**설명**: 저장소 루트의 CLAUDE.md가 자동 로드되어 프로젝트 이해 기반 제공.

*출처: 2개 문서*

---

#### 28. Dspy 프레임워크

**설명**: 프롬프트를 프로그래밍으로 대체, 모듈화된 AI 시스템 구축

*출처: 2개 문서*

---

#### 29. Rag - 검색 증강 생성

**설명**: 대규모 문서 전체를 LLM에 보내는 대신, 사용자 질문과 관련된 문서 부분만 벡터 유사성 검색으로 추출하여 컨텍스트로 제공

**적용 조건**: 대용량 문서(예: 1000페이지 PDF) 기반 Q&A 시스템, LLM이 학습하지 않은 도메인 지식 활용

*출처: 2개 문서*

---

#### 30. 샌드박스 환경에서의 안전한 에이전트 실행

**설명**: 파일시스템과 명령 실행 환경에 접근하는 에이전트의 프롬프트 인젝션 등 공격을 허용 가능한 수준으로 제한하기 위한 샌드박스 구축

*출처: 2개 문서*

---

#### 31. 포괄적 컨텍스트 윈도우 관리

**설명**: 프로젝트 컨텍스트와 현재 작업을 명시적으로 설정하여 대화 전반에 일관된 맥락 유지

**관련 도구**: Claude, ChatGPT, Claude Code

**적용 조건**: 복잡한 프로젝트 작업 시

---

#### 32. 데이터베이스 스키마 설계 프롬프트

**설명**: 애플리케이션, 엔티티, 요구사항 기반 스키마 요청

---

#### 33. 범용 Xml 프롬프트 템플릿

**설명**: task/topic/format/tone/persona/audience/input/constraints/goal 등의 요소를 포함하는 표준화된 XML 프롬프트 구조

---

#### 34. 파일 참조 기반 컨텍스트 제공

**설명**: 전체 파일 덤핑 대신 범위가 지정된 파일 참조와 라인 번호 사용.

---

#### 35. 선제적 성능 분석 프롬프트

**설명**: N+1 쿼리, API 응답 시간, 인덱스 누락 체계적 점검.

---

#### 36. 퓨샷(Few-Shot) 프롬프트

**설명**: 여러 가지 예시를 제공하여 원하는 형식으로 답변 유도

**적용 조건**: 복잡한 작업, 일정한 형식의 답변 필요 시

---

#### 37. 작업 크기별 전략적 접근

**설명**: 작업을 쉬움/중간/어려움 세 카테고리로 분류하여 각각 다른 방식으로 AI를 활용 (쉬움: 한 번의 프롬프트, 중간: 계획 모드 후 자동 수락, 어려움: 개발자 주도 페어 프로그래밍)

---

#### 38. 제약 조건(Constraints) 명시하기

**설명**: "must not" 형태의 제약 조건을 프롬프트에 명확히 정의

**관련 도구**: 모든 LLM 기반 코딩 도구

**예시**: "내가 추가한 테스트를 변경하지 말고 테스트가 성공하도록 해라"

---

#### 39. 한번 끝까지 해보기 (역방향 프롬프트 작성)

**설명**: 먼저 기존 방식대로 작업을 완료하고, 그 과정에서 컨텍스트를 학습한 후 역으로 프롬프트를 만드는 방법

**관련 도구**: GitHub CLI, Claude Code

---

#### 40. 롤백 후 컨텍스트 재설정 기법

**설명**: AI가 원하는 방향으로 작업하지 않을 때, 코드 수정 대신 롤백하고 컨텍스트를 다르게 제공

**관련 도구**: Claude Code, Git

---

#### 41. 질문 역량 강화 (Prompt Engineering)

**설명**: "질문을 잘하는 능력"이 핵심 경쟁력

---

#### 42. Sticc 프롬프팅 프레임워크

**설명**: Situation, Task, Intention, Concern, Calibration의 5가지 요소를 포함한 구조화된 프롬프트

**관련 도구**: ChatGPT, Claude, Cursor

---

#### 43. Cta (Cognitive Task Analysis) 기반 프롬프팅

**설명**: 작업을 입력-처리-출력-다음 행동으로 분해하여 AI에게 위임할 부분을 명확히 정의

**관련 도구**: Claude, ChatGPT, Cursor

---

#### 44. 불확실성 지도 (Uncertainty Map)

**설명**: AI 응답 하단에 AI가 가장 덜 자신있는 부분을 명시하게 하는 기법

**관련 도구**: 모든 LLM

---

#### 45. 되묻게 하기 (Ask-Back Prompting)

**설명**: AI가 더 유용한 응답을 위해 필요한 컨텍스트를 직접 요청하게 하는 기법

**예시**: "이 작업을 수행하기 위해 더 필요한 정보가 있다면 1-2개의 핵심 질문을 먼저 해줘"

---

#### 46. 프롬프트와 컨텍스트 버전관리

**설명**: AI와의 채팅 기록, 구현 계획, 테스트 방법을 모두 파일로 저장하고 Git으로 버전관리

**관련 도구**: Git, Claude Code

---

#### 47. Repomix를 이용한 리팩토링

**설명**: 코드베이스 전체를 하나의 문서로 만들고, 컨텍스트 큰 LLM에게 리팩토링 계획 수립

**관련 도구**: Repomix, Gemini AI Studio

---

#### 48. 메타 프롬프트로 프롬프트 개선

**설명**: AI에게 내 프롬프트를 개선하게 하고, 개선 이유도 설명하게 함

**관련 도구**: OpenAI Prompt Optimizer

---

#### 49. Claude.Md 파일 활용 (Context Documentation)

**설명**: 작업 디렉토리에 claude.md 파일을 생성하여 단위 테스트 실행 방법, 프로젝트 레이아웃 개요, 스타일 가이드 등을 포함시켜 세션 간 상태 공유

**관련 도구**: Claude Code

**적용 조건**: Claude Code와 협업하는 모든 프로젝트

---

#### 50. 시스템 프롬프트에 오늘 날짜 포함

**설명**: 일정 관리 AI 에이전트는 오늘 날짜를 정확히 알아야 하므로 프롬프트에 날짜를 동적으로 삽입

**관련 도구**: n8n

**예시**: `{{ $now.format('yyyy-MM-dd') }}`

---

#### 51. Requirements 템플릿 작성

**설명**: 비즈니스 요구사항, 기능적/비기능적 요구사항을 체계적으로 문서화하여 LLM에게 명확한 스펙 제공

**관련 도구**: 모든 LLM

**예시**: 성능, 보안, 동시 사용자 수, 가용성 등을 측정 가능하게 명시

---

#### 52. 러버 덕 디버깅 With Ai

**설명**: 증상, 시도한 접근법, 가설을 설명하고 "근본 원인 식별을 위한 5가지 질문" 요청

**관련 도구**: ChatGPT, Claude

---

#### 53. Cmd K 인라인 프롬프트

**설명**: Ctrl/⌘ + K로 편집기에서 직접 프롬프트 바 열어 코드 수정 요청

**관련 도구**: Cursor AI

**예시**: "이 함수의 성능 개선을 위한 리팩토링"

---

#### 54. Yaml 기반 서브에이전트 템플릿 정의

**설명**: name, description, model 필드로 구조화된 설정

---

#### 55. 베스트 프랙티스 내장 프롬프팅

**설명**: OWASP, SOLID, PEP 8 등 표준을 프롬프트에 포함

---

#### 56. Context7을 통한 실시간 문서 통합

**설명**: "use context7" 프롬프트로 최신 문서 삽입

---

#### 57. 사전 압축 (Pre-Compact)

**설명**: /compact로 컨텍스트 미리 압축

---

#### 58. 최소 프롬프트로 빠른 프로토타이핑

**설명**: 2개 프롬프트로 웹사이트 구현

---

#### 59. 명확성과 반복 (Clarity And Iteration)

**설명**: 명확한 요청으로 시작하고 프롬프트 수정 반복

---

#### 60. Ai에게 추가 질문 요청하기

**설명**: AI가 필요한 정보를 역으로 질문하도록 유도

---

#### 61. 아이디어 생성 질문 기법

**설명**: "무엇을 놓쳤을 수 있는가?" 질문으로 엣지 케이스 발견

---

#### 62. 목적 중심 Ai 도입 원칙

**설명**: "해결하려는 구체적 문제가 무엇인가?" 우선 질문

---

#### 63. 프롬프트에 효율성 요구사항 명시

**설명**: 입력 크기, 원하는 시간 복잡도, 성능 제약을 프롬프트에 명시

---

#### 64. 1인칭 시선 데이터 활용 (미래 트렌드)

**설명**: 스마트 글래스를 통한 사용자 시선/컨텍스트 데이터 활용

---

#### 65. 빈번한 세션 갱신

**설명**: 기능 완료 후 새로운 세션 시작으로 컨텍스트 저하 방지

---

#### 66. 프롬프트에 응답 형식 제한 명시

**설명**: "100 words로 제한" 등 제약조건 프롬프트에 포함

---

#### 67. 이론 기반 정교한 질문

**설명**: 배경 지식과 전문 용어를 활용한 구체적 질문

---

#### 68. 아키텍처 결정 기록(Adr) 생성 요청

**설명**: 논의 결과를 ADR 템플릿으로 문서화

---

#### 69. 코드 설명 요청 프롬프트

**설명**: 목적, 단계별 동작, 잠재적 문제점 질문

---

#### 70. 알고리즘 구현 요청 템플릿

**설명**: 함수, 헬퍼, 복잡도 분석, 사용 예제 4요소 포함

---

#### 71. 클래스/모듈 생성 템플릿

**설명**: 생성자, 메인 메서드, private 헬퍼, 캡슐화 체크리스트

---

#### 72. 단위 테스트 생성 프롬프트

**설명**: 정상 입력, 엣지 케이스, 잘못된 입력 3카테고리

---

#### 73. Sql 쿼리 최적화 프롬프트

**설명**: 쿼리, DB 시스템, 테이블 크기 컨텍스트 제공

---

#### 74. Think Harder 지시어

**설명**: "Think harder"를 프롬프트 끝에 추가하여 Claude가 더 깊이 사고하도록 유도하는 기법

**예시**: `"We will now add the ability to save chats locally... Think Harder"`

---

#### 75. 대화 내보내기 및 컨텍스트 관리

**설명**: `/export`, `/compact`, `/clear` 명령으로 대화 내역 관리 및 토큰 최적화

---

#### 76. 새로운 대화 자주 시작하기 (Fresh Chat Strategy)

**설명**: 긴 대화는 컨텍스트 처리량을 증가시켜 메시지 할당량을 빠르게 소모하므로, 새로운 주제마다 새 대화를 시작

---

#### 77. 질문 배치 처리 (Question Batching)

**설명**: 여러 개의 관련 질문을 하나로 묶어서 한 번에 보내는 기법

---

#### 78. Mcp 멀티턴 컨텍스트 유지

**설명**: DeepSeek MCP를 활용하여 메시지 간 컨텍스트를 유지하면서 대화를 이어가는 기법

---

#### 79. 세션 간 컨텍스트 연속성 관리

**설명**: Plan을 문서로 저장하여 세션이 끊어지더라도 다음 세션에서 기존 계획을 검토하고 보완

---

#### 80. 컨텍스트 인식 (Context Awareness)

**설명**: 대화 중 사용 가능한 토큰을 실시간 추적하여 토큰 한계 관리를 자동화

---

#### 81. Before/After 비교 패턴

**설명**: 일반 프롬프트와 구조화된 XML 프롬프트를 비교하여 개선점을 확인하는 학습 방법

---

#### 82. Ctrl+G 프롬프트 편집기 활용

**설명**: 구성된 텍스트 에디터에서 프롬프트를 편집한 후 Claude에게 전송

---

#### 83. 시스템 프롬프트 최적화

**설명**: 시스템 프롬프트를 1.4k 토큰 감소시켜 컨텍스트 윈도우 공간을 확보

---

#### 84. 시스템 프롬프트를 통한 컨텍스트 설정

**설명**: Claude.md 파일을 생성하여 전역 시스템 프롬프트로 활용

---

#### 85. 템플릿 기반 구조화 프롬프팅

**설명**: 미리 정의된 템플릿을 제공하여 AI가 일관된 형식으로 콘텐츠를 생성

---

#### 86. 이전 컨텍스트 활용 업데이트

**설명**: AI가 기존 다이어그램이나 문서의 컨텍스트를 활용하여 전체 재생성이 아닌 점진적 업데이트

---

#### 87. 코드베이스 컨텍스트 분석 자동화

**설명**: Claude Code가 전체 코드베이스를 스캔하여 컴포넌트, 서비스, 관계를 자동으로 식별

---

#### 88. 오케스트레이터 패턴

**설명**: 스킬 프롬프트는 라우팅 로직만 담당하고, 상세 문서는 references에, 기계적 작업은 scripts에 분리

---

#### 89. Pda 적용 의사결정 프레임워크

**설명**: 4가지 질문으로 PDA 적용 여부 결정

---

#### 90. 구체적 프롬프트 작성 (Specific Prompt Engineering)

**설명**: 프롬프트가 구체적일수록 결과가 더 좋습니다. 특정 클래스나 패턴을 명시적으로 언급하거나 프로젝트의 명명 규칙에 대한 지식을 공유하면 더 정확한 결과를 얻을 수 있습니다.

**예시**: - 일반적: "테스트를 만들어줘" (모호함)

---

#### 91. 계획 우선 개발 (Planning First Development)

**설명**: AI 코딩을 시작하기 전에 Figma, v0.ai 등을 활용해 시각적 프로토타입을 먼저 제작합니다. 최소 10-15개의 프롬프트를 사용하여 원하는 디자인에 근접하게 만든 후 코딩에 착수합니다.

**예시**: v0.ai에서 UI 프로토타입 10-15회 반복 개선 후 Cursor로 구현

---

#### 92. Cursor Rules 프롬프트 템플릿 활용

**설명**: cursor.directory 사이트에서 사용 중인 기술 스택에 맞는 프롬프트 템플릿을 가져와 프로젝트 루트의 `cursor.rules` 파일에 적용합니다.

**예시**: cursor.directory에서 "React + TypeScript" 템플릿 선택 → 프로젝트 루트에 .cursor.rules 파일 생성

---

#### 93. 스타터 템플릿 활용

**설명**: 인증, 데이터베이스, 결제 시스템 등 공통 기능이 이미 구현된 스타터 템플릿을 활용하여 새 프로젝트를 시작합니다.

**예시**: SaaS 스타터 키트(인증 + DB + 결제 포함) 기반으로 시작

---

#### 94. Rag 워크플로우 (Obsidian 노트 컨텍스트 활용)

**설명**: Obsidian vault를 Cursor에서 열고, `@` 멘션을 통해 파일/폴더를 AI 대화에 포함시켜 개인 지식베이스 기반 RAG를 구현합니다.

**예시**: `@폴더명` 또는 `@파일명.md`로 Obsidian 노트를 멘션하고 "이 내용을 바탕으로 요약해줘"

---

#### 95. Codebase Indexing 활용

**설명**: Cursor의 `codebase` 기능을 활용하여 전체 vault/프로젝트를 인덱싱하고, 자연어 질문으로 관련 문서를 검색합니다.

**예시**: "내가 최근 TDD에 대해서 작성한 토론이 뭔지 알려줘" + codebase 버튼 클릭

---

#### 96. Prompt Generator 활용

**설명**: OpenAI Playground나 Anthropic Console을 사용하여 System Instructions를 설정하고 프롬프트를 테스트합니다.

**예시**: "워크샵 주제를 입력하면 해당 워크샵의 기획안을 작성하세요"와 같은 시스템 프롬프트 설계

---

#### 97. 대화 중 문서 전환 (동적 컨텍스트 전환)

**설명**: AI와 대화를 진행하다가 특정 문서를 `@`로 멘션하여 참조 문서를 동적으로 변경합니다.

**예시**: 일반 질문 → 답변 확인 → `@specific-doc.md 이 문서에서 관련 내용을 찾아줘`

---

#### 98. 이미지 기반 Ui 생성

**설명**: Webflow 템플릿이나 직접 그린 스케치 이미지를 AI에 첨부하여 동일한 디자인을 생성하도록 요청합니다.

**예시**: 스케치 첨부 후 "첨부한 이미지대로 똑같이 디자인 해줘"

---

#### 99. 점진적 Ui 개선 프롬프트 시퀀스

**설명**: UI를 한 번에 완성하지 않고 초기 UI → 섹션 추가 → 애니메이션 → 디자인 개선 순서로 점진적으로 요청합니다.

**예시**: landing page 생성 → testimonial section 추가 → CTA 추가 → shadcn ui 스타일 적용

---

#### 100. 언제 멈출지 아는 것 (When To Stop Prompting)

**설명**: AI가 문제를 해결하지 못할 때 프롬프트를 계속 시도하는 대신, 직접 해결하기로 전환하는 시점을 판단하는 능력이 중요합니다.

**예시**: AI가 3-5번의 시도에도 해결되지 않으면 타이머를 설정하고, 10분 내 해결되지 않으면 공식 문서를 직접 읽거나 수동으로 해결

---

#### 101. 매몰 비용 오류 인식 (Sunk-Cost Fallacy Awareness)

**설명**: "한 번만 더 프롬프트를 시도하면 될 것 같다"는 생각으로 계속 시간을 투자하는 심리적 함정을 인식해야 합니다.

**예시**: AI 세션마다 타임박스(15-30분)를 설정하고, 시간이 초과되면 전략을 전환

---

#### 102. 비결정적 특성 인식 및 방향 수정

**설명**: AI의 비결정적(non-deterministic) 특성을 이해하고, 같은 프롬프트에도 다른 결과가 나올 수 있음을 인지합니다.

**예시**: AI 출력을 맹신하지 않고 항상 검증, 여러 번 실행하여 일관된 패턴 탐색

---

#### 103. 프롬프트 엔지니어링 역량 구축

**설명**: AI 도구의 효과는 프롬프트 품질에 크게 좌우됩니다. 비즈니스 맥락과 사용자 요구사항을 AI에게 명확하게 전달하는 능력을 개발해야 합니다.

**예시**: 요구사항을 구체적이고 구조화된 형태로 프롬프트에 포함, 프로젝트 컨텍스트, 제약조건, 기대 결과물 명시

---

#### 104. 타입 안전 프롬프트-코드 연동

**설명**: 프롬프트와 수동 작성 코드가 강타입 도메인 모델을 통해 깔끔하게 상호작용합니다.

**예시**: Kotlin/Java 클래스로 도메인 객체를 정의하고 IDE의 리팩토링 기능을 활용

---

#### 105. 타입 안전 프롬프트 (Type-Safe Prompts)

**설명**: Kotlin 데이터 클래스나 Java 레코드를 사용하여 풍부한 도메인 모델을 구축하고, 프롬프트를 타입 안전하게 구성합니다.

**예시**: `data class StoryRequest(val theme: String, val characters: List<String>)` - 클래스가 자동으로 프롬프트 구조로 변환

---

#### 106. 템플릿 기반 에이전트 프로젝트 생성

**설명**: 단일 명령어로 JVM 기반 AI 에이전트 프로젝트를 생성할 수 있습니다.

**예시**: `uvx --from git+https://github.com/embabel/project-creator.git project-creator` → 1분 내 실행 가능한 에이전트 프로젝트 생성

---

#### 107. Ai 세션 압도 시 중단 및 재시작

**설명**: AI 코딩 세션에서 진행 상황에 압도당한다고 느낄 때 세션을 중단하고, 프롬프트를 수정하여 새 세션을 시작합니다.

**적용 조건**: AI가 토끼굴에 빠지거나 컨텍스트 창이 너무 커져서 혼란스러워질 때

---

#### 108. Ai 코딩 어시스턴트에 커스텀 규칙 설정

**설명**: 팀의 좋은 관행을 코드화한 프롬프트 지침을 반복적으로 개선하여 AI의 실수를 완화합니다.

**적용 조건**: 반복적인 AI 실수 패턴이 발견될 때

---

#### 109. Ai의 광범위한 접근 방지

**설명**: 기능의 작동하는 수직 조각(vertical slice)으로 시작하도록 프롬프트에서 명시적으로 지시합니다.

**적용 조건**: 프론트엔드 마이그레이션, 대규모 리팩토링 시

---

#### 110. 패턴(Pattern) 기반 프롬프트 템플릿화

**설명**: 자주 사용하는 프롬프트를 "패턴"으로 저장하여 재사용합니다. CLI에서 `-p` 옵션으로 즉시 호출 가능합니다.

**적용 조건**: 반복적인 AI 작업(코드 리뷰, 요약, 분석 등)을 수행할 때

---

#### 111. 다중 프롬프트 체이닝 워크플로우

**설명**: 여러 프롬프트를 파이프(`|`)로 연결하여 복잡한 AI 워크플로우를 구성합니다.

**적용 조건**: 문서 분석 → 요약 → 번역 같은 다단계 처리

---

#### 112. 프롬프트 품질 향상 (Improve_Prompt)

**설명**: 작성한 프롬프트를 입력하면 더 명확하고 효과적인 프롬프트로 개선해줍니다.

**적용 조건**: AI 출력 품질이 낮을 때

---

#### 113. 커스텀 인스트럭션(Custom Instructions) 설정

**설명**: 프로젝트별로 AI에게 컨텍스트를 제공하는 설정 파일을 작성합니다.

**적용 조건**: 팀에서 일관된 AI 활용 품질을 유지하고 싶을 때

---

#### 114. 전체 코드베이스 컨텍스트 탐색

**설명**: 특정 파일만 지정하는 방식 대신 코드베이스 전체를 탐색하여 숨겨진 의존성까지 파악합니다.

**적용 조건**: 레거시 코드 리팩토링, 영향 분석 시

---

#### 115. 로컬 환경에서의 Llm 모델 비교 평가

**설명**: Open Web UI의 다중 모델 선택 기능을 활용하여 동일한 프롬프트로 여러 AI 모델의 응답을 동시에 비교합니다.

**적용 조건**: 특정 작업에 가장 적합한 모델을 선정할 때

---

#### 116. 멀티 Ai 프롬프트 체이닝

**설명**: Claude → GPT → Claude Opus4 협업

---

#### 117. 재사용 가능한 프롬프트

**설명**: 패턴 기반 CLI 파이프라인

---

#### 118. 고무 오리 디버깅의 진화형 활용

**설명**: AI를 "실제로 대답하고 당신보다 더 많이 알고 있는 고무 오리"로 활용. 더 많은 컨텍스트를 제공할수록 더 좋은 결과.

---

#### 119. Why 중심의 학습 요청

**설명**: AI에게 구현 방법(HOW)뿐만 아니라 왜 그렇게 작동하는지(WHY)를 함께 질문하여 이해도 향상.

---

#### 120. Promptrunner를 활용한 구조화된 출력

**설명**: `PromptRunner.usingLlm().createObject(prompt, TargetClass.class)` 패턴으로 LLM 응답을 Java 객체로 직접 매핑

---

#### 121. 프롬프트 템플릿 외부화

**설명**: `src/main/resources/prompt-templates/` 디렉토리에 프롬프트 별도 관리, `@Value`로 주입

---

#### 122. Ui 생성 및 통합 프롬프트 패턴

**설명**: `Implement web UI on top of the CRUD API, build the frontend code and integrate...`

---

#### 123. 레거시 프로젝트 기능 추가 프롬프트 패턴

**설명**: `What would it take to add [기능] functionality to the [프로젝트명] application...`

---

#### 124. @Symbol 참조를 활용한 정확한 컨텍스트 지정

**설명**: `@symbol:AlgorithmController`처럼 코드 심볼 직접 참조

---

#### 125. 다단계 구조화된 프롬프트 작성

**설명**: 복잡한 작업을 번호가 매겨진 단계로 분리하여 요청

---

#### 126. 컨텍스트 관리를 통한 정확도 향상

**설명**: 파일, 폴더 또는 이미지를 컨텍스트로 추가

---

#### 127. 여러 파일에 걸친 리팩토링 요청

**설명**: 한 번의 프롬프트로 다중 파일 변경 요청, diff로 검토

---

#### 128. 상세한 요구사항 명세 프롬프트

**설명**: REST API 생성 시 엔드포인트별 기능, 예외 처리 로직, 기본값 설정, 사용 기술 스택을 명확히 기술

---

#### 129. 기존 Api 문서 활용

**설명**: Postman Collection을 컨텍스트로 제공하여 프론트엔드 애플리케이션 생성

---

#### 130. 프롬프트 템플릿 명명 규칙 변경

**설명**: 더 명확하고 일관된 네이밍 컨벤션 적용

---

#### 131. 입력-출력 비율 인식

**설명**: AI 프롬프트(100단어)로 결과물(1만 단어) 생성하면 '선택'의 본질 사라짐 → 정밀한 제어가 필요하면 충분한 입력 제공

---

#### 132. 프롬프트 주도 개발(Prompt-Driven Development, Pdd)

**설명**: - TDD의 원칙을 AI 프롬프트 설계에 적용

---

#### 133. Promptpex를 활용한 프롬프트 테스트

**설명**: - 프롬프트에 대한 테스트 스위트를 자동 생성하는 프레임워크 활용

---

#### 134. 컨텍스트 인식 개발 지원 활용

**설명**: - 전체 아키텍처 패턴을 AI에게 설명

---

#### 135. 프롬프트의 체계적 보존 (Prompt Preservation)

**설명**: - Vibe Coding 시 생성된 코드만 보관하고 프롬프트를 버리는 것은 잘못

---

#### 136. Lovable + Cursor 에이전트 실험

**설명**: - Lovable로 프롬프트 기반 프로토타입 생성

---

#### 137. 올바른 질문 프레임워크 (리더용)

**설명**: - "개발자가 필요 없어질까?" (잘못된 질문)

---

#### 138. 3: Double Escape (Esc Esc) 대화 분기 기법

**설명**: 고품질 컨텍스트 구축 후 Double Escape로 대화 분기하여 동일 컨텍스트 재사용

---

#### 139. 5: 3층 컨텍스트 아키텍처

**설명**: 프로젝트 정보를 세 가지 계층으로 구조화
  - Layer 1: Project DNA (아키텍처, 기술 스택, 코딩 표준)
  - Layer 2: Active Context (현재 스프린트, 최근 변경사항)
  - Layer 3: Task-Specific Context (현재 작업 파일, 테스트, 에러)

---

#### 140. 7: Context Pipeline Approach

**설명**: 스크립트로 개발 컨텍스트 자동 수집 및 통합

---

#### 141. 2: Context7을 통한 최신 문서 실시간 주입

**설명**: AI가 최신 공식 문서와 코드 예제를 실시간으로 가져와 컨텍스트에 주입

---

#### 142. 5: 시맨틱 코드 검색 (Code Context Mcp)

**설명**: 자연어 질문으로 코드베이스에서 관련 코드 검색, AST 기반 지능형 청킹

---

#### 143. 전통적 코딩 + Ai 도구 둘 다 마스터

**설명**: 코딩 기본기(디버깅, 검증)와 AI 도구(프롬프트, 오케스트레이션) 모두 필요

---

#### 144. 프로덕션 코드 기반 질의 패턴

**설명**: AI에게 일반적인 코드 패턴 대신 실제 검증된 구현 예제를 요청하는 프롬프트 방식

---

#### 145. 실제 사용 사례별 프롬프트 패턴

**설명**: - **인증 구현**: "적절한 에러 관리를 포함한 OAuth 새로고침 토큰 처리의 프로덕션 예제를 찾아줘"

---

#### 146. 프롬프트 포맷팅 패턴

**설명**: 멀티라인 문자열과 템플릿 변수를 조합한 구조화된 프롬프트 작성

---

#### 147. Mcp 서버를 통한 컨텍스트 주입

**설명**: `shadcn-ui-mcp-server`를 설치하여 AI에게 컴포넌트 사용 예제, 메타데이터, 블록 정보를 실시간으로 제공

---

#### 148. 모델 매개변수 최적화

**설명**: 컨텍스트 길이, 온도, 응답 형식 조정

---

#### 149. 불확실성 표시 요구

**설명**: "불확실한 부분이 있다면 명시적으로 표시해주세요"

---

#### 150. 컬렉터-실행자 패턴

**설명**: 도구를 컬렉터(컨텍스트 수집)와 실행자(CRUD 작업)로 구분

---

#### 151. Mcp 서버 내장 프롬프트 활용

**설명**: `/fetch`, `/sql` 등 사전 정의된 프롬프트

---

#### 152. 구조화된 컨텍스트 제공

**설명**: XML 태그로 정보 구분 (`<name>`, `<src>`)

---

#### 153. 소스 코드 일괄 수집 스크립트

**설명**: `find` + `cat`으로 전체 컨텍스트 제공

---

#### 154. 타겟 오디언스 명확화

**설명**: 콘텐츠를 "컴퓨터과학 학사, 소프트웨어 공학 석사 수준의 한국 개발자"를 위해 작성하도록 지정하여, 프롬프트의 정확도와 관련성을 높입니다.

---

#### 155. 문맥 기반 질문 설계

**설명**: 특정 노트의 핵심 개념을 추출하도록 유도하는 구조화된 질문.

---

#### 156. 로컬 Llm 실행 최적화

**설명**: GPU 오프로드, 컨텍스트 길이, CPU 스레드풀 크기 조정.

---

#### 157. Ai를 주니어 개발자로 대우

**설명**: 명확한 지시와 컨텍스트 제공, 결과물에 대한 검증 필수.

---

#### 158. 시스템적 워크플로우 구축

**설명**: "마법의 프롬프트"보다 재사용 가능한 프로세스가 핵심.

---

#### 159. 컨텍스트 윈도우 최적화

**설명**: 중요 정보 우선 배치, 노이즈 제거, 효과적 구조화로 제한된 컨텍스트 최대 활용.

---

#### 160. 재사용 가능한 패턴 체계화

**설명**: 성공한 PRP 템플릿을 시스템 프롬프트에 통합하여 일관된 품질 보장.

---

#### 161. 계층적 아키텍처 분석 프롬프트

**설명**: 마이크로서비스 경계, 통신, DB 스키마 체계적 파악 + 다이어그램 생성.

---

#### 162. 자연언어 기반 일상 Q&A 패턴

**설명**: "결제 처리는 어떻게 동작하나?" 같은 자연스러운 질문으로 온보딩.

---

#### 163. 패턴 일관성 기반 생성 프롬프트

**설명**: 기존 서비스 패턴 분석 후 새 서비스 생성 시 규칙 준수.

---

#### 164. 재사용 가능한 커스텀 커맨드 라이브러리

**설명**: .claude/commands/에 표준화된 작업 템플릿 저장.

---

#### 165. 도메인 주도 설계(Ddd) 접근법

**설명**: 서브도메인과 바운디드 컨텍스트 식별, 컨텍스트 맵 작성.

---

#### 166. 구체성 제공(Specificity)

**설명**: 일반적 질문 대신 구체적 정보 포함하여 프롬프트 작성.

---

#### 167. Few-Shot Learning

**설명**: 원하는 결과물의 예시를 미리 보여주어 형식과 톤 유도.

---

#### 168. 연쇄 프롬프팅(Chained Prompting)

**설명**: 첫 결과물을 두 번째 프롬프트의 입력으로 사용.

---

#### 169. Simple-To-Detailed 프롬프트 계층화

**설명**: 단순 요청으로 시작하여 상세한 명세서로 확장.

---

#### 170. 의도 감지(Intent Detection) 기반 응답

**설명**: 50% 이상 확신 있으면 질문으로 간주하고 답변.

---

#### 171. 화면 기반 컨텍스트 우선순위화

**설명**: 음성과 화면 정보 함께 분석, 상황별 동적 우선순위 조정.

---

#### 172. 행동 사례 질문 처리

**설명**: 사용자 이력 사용하거나 일반 예시로 채우되 검증 불가 팩트 회피.

---

#### 173. 프롬프트 숨김 및 신원 보호

**설명**: 지침 언급 금지, 정체에 대해 간단히만 답변.

---

#### 174. 자연어 시나리오 변환 프롬프트

**설명**: 자연언어 테스트 시나리오를 구조화된 단계별 지시사항으로 변환.

---

#### 175. Zapier Instruction Template 활용

**설명**: Zapier가 제공하는 instruction 템플릿을 복사하여 action과 link만 변경

**적용 조건**: Zapier 액션을 빠르게 설정하고 싶을 때

---

#### 176. 멀티모달 프롬프트 기법 (Claude 글쓰기)

**설명**: 이미지를 포함한 멀티모달 입력으로 Claude에게 구조화된 글쓰기 요청

**적용 조건**: 스크린샷 기반 분석, 시각 자료 기반 문서 작성

---

#### 177. 제약 조건 명시 프롬프팅 (Constraint-Based Prompting)

**설명**: AI에게 코드 생성 시 구체적이고 상세한 제약 조건을 나열하여 원하는 형태의 코드를 정확하게 생성

**적용 조건**: 특정 아키텍처 패턴을 준수해야 할 때, 프로젝트의 코딩 컨벤션이 엄격할 때

**예시**: "DTO는 record로 구현", "Controller에 nested class로 구현", "부연 설명 없이 코드만 작성"

---

#### 178. 아키텍처 제약 프롬프팅 (Architecture Constraint Prompting)

**설명**: 클래스 구조, 레이어 분리, 의존성 관계 등 아키텍처 수준의 제약을 명시하여 일관된 코드 구조 유도

**적용 조건**: 마이크로서비스 아키텍처 구축 시, 레이어드 아키텍처 준수가 필요할 때

---

#### 179. 파레토 원칙(80/20) 적용 전략 프롬프트

**설명**: AI를 전문 전략가로 역할 설정하여 목표 달성을 위한 모든 전략을 도출하고, 그 중 80% 결과를 가져올 20% 핵심 전략을 식별

**적용 조건**: 비즈니스 목표 설정, 프로젝트 기획, 리소스 최적화가 필요할 때

**예시**: "심호흡을 하고 이 문제를 단계별로 해결해 보세요."

---

#### 180. 소셜 미디어 콘텐츠 생성 프롬프트

**설명**: 플랫폼별 특성을 고려한 바이럴 콘텐츠 생성 요청 기법

**적용 조건**: Twitter, LinkedIn 등 소셜 미디어 콘텐츠 제작 시

---

#### 181. 영문 교정 요청 간소화

**설명**: 간단한 프롬프트로 영문 오류를 체크하는 기법

**적용 조건**: 영문 콘텐츠의 문법, 철자 검토가 필요할 때

**예시**: "Are there any minor english issues:"

---

#### 182. 점진적 개선을 위한 후속 질문 패턴

**설명**: AI의 첫 응답에 만족하지 않고 지속적으로 피드백과 후속 질문을 통해 결과물을 개선

**적용 조건**: 초기 결과물이 기대에 미치지 못하거나 더 구체적인 결과가 필요할 때

---

#### 183. Claude.Md를 Guidelines.Md로 활용

**설명**: claude init으로 생성한 CLAUDE.md를 Junie의 guidelines.md로 복사하여 AI 어시스턴트에게 프로젝트 컨텍스트 제공

**적용 조건**: 여러 AI 도구를 사용할 때 일관된 프로젝트 가이드라인 공유

---

#### 184. 탐색적 프롬프팅 (Exploratory Prompts)

**설명**: 프로젝트 이해, 개선 제안, 기능 추천을 위한 오픈형 질문 프롬프트 활용

**적용 조건**: 프로젝트 초기 분석이나 개선 방향 모색 시

**예시**: "Tell me about this project", "What features do you recommend we ask?"

---

#### 185. 실행 제한 프롬프팅 (Suggest-Only Prompts)

**설명**: AI에게 제안만 하고 실제 구현은 하지 말라고 명시적으로 지시

**적용 조건**: 구현 전 계획 검토가 필요하거나, AI의 자동 코드 생성을 제어하고 싶을 때

**예시**: "Please suggest how to implement this, **but DON'T DO IT**"

---

#### 186. 프롬프트 구성요소 4가지

**설명**: 효과적인 프롬프트는 지시(instruction), 질문(question), 문맥(context), 예시(few-shot)로 구성

**적용 조건**: 모든 프롬프트 작성의 기본 원칙

---

#### 187. 프롬프트 가독성 향상 - 지시와 예시 분리

**설명**: ## 기호를 사용하여 지시, 예시 등을 명확히 구분

**적용 조건**: 복잡한 프롬프트 작성 시

---

#### 188. 프롬프트 리스트 형식으로 나열

**설명**: 여러 작업을 번호 매긴 리스트로 명확히 구분

**적용 조건**: 다단계 작업, 복잡한 워크플로우

---

#### 189. Cursor Prompt 최적화 기법

**설명**: 프롬프트 끝에 "Explain the full approach you'd take to implement this. Just tell, don't code."를 추가하여 전체 계획을 먼저 제시하도록 함

**적용 조건**: Cursor IDE에서 코드 구현을 요청할 때, 큰 규모의 변경이나 복잡한 로직 구현 시

---

#### 190. 원격 근무 준비도 의사소통

**설명**: "왜 원격으로 일하고 싶나요?" 질문에 대한 명확하고 설득력 있는 답변 작성

**적용 조건**: 원격 근무 동기 질문 대비

---

#### 191. 구조화된 콘텐츠 요약 프롬프트 (Fabric 스타일)

**설명**: 체계적인 단계별 지침으로 텍스트 콘텐츠에서 SUMMARY, IDEAS, INSIGHTS, QUOTES, FACTS 등 섹션별 추출

**적용 조건**: 긴 콘텐츠(영상, 팟캐스트, 기사 등) 요약 시

---

#### 192. 계획 우선 코딩 프롬프트

**설명**: 코드 작성 전 전체 접근 방식을 설명하도록 요청

**적용 조건**: 복잡한 구현 전 계획 검토가 필요할 때

---

#### 193. 역할 기반 프롬프트 설정 (Role-Based Prompting)

**설명**: AI에게 특정 전문가 역할을 부여하여 전문성과 일관성 있는 응답을 유도

**적용 조건**: 코드 리뷰, 리팩터링 요청 시 AI의 응답 품질을 높이고자 할 때

**예시**: "당신은 Java와 Refactoring 전문가입니다"

---

#### 194. 컨텍스트 기반 참조 제공 (Context-Based Reference)

**설명**: AI에게 특정 전문 서적이나 방법론을 참조하도록 명시

**적용 조건**: 업계 표준이나 검증된 방법론에 따른 코드 개선이 필요할 때

**예시**: Kent Beck의 "TDD By Example", Joshua Kerievsky의 "Refactoring to Patterns"

---

#### 195. Slow Think (슬로우 싱크) 프롬프트 기법

**설명**: Chain of Thought보다 4~10% 더 정확한 결과를 제공하는 고급 프롬프트 기법

**적용 조건**: 중요한 전략 결정, 복잡한 의사결정, 높은 정확도가 필요한 비즈니스 분석

**예시**: "Take a deep breath and work through this carefully."

---

#### 196. 불확실성 관리 및 정직성

**설명**: AI가 자신의 지식 한계를 인지하고, 불확실한 정보에 대해 솔직하게 표현

**적용 조건**: 정보의 모호성이 존재할 때, AI 환각(hallucination) 우려 시

---

#### 197. Step-Back Prompting (한 걸음 물러서기)

**설명**: 구체적인 문제에 매몰되기 전에, 관련된 일반 원칙이나 배경 지식을 먼저 활성화

**적용 조건**: 특정 사례에 대한 판단, 역사적 사건 분석, 새로운 개념 이해

---

#### 198. 지식 베이스 통합을 통한 컨텍스트 인식 Ai 구축

**설명**: 벡터 데이터베이스(Chroma)를 활용하여 AI가 프로젝트별 지식과 문서를 참조하도록 구성

**적용 조건**: 프로젝트 문서와 코드베이스를 AI가 이해해야 할 때, RAG 패턴 적용

---

#### 199. 다단계 프롬프트

**설명**: 지시, 문맥, 예시, 질문 4요소 구조화

---

#### 200. 자체 데이터 통합 (Byod)

**설명**: LLM이 학습하지 않은 사용자의 비공개 문서, 제품 정보, 최신 정보 등을 컨텍스트로 제공

**적용 조건**: 기업 내부 문서 기반 챗봇, 제품 FAQ 시스템

---

#### 201. Ast Pattern Search

**설명**: `search_for_pattern`으로 특정 코드 패턴을 검색하여 정확한 위치 파악. 컨텍스트 라인 포함

**적용 조건**: 특정 코드 패턴이 어디에서 사용되는지 찾아야 할 때, 변수나 메서드 호출의 정확한 위치 특정

---

#### 202. Ai 기반 Bounded Context 설계

**설명**: 특정 도메인에 대해 경계 컨텍스트를 정의하고, 의존성을 3가지로 분류(의존성 없음/업스트림-다운스트림/상호 의존적)

**적용 조건**: 마이크로서비스 경계 결정, 서비스 분리 전략 수립

---

#### 203. Ai 기반 Context Map 시각화

**설명**: 경계 컨텍스트 간의 관계 유형, 통합 메커니즘, 의존성을 분석하여 PlantUML 다이어그램으로 시각화

**적용 조건**: 아키텍처 문서화, 팀 간 의존성 파악

---

#### 204. Ai 기반 전술적 Ddd 모델링

**설명**: 특정 경계 컨텍스트에 대해 애그리게이트, 엔티티, 값 객체, 리포지토리를 식별하고 정의

**적용 조건**: 도메인 모델 설계, 코드 구조 결정

---

#### 205. Ai 기반 Event Storming

**설명**: 경계 컨텍스트 내의 도메인 특화 이벤트를 식별. 각 이벤트에 대해 이름, 설명, 도메인 컨텍스트 정의

**적용 조건**: 이벤트 주도 아키텍처 설계, 비즈니스 프로세스 분석

---

#### 206. Ddd 전문가 페르소나 활용

**설명**: 모든 프롬프트에서 "Eric Evans의 도메인 주도 설계(DDD) 전문성을 갖춘 소프트웨어 아키텍트로서"라는 역할 부여

**적용 조건**: 전문적인 분석이나 설계 결과물이 필요할 때

---

#### 207. Ai 초안 + 전문가 검토 협업

**설명**: AI가 생성한 초안(용어집, 도메인 모델, 컨텍스트 맵 등)을 전문가가 검토, 도전, 정제하는 협업 워크플로우

**적용 조건**: 복잡한 설계 작업, 시간이 제한된 상황

---

#### 208. 반복 질문 비교 기법 (Multiple Query Comparison)

**설명**: 같은 질문을 여러 번, 표현을 다르게 바꿔가며 물어보고 답변들을 비교. LLM의 비결정론적 특성 활용

**적용 조건**: 중요한 의사결정, 정확한 정보 필요, LLM 답변의 신뢰성 검증

---

#### 209. Llm 자기 비교 요청 (Self-Comparison Request)

**설명**: 여러 번의 질문을 통해 얻은 답변들을 LLM 자체에게 비교 분석하도록 요청

**적용 조건**: 복잡한 주제에 대한 다양한 관점 종합, 모순되는 답변 정리

---

#### 210. Spec As Context

**설명**: 사양과 프롬프트를 통합된 개념으로 사용. 사양 자체가 구조화된 프롬프트의 일부로 기능

**적용 조건**: 복잡한 기능 구현 시 기존 사양 문서, 테스트 케이스, 인터페이스 정의를 컨텍스트로 제공

---

#### 211. Questionansweradvisor 자동 프롬프트 증강

**설명**: 사용자 질문에 검색된 관련 문서를 자동으로 컨텍스트로 추가. "Given the context and provided history information, and not prior knowledge"

**적용 조건**: LLM이 제공된 데이터에만 기반하여 정확한 답변을 해야 할 때, 환각 방지

---

#### 212. Dspy 모듈 기반 Ai 개발

**설명**: 프롬프트 문자열 대신 입출력 동작을 시그니처로 정의하고 모듈로 추상화. `dspy.ChainOfThought("question -> answer: float")`와 같이 선언적 정의

**적용 조건**: 복잡한 AI 시스템 구축, 여러 LLM 호출 조합, 유지보수 가능한 AI 코드 필요 시

---

#### 213. Bootstraprs 최적화

**설명**: `dspy.BootstrapRS`로 각 모듈에 효과적인 few-shot 예제를 자동 합성

**적용 조건**: few-shot 프롬프팅 성능 향상, 수동 예제 작성 노력 절감

---

#### 214. Miprov2 프롬프트 최적화

**설명**: `dspy.MIPROv2`로 각 프롬프트에 더 나은 자연어 지시문을 자동 제안 및 탐색

**적용 조건**: 프롬프트 성능 체계적 개선, A/B 테스트 없이 최적 프롬프트 탐색

---

#### 215. Dspy Rag 모듈 구현

**설명**: `dspy.Predict("context, question -> answer")`로 RAG 패턴 모듈화. ColBERTv2 등 검색 도구와 연동

**적용 조건**: 문서 기반 질의응답, 지식베이스 검색, 컨텍스트 기반 답변 생성

---

#### 216. 설계 문서 컨텍스트 프롬프팅

**설명**: Markdown 설계 문서 전체를 AI에게 컨텍스트로 제공하고 명시적 요구사항 기반 코드 생성 유도

**적용 조건**: 설계 문서에 정의된 비즈니스 규칙을 정확히 반영한 코드 생성

---

#### 217. Cursor Rules를 통한 Ai 코딩 어시스턴트 커스터마이징

**설명**: 프로젝트별 cursor rules 파일을 생성하여 Cursor AI 에디터의 동작을 프로젝트 컨텍스트에 맞게 커스터마이징

**적용 조건**: Cursor AI 에디터에서 일관된 코드 스타일과 프로젝트별 규칙 전달

---

#### 218. Prd 기반 태스크 관리

**설명**: PRD 템플릿을 활용하여 AI가 태스크를 자동으로 분해하고 관리

**적용 조건**: 복잡한 프로젝트를 AI와 협업하여 체계적으로 분해하고 관리

---

#### 219. Intermittent Reinforcement Awareness

**설명**: AI 코딩의 슬롯머신 같은 특성 인식. "한 번만 더 프롬프트를"이라는 충동 인식하고 적절한 휴식

**적용 조건**: AI 코딩에 과도하게 몰입하는 것 방지, 건강한 작업 패턴 유지

---

#### 220. Feedback Loop Iteration

**설명**: AI 생성 코드가 불완전할 경우, 오류 메시지와 컨텍스트를 AI에게 피드백으로 제공하여 반복 개선

**적용 조건**: AI가 첫 번째 시도에서 완벽한 코드 생성하지 못할 때, 복잡한 로직이나 특수 요구사항

---

#### 221. Context File Provisioning

**설명**: AI가 사용자 정의 코드나 덜 알려진 의존성을 참조해야 할 때, 관련 컨텍스트 파일 함께 제공

**적용 조건**: 커스텀 클래스, 내부 라이브러리, AI가 학습하지 않았을 수 있는 의존성 사용 시

---

#### 222. Ask Vs Code 모드 구분

**설명**: 코드베이스 이해가 필요할 때는 'ASK' 모드로 질문하고, 실제 코드 생성이 필요할 때는 'CODE' 모드를 사용하여 AI 에이전트의 동작을 명확히 구분

---

#### 223. 로그 배치 처리를 통한 Ai 입력 최적화

**설명**: 20개 로그를 모으거나 300ms 간격으로 배치 전송하여 AI가 처리하기 적합한 단위로 정보 제공. AI의 컨텍스트 윈도우를 효율적으로 활용

---

#### 224. 오버라이드 템플릿 거버넌스

**설명**: "위험 수용 + 완화책 + 만료일 + 승인자"를 명시한 구조화된 오버라이드 템플릿으로 Staff/EM이 AI 게이트를 투명하게 우회할 수 있도록 하여 유연성과 책임성 균형

---

#### 225. 도메인 언어 사용

**설명**: 프로젝트의 도메인 언어를 사용하여 질문하면 더 정확한 결과를 얻을 수 있음

---

#### 226. 점진적 탐색 (Top-Down Exploration)

**설명**: 넓은 범위의 질문으로 시작한 다음 특정 영역으로 좁혀가는 방식으로 코드베이스 이해

---

#### 227. 메모리 시스템 (Claude.Md)

**설명**: 프로젝트 메모리(팀 공유), 로컬 메모리(개인 프로젝트별), 사용자 메모리(전역 개인)의 3가지 계층으로 컨텍스트 관리

---

#### 228. 토큰 효율적 컨텍스트 관리

**설명**: 세션 시작 시 각 스킬의 짧은 설명(frontmatter YAML)만 로드하여 수십 개 토큰만 사용하고, 실제 필요할 때만 전체 내용을 불러와 컨텍스트 오염(context pollution) 문제 해결

---

#### 229. 코드베이스 질문 우선 접근

**설명**: Claude Code 사용 시 코드 작성보다 코드베이스에 대한 질문("이 함수가 왜 이렇게 설계되었나요?", "새로운 로거를 추가하려면?")부터 시작하여 에이전트와 친숙해진 후 코딩 시작

---

#### 230. 브라우저-터미널 컨텍스트 브릿징

**설명**: AI가 클라이언트 측 상태를 파악할 수 있도록 로그 스트리밍

---

#### 231. 프로젝트 범위 메모리 격리 (Project-Scoped Memory Isolation)

**설명**: 각 프로젝트마다 독립적인 AI 메모리 공간을 생성하여 컨텍스트 교차 오염을 방지. 클라이언트 작업, 개인 프로젝트, 연구 등을 별도로 관리하며, 각 프로젝트의 기술 스택, 코딩 표준, 아키텍처 결정이 독립적으로 유지.

**적용 조건**: 여러 클라이언트 프로젝트를 동시에 관리하는 프리랜서, 다양한 기술 스택을 사용하는 팀

---

#### 232. 메모리 시딩 (Memory Seeding)

**설명**: 새 프로젝트 시작 시 기술 스택, 코딩 표준, 클라이언트 선호도, 아키텍처 패턴 등을 명시적으로 문서화하여 AI에게 프로젝트 컨텍스트를 일괄 주입.

**적용 조건**: 신규 프로젝트 킥오프, 새로운 팀원 온보딩, AI 페어 프로그래밍 세션 시작

---

#### 233. 구조화된 메모리 추가 (Structured Memory Additions)

**설명**: 복잡한 컨텍스트를 구조화된 형식으로 명시적으로 기록. 클라이언트 선호도, 코드 리뷰 표준 등.

**적용 조건**: 팀 협업 규칙 정의, 코드 리뷰 표준 일관성 유지

---

#### 234. Dynamic Tool Loading Strategy

**설명**: 모든 툴 정의를 컨텍스트에 미리 로드하는 대신, 실제로 필요한 툴만 동적으로 로드.

**적용 조건**: 수십 개 이상의 MCP 툴을 관리하는 환경, 토큰 비용 절감

---

#### 235. Code-Based Agent Control Flow

**설명**: 프롬프트 체인 대신 코드로 루프, 조건문, 에러 처리 등의 제어 흐름을 표현.

**적용 조건**: 복잡한 조건 분기가 필요한 에이전트 워크플로우

---

#### 236. Context-External Data Processing

**설명**: 중간 데이터를 모델 컨텍스트에 포함시키지 않고 코드 실행 환경에서만 처리하여 프라이버시 보호.

**적용 조건**: 개인정보나 민감한 비즈니스 데이터 처리

---

#### 237. 컨텍스트 기반 질문 추천 시스템

**설명**: 처리된 콘텐츠를 분석하여 카테고리별 의미 있는 질문을 추천.

**적용 조건**: 학습 가이드, 지식 탐색, FAQ 자동 생성

---

#### 238. `@` 기호를 통한 특정 파일 참조

**설명**: AI에게 질문할 때 `@` 기호로 특정 파일을 명시적으로 지정.

**적용 조건**: 대규모 코드베이스에서 특정 파일에 대한 질문

---

#### 239. 마크다운 기반 커스텀 명령어 생성

**설명**: `.opencode/command/` 디렉토리에 마크다운 파일로 재사용 가능한 AI 명령어 템플릿화. `$arguments` 사용.

**적용 조건**: 반복적인 코드 생성 작업, 팀 전체 일관된 코드 패턴

---

#### 240. Context-Driven Ai Guidance

**설명**: 모호한 프롬프트 대신 명확한 컨텍스트(명세, 계획, 작업 정의)를 제공하여 AI의 패턴 완성 능력 최대화.

**적용 조건**: AI에게 복잡한 기능 구현을 요청할 때

---

#### 241. Ai 대화형 명세 정제

**설명**: 모호한 아이디어를 AI와의 반복적 대화를 통해 포괄적인 PRD로 발전. AI가 명확화 질문 제시, 엣지 케이스 식별.

**적용 조건**: 요구사항이 불명확할 때, PRD 작성 시

---

#### 242. 증거 기반 개발 원칙

**설명**: AI가 절대적 표현을 금지하고 확률적 언어 사용. Context7 도구로 공식 문서 조회하는 "연구 우선" 정책.

**적용 조건**: AI의 추측 기반 코드 생성 방지, 정확한 개발

---

#### 243. 토큰 경제 최적화 (Ultra-Compressed Mode)

**설명**: 기호 언어, 약어, 글머리 기호로 토큰 사용량 70%까지 감소. 컨텍스트 증가 시 자동 활성화.

**적용 조건**: 대규모 코드베이스 분석, API 호출 비용 최적화

---

#### 244. 전문화된 역할 기반 Ai 활성화 (9가지 페르소나)

**설명**: 아키텍트, 프론트엔드/백엔드 개발자, 보안 전문가 등 9가지 전문 페르소나 정의. 컨텍스트 기반 자동 전환.

**적용 조건**: 작업 성격에 따라 AI의 사고방식과 접근법을 전환

---

#### 245. 컨텍스트 기반 자동 역할 전환

**설명**: 파일 확장자, 키워드 감지로 자동 페르소나 활성화. .tsx → frontend, "버그" → analyzer.

**적용 조건**: 다양한 파일 타입과 작업을 오가며 개발할 때

---

#### 246. Mcp Context Enhancement

**설명**: `--c7` (공식 문서), `--seq` (복잡한 분석), `--magic` (UI 생성), `--play` (브라우저 자동화) 플래그.

**적용 조건**: 최신 라이브러리 문서 참조, 특수 기능 필요 시

---

#### 247. Deep Project Context Loading

**설명**: `/load --deep --summary` 명령으로 프로젝트 전체 구조, 의존성, 아키텍처 패턴 종합 이해.

**적용 조건**: 새로운 코드베이스 참여, 전체적인 리팩토링 전 현황 파악

---

#### 248. Token-Efficient Configuration With @Include Template System

**설명**: @include 참조 시스템과 YAML 템플릿으로 설정을 모듈화하고 UltraCompressed 모드로 토큰 절감.

**적용 조건**: 대규모 코드베이스, 긴 컨텍스트 작업에서 토큰 비용 절감

---

#### 249. Git Checkpoint Support For Safe Ai-Assisted Experimentation

**설명**: AI와 실험적 작업 시 Git 체크포인트로 컨텍스트 보존, 롤백 용이.

**적용 조건**: AI가 제안한 대규모 리팩토링을 안전하게 시도

---

#### 250. Project Context Loading For Consistent Ai Assistance

**설명**: `/load` 명령어로 프로젝트 컨텍스트를 한 번에 로딩하여 AI가 프로젝트 특성 이해.

**적용 조건**: 새 세션 시작, 팀 내 코딩 컨벤션 전달

---

#### 251. 개인화된 Ai 자동화

**설명**: 일상 생활 자동화, 컨텍스트 파일 설정 (265)

---

#### 252. "무엇"과 "왜" 중심의 명세서 작성

**설명**: AI에게 기술적 세부사항 대신 사용자 관점의 목적과 이유를 설명하는 명세서를 작성합니다. 컨텍스트가 더 나은 AI 결정을 이끕니다.

---

#### 253. 계획 문서 중심 접근법 (Plan Document-Centric Approach)

**설명**: AI 코딩 도구와 작업할 때 대화가 아닌 계획 문서를 "진실의 소스(source of truth)"로 만드는 방법입니다. 대화 기반 접근법의 컨텍스트 손실 문제를 해결합니다.

---

#### 254. 컨텍스트 갱신 기법 (Context Refresh Technique)

**설명**: 대화가 길어져 컨텍스트 제한에 도달하면, 계획 문서만을 컨텍스트로 새로운 대화를 시작하여 작업을 이어갑니다.

---

#### 255. 예제 참조 기법 (Example Reference Technique)

**설명**: 새로운 기능의 계획 문서를 작성할 때 공식적인 템플릿 대신 이전에 구현된 기능들의 기존 계획들을 참조하도록 합니다.

---

#### 256. 개인 컨텍스트 파일 설정 (About Me File)

**설명**: Claude Code가 효과적으로 작동하려면 사용자에 대한 맥락 정보가 필요합니다. 자신이 누구인지, 관심사, 콘텐츠 링크 등을 담은 markdown 파일을 생성합니다.

---

#### 257. 일일 저널링 Ai 에이전트 (Daily Journal)

**설명**: `/daily-checkin` 명령으로 AI가 질문을 통해 일일 저널 항목을 자동 생성합니다.

---

#### 258. 온톨로지 기반 자연어 쿼리 시스템

**설명**: 온톨로지(Ontology) 기반 검색 환경을 구축하여 자연어 질문으로 복잡한 데이터를 조회하고 시각화할 수 있게 함.

---

#### 259. Clarification Questions(명확화 질문) 프로세스

**설명**: AI와 대화할 때 "질문이 있으면 명확화를 위해 질문하고, 이후 요청을 진행하라"는 프롬프트를 추가하여 AI가 요구사항을 제대로 이해했는지 확인하는 방법입니다.

---

#### 260. Memory Mode를 통한 컨텍스트 유지

**설명**: 프로젝트별 또는 전역 메모리를 저장하여 AI가 프로젝트 컨텍스트를 지속적으로 유지하도록 합니다.

---

#### 261. 기술 명세 기반 프롬프트 작성

**설명**: AI에게 코드 생성을 요청할 때, 언어, 함수명, 파라미터명, 반환값 사양, 테스트 케이스 요구사항 등 구체적인 기술 명세를 프롬프트에 포함시킵니다.

---

#### 262. 프롬프트를 통한 설계 문서화

**설명**: AI 코드 생성에서 프롬프트는 단순한 명령이 아니라 개발자의 사고 과정과 설계를 문서화하는 역할을 합니다.

---

#### 263. Claude.Md를 통한 바이브코딩 환경 구성

**설명**: 프로젝트 루트에 CLAUDE.md 파일을 작성하여 Claude Code가 코드베이스를 이해하고 효율적으로 작업할 수 있는 컨텍스트를 제공합니다.

---

#### 264. 로직 버그 및 엣지 케이스 실패 테스트 프롬프트

**설명**: AI에게 "이 코드가 오작동할 때 실패하는 단위 테스트를 작성하라"고 요청하여 잠재적 버그를 사전에 발견합니다.

---

#### 265. Null/경계값 테스트 프롬프트

**설명**: AI가 생성한 코드에 대해 null 값, 빈 문자열, 경계 숫자를 전달하는 테스트를 작성하도록 요청합니다.

---

#### 266. 부작용(Side Effects) 검증 테스트 프롬프트

**설명**: AI 생성 메서드가 입력 인자를 변경하거나 정적 상태를 수정하는 부작용이 있는지 확인하는 테스트를 작성하도록 요청합니다.

---

#### 267. 회귀 테스트 및 구현 변경 영향 분석 프롬프트

**설명**: "나중에 구현을 변경하면 무엇이 깨질까요?"라고 AI에게 질문하여 유지보수자 관점에서 사고하도록 강제합니다.

---

#### 268. 동시성/부하 테스트 프롬프트

**설명**: AI에게 멀티스레드 또는 부하 테스트를 작성하여 경쟁 조건이나 성능 병목을 식별하도록 요청합니다.

---

#### 269. 테스트 주도 프롬프트(Test-Driven Prompts) 패턴

**설명**: AI가 스스로 자신의 출력물을 검증하고 도전하도록 테스트 작성을 요청하는 워크플로우입니다.

---

#### 270. Ai 코드 검증 체크리스트 도입

**설명**: 6가지 테스트 주도 프롬프트를 팀 전체의 표준 실천 사항으로 도입합니다.

---

#### 271. 요구사항 도출 질문 기법

**설명**: AI에게 "요건 정의에 필요한 질문들을 알려줘"라고 요청하여 AI가 스스로 필요한 정보를 파악하고 질문하도록 유도하는 기법.

---

#### 272. Ai 기반 맥락적 학습

**설명**: 새로운 기술, 라이브러리, 프레임워크를 학습할 때 AI에게 질문하여 빠르게 습득.

---

### Agent & Workflow (187개)

#### 1. Human-In-The-Loop 확인 패턴

**설명**: AI 에이전트가 자율적으로 동작하면서도 중요한 결정 지점에서 `WaitFor.formSubmission()` 메서드를 사용하여 사람의 확인을 받는 패턴이다. 에이전트가 프로세스를 일시 중지하고 Human 응답을 기다린 후 재개할 수 있다.

**적용 조건**: 주문 확인, 승인 워크플로우, 위험한 작업 실행 전 확인이 필요한 경우

*출처: 9개 문서*

---

#### 2. 자율적 에이전트 오케스트레이션

**설명**: 여러 AI 에이전트를 동시에 조정하여 복잡한 워크플로우를 병렬로 처리. 최대 10개 에이전트를 동시 실행하며 지능적 작업 분산 및 로드 밸런싱 수행

*출처: 5개 문서*

---

#### 3. 투명한 변경 추적

**설명**: AI가 생성한 모든 파일과 코드 변경을 인터페이스에서 실시간으로 확인하고, 필요에 따라 개별 변경 사항을 승인하거나 거부할 수 있는 워크플로우 활용

*출처: 4개 문서*

---

#### 4. Sdd 워크플로우

**설명**: 자연어 명세서를 작성하면 AI가 실제 작동하는 코드를 자동 생성. 명세→구현 계획→코드 생성. 12시간 → 15분으로 단축.

**적용 조건**: 뉴스레터 작성, 여행 일정 계획, 이메일-캘린더-노션 통합 등

*출처: 4개 문서*

---

#### 5. Claude.Md를 통한 프로젝트 Dna 정의

**설명**: 아키텍처, 스타일 가이드, 보안 필수통과 조건, 수용 체크리스트를 단일 `CLAUDE.md` 파일에 정의하여 AI 에이전트에게 프로젝트 맥락을 제공하고, "좋은 것 vs 나쁜 것" 예시로 지속 업데이트

*출처: 3개 문서*

---

#### 6. 컨텍스트 기반 지침 활용

**설명**: 'agent.md' 파일에서 제공된 지침을 참조하여 에이전트가 코드베이스 규칙 이해.

**적용 조건**: 특정 문서 기반 Q&A 시스템

*출처: 3개 문서*

---

#### 7. 파이프라인 통합

**설명**: `cat file | claude -p "query"` 형태로 Unix 파이프라인에 Claude를 통합하여 자동화된 워크플로우 구축

*출처: 3개 문서*

---

#### 8. 권한 스킵 모드

**설명**: `--dangerously-skip-permissions` 플래그로 권한 확인을 건너뛰어 자동화된 워크플로우 실행

**관련 도구**: Cursor AI

*출처: 2개 문서*

---

#### 9. 에이전트 생태계

**설명**: Sub-agents, Slash-commands, MCP 서버 연동으로 전문화된 작업 분담

*출처: 2개 문서*

---

#### 10. 80/20 규칙

**설명**: 일상 작업은 Slash-commands, 복잡한 작업만 Sub-agents

*출처: 2개 문서*

---

#### 11. 서브 에이전트 (Sub-Agents) 활용

**설명**: 병렬 작업을 분리하여 처리하고, 공유 목표를 향해 작업하는 여러 에이전트를 조정

*출처: 2개 문서*

---

#### 12. Ai 의존성 승인 워크플로우

**설명**: AI가 새로운 패키지나 라이브러리를 추가할 때 자동으로 승인된 의존성 목록과 대조하는 워크플로우를 구축합니다.

**적용 조건**: 콘텐츠 제작 시간을 절약하면서 개인적 톤을 유지하고 싶을 때

*출처: 2개 문서*

---

#### 13. Ai 코드에 대한 자동화된 품질 검사

**설명**: SonarQube나 Codescene 같은 도구를 설정하여 코드 냄새에 대해 경고받습니다.

**적용 조건**: AI 어시스턴트를 팀 전체에서 사용하기 시작할 때

*출처: 2개 문서*

---

#### 14. 원문 병렬 표기

**설명**: 기술용어가 처음 나타날 때 "용어 (원문표현)" 형식으로 괄호 안에 영문을 병기합니다.

**적용 조건**: 원격 직무 면접 준비 시

*출처: 2개 문서*

---

#### 15. 규제 환경 대응

**설명**: 에이전트를 stateless로 유지하고, 리뷰 아티팩트(발견사항 + 수용 근거)를 감사용으로 보존하며, 도메인 규칙(PHI, PII, 데이터 거주)을 `CLAUDE.md`에 명시하여 GDPR/HIPAA 등 규제 준수

*출처: 2개 문서*

---

#### 16. Plans.Md 기반 Task 분해 워크플로우

**설명**: AI에게 plans.md 파일을 먼저 생성하게 하고, 이를 기반으로 task.md를 만드는 계획 중심 접근법

**적용 조건**: 복잡한 기능 구현이나 프로젝트 작업 시 체계적인 계획과 실행이 필요한 경우

**예시**: "Please create a new branch for that, and write your recommended steps to a file called plans.md"

---

#### 17. Ask 모드 → Agent 모드 워크플로우

**설명**: 먼저 Ask 모드로 정보를 수집하고, 이 산출물로 프롬프트를 만들어서 Agent 모드에서 실행

**관련 도구**: Cursor (Ask 모드, Agent 모드)

---

#### 18. 반복 업무의 재사용 가능한 함수화

**설명**: LLM을 통해 작업하는 워크플로우를 함수 호출처럼 추상화하여 반복되는 업무에 재사용

**관련 도구**: Claude Code Slash Commands

---

#### 19. Claude.Md/Agents.Md 지속적 업데이트 기법

**설명**: `/init` 후 그대로 두지 않고, 새로운 기능 추가 시마다 AI가 읽는 문서를 수정

**관련 도구**: Claude Code, IDE

---

#### 20. 병렬 처리를 위한 이슈 자동 생성 기법

**설명**: 문서화를 잘 하고 이슈의 parent-sub 관계를 명확히 설정한 후 자동으로 이슈 생성

**예시**: 보통 20-30개의 이슈를 한 번에 생성

---

#### 21. 에이전틱 검색 (Agentic Search)

**설명**: 인덱싱이나 RAG 없이 glob, grep, find 같은 도구로 코드베이스를 인간처럼 탐색

**관련 도구**: Claude Code

**적용 조건**: 새로운 코드베이스 온보딩 시

---

#### 22. Ai 에이전트의 3요소 구성 (두뇌-기억력-툴)

**설명**: n8n에서 AI 에이전트는 두뇌(챗 모델), 기억력(메모리), 툴(손, 발 역할)의 세 가지 요소로 구성

**관련 도구**: n8n, OpenAI API

---

#### 23. Ai 체인 Vs Ai 에이전트 선택

**설명**: 업무 순서가 예측 가능하면 AI 체인(안정적), 다양한 요청에 유연하게 대처해야 하면 AI 에이전트(유연함)

**관련 도구**: n8n

**적용 조건**: 자동화 워크플로우 설계 시

---

#### 24. 주문형 인텔리전스 (Intelligence On Tap)

**설명**: AI와 에이전트를 통해 역량 격차(capacity gap)를 해소하고 즉시 사용 가능한 지식과 역량 확보

**적용 조건**: 조직의 AI 전략 수립 시

**예시**: Wells Fargo는 35,000명 은행원을 위한 에이전트로 쿼리 응답 시간을 10분→30초로 단축

---

#### 25. 인간-에이전트 비율 최적화

**설명**: 너무 적은 에이전트는 효율성 손실, 너무 많은 에이전트는 판단력 압도. 최적 균형점 찾기

**적용 조건**: 에이전트 도입 시

---

#### 26. 에이전트 보스 (Agent Boss) 역할

**설명**: 모든 직원이 에이전트를 구축, 위임, 관리하며 자신의 영향력을 증폭시키는 역할 수행

**적용 조건**: AI 시대 개인 역량 개발

---

#### 27. Git 워크플로우 자연어 변환

**설명**: 복잡한 Git 시나리오를 자연어로 설명하면 단계별 Git 명령어 생성

**관련 도구**: ChatGPT, Claude

---

#### 28. 컨테이너 관리 자동화 (Docker-Mcp)

**설명**: 컨테이너 관리, 로그 검색, 배포 작업 자동화

---

#### 29. 오피스 문서 자동화 (Powerpoint/Excel-Mcp)

**설명**: 프레젠테이션 요점 추출, 스프레드시트 분석

---

#### 30. 프로젝트 관리 자동화 (Jira-Mcp)

**설명**: 이슈 검색, 진행 추적, 티켓 생성

---

#### 31. Proactively 키워드 활용

**설명**: 서브에이전트 자동 활성화 시점 지시

---

#### 32. 도메인별 전문가 에이전트 분리

**설명**: Frontend, Backend, API, Mobile 등 영역별 분리

---

#### 33. 언어/프레임워크 특화 에이전트

**설명**: Python, JavaScript, iOS 등 특정 플랫폼 최적화

---

#### 34. 24/7 Ai 코딩 워크포스 구축

**설명**: 여러 전문 서브에이전트 조합 AI 팀 구성

---

#### 35. Fine Tuning 10단계 워크플로우

**설명**: 체계적인 파인튜닝 파이프라인

---

#### 36. Gemini Mcp 에이전트 연동

**설명**: 디버깅, 브레인스토밍에 활용

---

#### 37. 효율성 분석 필수화 워크플로우

**설명**: AI 생성 알고리즘의 시간 복잡도 분석 및 Big-O 검토 필수화

---

#### 38. 백오피스 우선 Ai 자동화

**설명**: 내부 FAQ 챗봇 → 교육/해커톤 → 제품 AI 적용 순서

---

#### 39. 워크플로우 재설계 선행

**설명**: AI 도입 전 기존 업무 흐름 분석 및 구조화

---

#### 40. Configuration Over Code

**설명**: 에이전트 구성이 코드보다 중요

---

#### 41. Mixture Of Experts

**설명**: 하나의 AI가 모든 것을 하기보다 전문화된 에이전트 활용

---

#### 42. 커스텀 슬래시 명령어

**설명**: 반복되는 작업을 슬래시 명령어로 정의하여 재사용 가능한 워크플로우 자동화

---

#### 43. 명령어 인수 활용 ($Arguments)

**설명**: 슬래시 명령어에 `$ARGUMENTS` 변수를 사용하여 동적 파라미터를 받는 유연한 자동화 명령어 생성

---

#### 44. 자동화 시 숨겨진 요청 주의

**설명**: 스크립트나 API 통합을 통한 자동화 시, 숨겨진 요청이 증가하여 할당량을 빠르게 소모할 수 있으므로 주의

---

#### 45. Slash Command 활용

**설명**: `/do-commit`, `/organize`, `/wrap-up` 등 반복적인 작업을 자동화

---

#### 46. 체크포인트-커밋 워크플로우

**설명**: 체크포인트를 에어백으로, git 커밋을 안전벨트로 사용하는 이중 안전망 워크플로우

---

#### 47. Claude For Chrome Extension

**설명**: 브라우저에서 직접 Claude를 사용하여 웹 작업을 자동화하는 확장 프로그램

---

#### 48. Claude Agent Sdk 활용

**설명**: Claude Code를 구동하는 동일한 인프라를 사용하여 복잡한 에이전트를 구축할 수 있는 SDK

---

#### 49. 백그라운드 작업 유지

**설명**: 서버나 빌드 프로세스를 백그라운드에서 유지하면서 다른 작업을 병렬로 수행

---

#### 50. 플러그인 마켓플레이스 활용

**설명**: 단일 명령어로 커스텀 슬래시 커맨드, 특수 에이전트, MCP 서버를 설치

---

#### 51. 워크플로우 훅 자동화

**설명**: 특정 워크플로우 시점에 자동화된 액션을 트리거

---

#### 52. 인박스 정리 루틴 자동화

**설명**: 정기적인 인박스 정리 루틴을 확립하고 AI를 활용하여 새로운 자료를 적절한 카테고리로 분류

---

#### 53. Living Documentation 자동화

**설명**: 코드 변경과 함께 문서(다이어그램)가 자동으로 동기화되어 항상 최신 상태를 유지

---

#### 54. Ai 기반 코드 설명/문서화

**설명**: 기존 코드에 대한 설명을 AI에게 요청하여 학습하고, 문서화를 자동화합니다.

**예시**: "이 코드를 초보자도 이해할 수 있게 단계별로 설명해줘"

---

#### 55. 하이브리드 개발 워크플로우

**설명**: AI와 인간의 강점을 명확히 구분하여 역할을 분담합니다. AI는 반복적인 작업, 인간은 아키텍처 설계, 보안, 확장성 고려를 담당합니다.

**예시**: - AI: 테스트 코드 초안 작성, 리팩토링 제안, 문서화

---

#### 56. 목표-조건-행동 기반 에이전트 설계 (Goap)

**설명**: 에이전트를 Actions(행동), Goals(목표), Conditions(조건), Domain Model(도메인 모델), Plan(계획)의 다섯 가지 핵심 개념으로 구조화합니다.

**예시**: `@Agent` 클래스에 `@Goal`, `@Condition`, `@Action` 메서드를 정의하여 에이전트 흐름을 선언적으로 구성

---

#### 57. 어노테이션 기반 에이전트 구성

**설명**: Spring MVC와 유사한 어노테이션 기반 모델을 사용하여 에이전트 흐름을 정의합니다.

**예시**: ```kotlin

---

#### 58. 가드레일 주입 (Guardrails Injection)

**설명**: AI 에이전트 플로우의 어느 지점에서든 가드레일을 주입하여 안전성을 확보합니다.

**예시**: 에이전트가 DB 쓰기 작업 전 반드시 검증 단계를 거치도록 가드레일 삽입

---

#### 59. 설명 가능한 Ai (Explainable Ai)

**설명**: 에이전트가 문제를 해결할 때 왜 그런 선택이 이루어졌는지 설명할 수 있어야 합니다.

**예시**: 비즈니스 의사결정 에이전트에서 각 단계의 선택 이유를 로그로 기록

---

#### 60. 에이전트 연합 (Agent Federation)

**설명**: 대규모에서 플로우의 조합 가능성을 통해 에이전트 연합체를 구성합니다.

**예시**: 주문 처리, 고객 서비스, 재고 관리 에이전트가 각각 독립적으로 운영되면서 협력하는 연합 시스템

---

#### 61. 에이전트 플로우 실행 제어 및 복원력

**설명**: 에이전트 플로우의 실행을 관리하고 더 큰 복원력을 도입합니다. 실패 시 재시도, 폴백 전략, 상태 지속성 등을 통해 안정적 운영을 보장합니다.

**예시**: 외부 API 호출 실패 시 자동 재시도, 중간 상태 저장을 통한 장애 복구

---

#### 62. 선언적 에이전트 정의 (Annotation 기반)

**설명**: `@Agent`, `@Action`, `@AchievesGoal` 어노테이션을 통해 에이전트의 역할, 수행 가능한 액션, 최종 목표를 선언적으로 정의한다.

**적용 조건**: Java/Spring Boot 기반 AI 에이전트 개발 시

---

#### 63. 비동기 프로세스 재개 패턴 (Processid 활용)

**설명**: `processId`를 통해 일시 중지된 AI 에이전트 프로세스를 식별하고, Human 응답을 받은 후 프로세스를 비동기적으로 재개한다.

**적용 조건**: 장시간 대기가 필요한 승인 프로세스

---

#### 64. 에이전트 → Mcp 서버 지시 패턴

**설명**: MCP 서버가 호출자 에이전트에게 다음에 무엇을 해야 하는지 명시적으로 지시하는 응답을 반환한다.

**적용 조건**: 다중 에이전트 시스템에서 에이전트 간 조율

---

#### 65. 비동기 병렬 웹 크롤링

**설명**: asyncio.gather()를 사용하여 여러 URL을 동시에 크롤링합니다.

**적용 조건**: 대규모 문서 사이트 전체를 빠르게 수집해야 할 때

---

#### 66. 감독된 에이전트(Supervised Agents) 활용

**설명**: 에이전트가 파일 읽기/쓰기, 테스트 실행 등을 자동으로 수행하되, 개발자가 각 단계를 승인하는 방식입니다.

**적용 조건**: 반복적인 수정-테스트 사이클을 자동화하고 싶을 때

---

#### 67. Ai 제안 코드 충돌 해결 워크플로우

**설명**: AI가 제안한 코드와 기존 코드 간의 충돌을 Git 병합 충돌 방식으로 처리합니다.

**적용 조건**: AI가 제안한 코드 변경사항을 검토하고 선택적으로 적용할 때

---

#### 68. Graphiti

**설명**: 시간 인식 지식 그래프로 AI 에이전트에 장기 기억 부여

---

#### 69. 다중 에이전트 분할

**설명**: 요구사항 분석가 → 부트스트래퍼 → 백엔드 디자이너 등 역할 분리

---

#### 70. Lifecycle Hooks

**설명**: PreToolUse, PostToolUse, Notification 시점에 커스텀 셸 명령 실행

---

#### 71. @Agent 어노테이션을 통한 에이전트 선언

**설명**: 클래스에 `@Agent(name, description)` 어노테이션으로 에이전트 선언

---

#### 72. Interactive Shell 모드

**설명**: `@EnableAgentShell`로 대화형 CLI 활성화

---

#### 73. Goap 기반 자동 계획 수립

**설명**: 워크플로우 명시적 프로그래밍 없이 에이전트가 최적의 실행 경로 자동 결정

---

#### 74. Rule Files 설정

**설명**: 프로젝트별 규칙 파일로 에이전트가 코딩 컨벤션 준수하도록 설정

---

#### 75. 기술 스택 마이그레이션 자동화

**설명**: "Switch from Spring Data JPA to JdbcClient" 같은 간결한 명령으로 기존 코드베이스 기술 스택 변경

---

#### 76. 풀스택 애플리케이션 단계적 생성

**설명**: 백엔드(Spring Boot) → 프론트엔드(Angular) 순으로 점진적 개발 워크플로우

---

#### 77. 백오피스 Roi 우선 전략

**설명**: 세일즈/마케팅이 아닌 조달, 재무, 운영 등 백오피스 자동화에 우선 투자

---

#### 78. Jetbrains Ai 생태계

**설명**: AI Assistant, Junie, Claude Agent의 역할 분담과 guidelines.md를 통한 프로젝트별 가이드라인 설정

---

#### 79. Embabel Agent Framework

**설명**: Java/Spring 생태계에서 선언적 에이전트 개발

---

#### 80. Ai 도구 활용 영역 분류

**설명**: - 단위 테스트 작성, 문서화 지원, 코드 작성, 에이전트 워크플로우

---

#### 81. 도메인 객체 기반 에이전트 설계

**설명**: Java Record를 사용하여 도메인 모델을 정의하고, AI 에이전트의 입출력 타입으로 활용

---

#### 82. 상태 저장형(Stateful) 에이전트 패턴

**설명**: 장시간 실행되는 에이전트가 중간에 사용자 입력을 요청하고, 대기 상태로 전환 후 재개하는 HITL(Human-in-the-Loop) 패턴

---

#### 83. 어노테이션 기반 액션-목표 연결

**설명**: `@Action`, `@AchievesGoal`, `@Export` 어노테이션으로 선언적 에이전트 플로우 구성

---

#### 84. Processid 기반 에이전트 재개

**설명**: 대기 상태의 에이전트를 식별하여 재개하는 패턴

---

#### 85. 지침 파일을 통한 표준 정의

**설명**: 코드 표준, 프로젝트 구조 등을 외부 지침 파일에 정의하여 자동화.

---

#### 86. 블로그-팟캐스트 변환 워크플로우

**설명**: Generate 기능으로 음성 생성 후 Speechify/Descript로 편집하는 멀티포맷 재활용.

---

#### 87. 다중 모델 조합 워크플로우

**설명**: LM Studio + Nomic Embed 조합으로 정확도 향상.

---

#### 88. 작업 위임 및 비동기 처리 패턴

**설명**: 코드 탐색, 버그 수정 등을 AI 에이전트에 위임하고 나중에 결과 확인.

---

#### 89. 다중 병렬 작업 에이전트 아키텍처

**설명**: 원격 에이전트가 여러 작업을 동시에 병렬로 수행하는 인프라.

---

#### 90. Posix 명령어 기반 도구 연동

**설명**: grep, sed 등 표준 UNIX 명령어를 활용한 에이전트 기능.

---

#### 91. 로컬-클라우드 하이브리드 워크플로우

**설명**: 로컬 동기식(Codex CLI) + 클라우드 비동기식(Codex) 통합 개발 환경.

---

#### 92. "Explore → Plan → Code → Commit" 워크플로우

**설명**: 탐색 → 분석 → 계획 수립 → 구현의 단계적 접근.

---

#### 93. Agentic Workflow 패턴

**설명**: "먼저 도구로 검증, 모든 단계 완료 후 테스트 코드 생성" 순서 명시.

---

#### 94. 대상 사용자별 활용 전략

**설명**: 역할별(자동화 엔지니어 없는 팀/입문자/프론트엔드 등) 적용 방식 차별화.

---

#### 95. Gpt 챗봇 단계별 생성 워크플로우

**설명**: ChatGPT의 GPT 기능을 활용하여 커스텀 챗봇을 4단계로 생성 (Create → Instructions → Configure → Actions)

**적용 조건**: 특정 도메인이나 작업에 특화된 AI 챗봇이 필요할 때

---

#### 96. Gpt Actions - 외부 서비스 연동

**설명**: GPT를 Zapier, Google Sheets, API 등 외부 서비스와 연결하여 자동화 워크플로우 구축

**적용 조건**: 챗봇이 실제 업무 자동화(데이터 저장, 알림 전송 등)를 수행해야 할 때

---

#### 97. 단계별 워크플로우 지시 (Step-By-Step Workflow)

**설명**: 복잡한 작업을 단계별로 분해하고, 각 단계마다 피드백을 요청하도록 설정

**적용 조건**: 대규모 리팩터링이나 복잡한 코드 개선 작업 시

---

#### 98. 스트림 파이프라인 변환 (Stream Pipeline Transformation)

**설명**: 전통적인 for loop를 함수형 스타일의 stream pipeline으로 변환하도록 지시

**적용 조건**: Java 코드의 가독성과 함수형 프로그래밍 스타일 적용 시

---

#### 99. Ai 에이전트를 활용한 멀티 툴 통합 워크플로우

**설명**: LangChain/LangGraph를 사용하여 여러 도구(Asana, Google Drive, Chroma DB)를 하나의 AI 에이전트로 통합

**적용 조건**: 여러 SaaS 도구를 동시에 사용하는 프로젝트, 반복적인 멀티 플랫폼 작업 자동화

---

#### 100. Langchain/Langgraph

**설명**: 멀티 툴 에이전트 구축

---

#### 101. Least Privilege For Ai Agents (Ai 최소 권한 원칙)

**설명**: AI 에이전트에게 작업에 필요한 최소한의 권한만 부여. 기본적으로 읽기 전용 접근, 쓰기 권한은 명시적 승인 후에만 부여

**적용 조건**: AI 코딩 어시스턴트 초기 설정, 환경별 권한 설계

---

#### 102. Environment Separation (환경 분리)

**설명**: Dev/Staging/Prod 환경을 물리적/논리적으로 완전히 분리하고, AI 에이전트는 개발 환경에서만 자유롭게 작업하도록 제한

**적용 조건**: AI 코딩 도구 도입 시 인프라 설계

---

#### 103. Code Freeze Ai Lockout

**설명**: 시스템이 "code and action freeze" 상태일 때 AI 에이전트의 작업 권한을 완전히 차단하는 메커니즘

**적용 조건**: 배포 전 안정화 기간, 중요 시스템 점검 중, 장애 대응 시

---

#### 104. Ai + Xp 하이브리드 워크플로우

**설명**: AI가 코드 생성을 자동화할수록, 페어 프로그래밍, 지속적인 피드백, 작은 배치 배포 등 XP의 실천법을 결합하여 검증되지 않은 로직의 축적 방지

**적용 조건**: AI 코딩 도구를 팀에서 도입할 때, 코드 품질과 아키텍처 복잡성 관리

---

#### 105. 에이전틱 Ai 제약 조건 설정

**설명**: 여러 자율 에이전트가 코드를 생성, 정제, 출시하는 시스템에서는 명시적인 제약이 없으면 검증되지 않은 로직이 빠르게 쌓임. 의도적인 마찰과 제약 도입 필요

**적용 조건**: 자율 AI 에이전트를 개발 파이프라인에 도입할 때, 코드 리뷰 및 검증 게이트 설계

---

#### 106. Ai 아웃풋 피드백 루프 구축

**설명**: AI가 아웃풋을 가속화할수록 품질, 위험, 의도를 관리하기 위한 강한 피드백 루프 필요. 작은 배치, 지속적 통합, 자동화된 테스팅, 공유된 소유권 활용

**적용 조건**: AI 코드 생성 도구를 CI/CD 파이프라인에 통합할 때, TDD와 결합하여 AI 코드 품질 관리

---

#### 107. 코드 직접 편집 워크플로우 (Direct Code Editing Workflow)

**설명**: 단순한 자동 완성을 넘어서, LLM이 소스 코드 파일을 직접 읽고 편집할 수 있는 접근 방식 활용

**적용 조건**: 복잡한 리팩토링, 여러 파일에 걸친 변경, 코드베이스 이해가 필요한 작업

---

#### 108. React (Reasoning + Acting) 에이전트

**설명**: `dspy.ReAct` 모듈로 도구 사용이 가능한 AI 에이전트 구현. 추론하면서 외부 도구 활용

**적용 조건**: Wikipedia 검색, 데이터베이스 조회, 외부 API 연동이 필요한 복잡한 질의응답

---

#### 109. 구조화된 Markdown 스펙 기반 코드 생성

**설명**: 설계 문서를 구조화된 Markdown으로 작성하고, 특정 헤더(`## Class Summary`, `## Members`)를 자동화 훅으로 활용

**적용 조건**: 엔터프라이즈 Java 프로젝트에서 설계 문서와 코드 간 일관성 유지

---

#### 110. Claude.Md 표준 워크플로우 정의

**설명**: 프로젝트 루트에 claude.md 파일을 두고 AI가 따라야 할 표준 워크플로우를 정의 - 문제 분석 → 계획 작성(tasks/todo.md) → 사용자 확인 → 실행 → 리뷰 섹션 추가의 단계적 프로세스 적용

---

#### 111. 자연어 기반 Ai 작업 할당

**설명**: "*Claude, please take over task 33*"과 같은 자연어 명령으로 AI 에이전트에게 작업을 할당할 수 있어, 개발자-AI 간 협업을 자연스럽게 구현

---

#### 112. 에이전트 가이드라인 자동 생성

**설명**: 프로젝트 초기화 시 CLAUDE.md, AGENTS.md, GEMINI.md, Copilot 지침 파일을 자동 생성하여 AI 에이전트가 프로젝트 컨텍스트를 즉시 이해하도록 지원

---

#### 113. 백로그 특화 Claude Code 에이전트

**설명**: 향상된 작업 관리 기능을 제공하는 전용 AI 에이전트를 선택적으로 설치하여 AI 협업 품질 향상

---

#### 114. 인수 조건(Acceptance Criteria) 기반 작업 정의

**설명**: 각 작업에 명확한 인수 조건을 정의하여 AI 에이전트가 완료 기준을 명확히 이해하고 작업 수행

---

#### 115. Feedback-Driven Loops

**설명**: 반영(reflection) 에이전트와 비평(critique) 에이전트로부터 차분 및 비판적 피드백을 수신하여 코드 품질을 반복적으로 개선

---

#### 116. 에이전트 간 메모리 공유

**설명**: 모든 에이전트가 지속적인 지식 뱅크를 공유하고 세션 간 메모리를 유지하여, 좌표 시스템을 통해 20% 이상의 토큰 사용량 감소 달성

---

#### 117. 대화형 Repl 모드

**설명**: `claude-flow repl` 명령으로 대화형 모드에서 에이전트 생성, 작업 생성, 메모리 쿼리 등을 즉석에서 실행하며 실험적인 워크플로우 구축

---

#### 118. 실시간 에이전트 모니터링

**설명**: 라이브 대시보드를 통해 에이전트 상태, 진행 상황, 성능을 실시간으로 확인하며 복잡한 작업에서 2배 이상의 속도 향상 가능

---

#### 119. Markdown 기반 에이전트 지침 패턴

**설명**: 작업 수행 방법을 설명하는 Markdown 파일만 드롭하고, 안정성/효율성 향상이 필요한 경우에만 추가 스크립트를 포함하는 단순하고 효과적인 에이전트 구성 방법

---

#### 120. 범용 에이전트로서의 코딩 도구 활용

**설명**: Claude Code를 순수 코딩 도구가 아닌 컴퓨터로 달성할 수 있는 모든 작업을 자동화하는 범용 에이전트로 활용 (데이터 저널리즘, 데이터 시각화, 데이터 게시 등)

---

#### 121. 도메인별 에이전트 구축 패턴

**설명**: 특정 도메인(예: 데이터 저널리즘)에 필요한 데이터 소스 이해, 처리 라이브러리, 게시 방법, 스토리 발견 지침, 시각화 구축 방법을 Markdown 파일과 Python 스크립트 예제로 구성하여 전문화된 에이전트 구축

---

#### 122. 교육/온보딩 자동화

**설명**: 프로젝트 아키텍처, 코딩 규칙, 배포 프로세스를 Skills로 만들어 AI 에이전트가 신규 개발자에게 실시간으로 가이드하게 하는 방식

---

#### 123. 슬래시 명령어로 재사용 가능한 워크플로우 정의

**설명**: 마크다운 파일로 작성되는 커스텀 슬래시 명령어를 통해 반복적인 작업(예: 커밋)의 지침과 권한을 사전 정의하여 매번 허가받지 않고 효율적으로 수행

---

#### 124. 병렬 에이전트 실행 (Parallel Agent Execution)

**설명**: 10개의 병렬 에이전트를 각각 독립된 컨텍스트에서 실행하여 토큰 블리드(token bleed)나 메모리 오버랩 없이 순수한 스코프 실행을 달성. 기존 batchtool보다 깨끗하고 빠르며 유연함

---

#### 125. 중첩 워크플로우 (Nested Workflows)

**설명**: 각 에이전트가 자체적으로 batchtools나 서브프로세스를 생성할 수 있어 워크플로우를 중첩(nesting) 구성 가능. 이는 10개의 완전한 Claude 인스턴스를 동시에 실행하는 것과 동일한 효과

---

#### 126. 스텁 에이전트 패턴 (Stub Agent Pattern)

**설명**: 완전히 구축된 전용 에이전트(플래너, 테스터, 옵티마이저)와 최소한의 메타데이터만 가진 스텁(stub) 에이전트를 혼합 사용. 스텁은 활성화되기를 기다리는 잠재적 능력(latent capabilities)으로 작동

---

#### 127. 자동 에이전트 감지 메커니즘

**설명**: Claude Code가 많은 가이드 없이도 언제 어떤 에이전트를 사용해야 하는지 자동으로 감지. 명시적인 호출 없이도 상황에 맞는 에이전트가 활성화됨

---

#### 128. 스웜 레이어 아키텍처 (Swarm Layers)

**설명**: 64개의 에이전트를 4개의 역할 계층으로 매핑 - 계획(Planning), 조정(Coordination), 리뷰(Review), 최적화(Optimization). 단순 병렬 처리가 아닌 진정한 오케스트레이션 구현

---

#### 129. 공유 메모리 시스템 (Shared Memory)

**설명**: 에이전트 간 정보 공유를 위한 공유 메모리 내장. 독립적 실행과 협업 사이의 균형 유지

---

#### 130. 에이전트 상태 확인 (Agent Health Checks)

**설명**: 각 에이전트의 상태를 모니터링하는 health check 시스템 내장. 프로덕션 환경에서의 안정성 확보

---

#### 131. 추적성 (Traceability)

**설명**: 에이전트 실행 흐름을 추적할 수 있는 기능 내장. 디버깅과 시스템 동작 파악에 필수적

---

#### 132. Claude Code 에이전트 시스템 심화

**설명**: 서브에이전트, 스웜 레이어, 병렬 에이전트 실행 등 다층적 AI 오케스트레이션

---

#### 133. 작업 분해 및 병렬 처리

**설명**: 큰 작업을 작은 단위로 분해, 서브에이전트 도메인 분리, 병렬 처리로 효율성 향상

---

#### 134. Virtual Me Ai Agent Creation

**설명**: 개인의 SNS 활동 내역(YouTube, 블로그, GitHub 등)을 수집하여 자신의 지식과 스타일을 반영한 가상 AI 에이전트를 구축.

**적용 조건**: 개인 브랜딩, 지식 관리, 24/7 질문 응답

---

#### 135. Ai 워크플로우 캡슐화 및 재사용

**설명**: 복잡한 다단계 AI 작업을 하나의 slash command로 캡슐화하여 재사용 가능한 자동화 도구로 제작.

**적용 조건**: 동일한 패턴의 작업을 반복적으로 수행해야 할 때

---

#### 136. Plan Agent와 Build Agent 분리

**설명**: AI 에이전트를 계획 단계(Plan Agent)와 실행 단계(Build Agent)로 분리하여 운영. Tab 키로 전환.

**적용 조건**: AI가 코드를 변경하기 전에 계획을 검토하고 싶을 때

---

#### 137. `/Init` 명령을 통한 프로젝트 구조 분석

**설명**: 프로젝트 디렉토리에서 `/init` 실행하면 AI가 프로젝트를 분석하여 `agents.md` 파일 자동 생성.

**적용 조건**: 새로운 프로젝트에 AI 도구 도입, 코드베이스 컨벤션 학습

---

#### 138. Tmux 기반 Ai-개발환경 병렬 운영

**설명**: Tmux로 별도의 윈도우/페인에서 AI 에이전트를 실행하고, Neovim과 프로젝트 실행 환경을 다른 페인에 배치.

**적용 조건**: 터미널 기반 개발 환경을 선호할 때

---

#### 139. Spec Kit Cli-Driven Workflow

**설명**: `/specify`, `/plan`, `/tasks` 명령어로 코딩 에이전트를 조정. 각 명령어가 상세한 아티팩트로 변환.

**적용 조건**: 여러 코딩 에이전트와 일관된 워크플로우 유지

---

#### 140. Ai 기반 기술 조사 자동화

**설명**: AI 에이전트가 라이브러리 호환성, 성능 벤치마크, 보안 영향 등을 자동으로 조사하고 분석.

**적용 조건**: 기술 스택 선정, 라이브러리 선택의 근거

---

#### 141. 다중 구현 접근법 탐색

**설명**: 동일한 명세에서 다양한 최적화 목표(성능, 메모리, 보안)를 위한 여러 구현 접근법을 병렬로 생성 비교.

**적용 조건**: 기술 선택의 불확실성이 클 때, POC 단계

---

#### 142. 전문 에이전트 위임 및 병렬 처리 (/User:Spawn)

**설명**: 복잡한 작업을 전문 에이전트에게 위임하여 병렬 처리. frontend/backend 에이전트 협업.

**적용 조건**: 풀스택 개발, 여러 모듈을 독립적으로 병렬 개발

---

#### 143. 다단계 전문가 검토 프로세스

**설명**: architect → frontend/backend 병렬 → security/qa 검토 순서의 파이프라인 구성.

**적용 조건**: 새로운 기능 개발 시 전체 프로세스 체계적 진행

---

#### 144. 세션 인식 워크플로우 학습

**설명**: 단일 세션 내에서 개발자의 반복적인 워크플로우를 감지하고 자동화 제안.

**적용 조건**: 자주 반복되는 작업 패턴 자동화

---

#### 145. Prd-To-Workflow Pipeline

**설명**: `/workflow feature.md` 명령으로 PRD를 단계별 구현 계획으로 자동 변환.

**적용 조건**: 새로운 기능 개발 시 요구사항에서 구현까지 간극 해소

---

#### 146. Parallel Task Execution With Spawn Command

**설명**: `/spawn` 명령어로 여러 AI 작업을 병렬로 실행.

**적용 조건**: 여러 마이크로서비스 개발, 병렬 테스트 실행

---

#### 147. Ai 생성 Ui + Cli 통합 워크플로우

**설명**: v0로 UI를 생성한 후, shadcn CLI를 활용하여 생성된 컴포넌트를 단일 명령어로 코드베이스에 추가하는 통합 워크플로우입니다.

---

#### 148. Slash Command 기반 Ai 에이전트 실행

**설명**: `/weekly-checkin`, `/daily-checkin`, `/newsletter-researcher` 등의 slash command를 통해 미리 설정된 AI 에이전트를 즉시 실행할 수 있습니다.

---

#### 149. 주간 체크인 자동화 (Weekly Check-In)

**설명**: `/weekly-checkin` 명령을 실행하면 서브 에이전트가 YouTube 구독자, 비즈니스 지표, Twitter 팔로워 등 다양한 데이터를 자동 수집하여 개인 대시보드를 생성합니다.

---

#### 150. 경쟁사 콘텐츠 리서치 자동화

**설명**: `/newsletter-researcher` 명령으로 AI 에이전트가 모든 경쟁사 콘텐츠 히스토리를 검토하여 트렌드를 파악하고 콘텐츠 초안을 작성합니다.

---

#### 151. 일일 브리핑 자동 생성 (Daily Brief)

**설명**: `/daily brief` 명령으로 AI 에이전트가 지난 7일간의 관련 뉴스를 자동 수집하고 요약합니다.

---

#### 152. 서브 에이전트 활용 병렬 처리

**설명**: 복잡한 작업 시 Claude Code가 여러 서브 에이전트를 생성하여 다양한 지표를 동시에 수집하고 처리합니다.

---

#### 153. 단일 프롬프트 워크플로우 구축

**설명**: 복잡한 AI 에이전트 워크플로우를 단일 프롬프트로 설정할 수 있습니다. 초기 설정만 완료하면 이후에는 slash command만으로 모든 기능을 즉시 실행할 수 있습니다.

---

#### 154. Ai 에이전트 기반 개인화 쇼핑

**설명**: AI 에이전트가 사용자의 스타일, 구매 패턴, 선호도를 학습하여 맞춤형 제품 추천부터 자동 재주문, 업체 협상까지 대행하는 방식입니다.

---

#### 155. Ai 기반 자동 이력서 최적화 및 지원

**설명**: 구인구직 분야에서 AI가 각 회사의 Job Description을 분석하고, 사용자의 이력서를 맞춤 수정한 뒤 자동으로 지원까지 완료하는 워크플로우입니다.

---

#### 156. Ai 에이전트를 통한 검색-구매 프로세스 간소화

**설명**: 기존 쇼핑 프로세스(구글 검색 → 사이트 방문 → 제품 비교 → 결제)를 AI 에이전트가 대화 한 번으로 처리하는 방식입니다.

---

#### 157. Ai 에이전트 기반 여행 계획 및 예약 자동화

**설명**: AI가 동행자 구성에 따른 맞춤 여행 일정 작성, 현지 정보 제공, 예약, 예산 관리를 통합 지원하는 방식입니다.

---

#### 158. Ai 에이전트 기반 데이터 시각화

**설명**: 히트맵(Heatmap) 등을 활용하여 주문 위치별 빈도를 자동 시각화하는 에이전트 기능 구현.

---

#### 159. Ai 기반 업무 효율화 워크플로우

**설명**: 기획-조사-분석의 업무 단계에서 AI를 체계적으로 활용하는 워크플로우.

---

#### 160. Sub-Agents를 통한 병렬 작업 처리

**설명**: Task 도구를 통해 하위 에이전트를 생성하여 병렬 작업을 처리하는 기법.

---

#### 161. Hooks를 통한 자동화

**설명**: Claude Code의 특정 액션에 반응하여 자동으로 실행되는 스크립트를 정의합니다.

---

#### 162. 인지 부하 전환

**설명**: 구문 → 시스템 사고, 에이전트 조율자 역할 (275, 278)

---

#### 163. 평문 프롬프트를 통한 노코드 자동화 구축

**설명**: 프로그래밍 지식 없이 평문 영어로 복잡한 자동화 워크플로우를 설명하면 Claude Code가 이를 실행 가능한 JSON 워크플로우로 변환한다.

---

#### 164. Ai 에이전트 기반 다중 서비스 오케스트레이션

**설명**: Telegram 트리거, OpenAI 음성 변환, Google Calendar 등 여러 서비스를 AI 에이전트가 통합 조율하는 패턴.

---

#### 165. 음성 입력을 통한 Ai 자동화 트리거

**설명**: Telegram을 통해 음성 메모를 수신하고 OpenAI의 음성 인식으로 텍스트로 변환한 후 AI 에이전트가 처리하는 워크플로우.

---

#### 166. Vps 기반 24/7 Ai 에이전트 셀프 호스팅

**설명**: Hostinger VPS 등을 활용하여 n8n과 AI 에이전트를 자체 호스팅하는 방법.

---

#### 167. 접근성 트리 기반 브라우저 자동화

**설명**: Playwright MCP는 스크린샷 기반 시각적 해석 대신 브라우저의 접근성 트리를 활용하여 빠르고 안정적인 성능을 보장합니다.

---

#### 168. Claude Agent Sdk 기반 Ai 에이전트 개발

**설명**: Claude Agent SDK Typescript를 사용하여 목표 달성을 위해 최대 10번까지 멀티 턴 대화를 자동으로 수행하는 자율적 에이전트를 만들 수 있습니다.

---

#### 169. Sub-Agent 및 Slash Command 패턴

**설명**: github-issue-planner, github-issue-manager 등 특화된 서브에이전트를 구성하고, 슬래시 커맨드로 복잡한 워크플로우를 단일 명령으로 실행합니다.

---

#### 170. Github Issue 기반 Tdd 자동화

**설명**: GitHub 이슈를 생성하면 서브에이전트가 이슈와 코드베이스를 탐색한 후 TDD 방식으로 자동 개발합니다.

---

#### 171. Ai 에이전트 오케스트레이션 (Agent Orchestration)

**설명**: 개발자가 여러 AI 에이전트(DEVELOPER → REVIEWER → VERIFIER → GIT-MANAGER)를 조율하고 관리하는 워크플로우.

---

#### 172. 독립적 컨텍스트 윈도우 활용

**설명**: 각 AI 서브 에이전트에 별도의 컨텍스트 윈도우를 할당하여 컨텍스트 오염 없이 병렬 작업을 수행합니다.

---

#### 173. 에이전트 성격 설계 (Agent Personality Design)

**설명**: 각 AI 에이전트의 역할, 행동 방식, 품질 표준을 정의하는 "성격"을 설계합니다.

---

#### 174. 멀티 에이전트 품질 게이트 (Multi-Agent Quality Gates)

**설명**: QA를 전체 개발 "심포니"의 통합적 부분으로 운영합니다.

---

#### 175. 핸드오프 관리 (Handoff Management)

**설명**: 여러 AI 에이전트 간의 작업 전달을 설계하고 관리하는 기법.

---

#### 176. Ai 생성 콘텐츠 검증 워크플로우

**설명**: AI가 생성한 콘텐츠에 대해 모든 URL의 정확성을 수동으로 검증하는 human-in-the-loop 방식을 적용합니다.

---

#### 177. Mcp 서버를 활용한 반복 작업 자동화

**설명**: MCP 서버를 구축하여 반복적인 수작업을 자동화합니다.

---

#### 178. 기존 도구와 Ai의 결합 활용

**설명**: AI 도구는 기존 개발 워크플로우를 대체하는 것이 아니라 향상시키는 방식으로 활용합니다.

---

#### 179. Agent Swarm 오케스트레이션

**설명**: claude-flow를 사용하여 5개의 AI 에이전트가 병렬로 협업하며 서로 다른 역할을 분담합니다.

---

#### 180. Readme 기반 프로젝트 정의

**설명**: README.md 파일에 아이디어와 구현 개요를 먼저 작성하고, AI 에이전트가 분석하여 상세한 기술 구현 계획을 자동으로 생성합니다.

---

#### 181. 계획 우선 실행 (Plan-First Execution)

**설명**: AI 에이전트에게 먼저 /plans 디렉토리에 상세한 구현 계획을 작성하게 합니다.

---

#### 182. 에이전트 조율자(Orchestrator) 역할

**설명**: 개발자의 역할이 "코드 작성자"에서 "에이전트 조율자"로 전환됩니다.

---

#### 183. 적정 Ai 리소스 투자 전략

**설명**: 복잡한 AI 에이전트 프로젝트를 위해 충분한 API 크레딧과 높은 요금제가 필요합니다.

---

#### 184. 문서 기반 단계적 개발 워크플로우

**설명**: "요구사항 정의 → 설계 문서 → 체크리스트 → 실제 코딩"의 체계적인 프로세스를 따르는 AI 협업 개발 방식.

---

#### 185. Ai 90% 코드 생성 워크플로우

**설명**: AI가 코드의 대부분(90%)을 작성하고 개발자가 검토, 가이드 제공, 수정을 담당.

---

#### 186. 병렬 옵션 탐색 (Optionality)

**설명**: AI를 활용하여 다양한 구현 경로를 적은 비용으로 병렬로 탐색.

---

#### 187. 에이전틱 Ai Appsec 어시스턴트 도입

**설명**: 자율적 예방과 실시간 문제 해결을 수행하는 AI 에이전트를 AppSec 워크플로에 도입.

---

### Tools & Integration (179개)

#### 1. Mcp(Model Context Protocol) 기반 워크플로우 생성

**설명**: Claude Code와 MCP를 연동하여 n8n 워크플로우를 자동 생성하는 기법. MCP 도구를 통해 최신 문서를 참조하므로 직접 JSON 생성 대비 10배 더 신뢰할 수 있는 자동화를 생성할 수 있다.

**적용 조건**: Claude Code, Cursor 등 MCP 지원 AI 도구에서 프로젝트 특화 기능 활용

*출처: 8개 문서*

---

#### 2. 파일 구조 자동 생성

**설명**: Claude AI가 제안한 파일 구조를 Cursor AI에게 전달하여 디렉토리와 파일을 자동으로 생성합니다.

**적용 조건**: 원격 직무 지원 시

**예시**: "create a file structure as follows and create the files with boilerplate"

*출처: 5개 문서*

---

#### 3. Claude Code 도구 생태계

**설명**: claude-code-templates, Custom Commands, Skills, Hooks 등 Claude Code의 확장 기능을 체계적으로 활용

*출처: 5개 문서*

---

#### 4. Rag 기반 지식베이스 구축

**설명**: 프로젝트 관련 문서(에픽, 사용자 스토리, 비기능적 요구사항 등)를 RAG 시스템에 업로드하여 LLM과 통합

**적용 조건**: 새 프로젝트 온보딩, 복잡한 도메인 이해

*출처: 4개 문서*

---

#### 5. 다중 Ai 에이전트 지원

**설명**: Claude Code, Gemini, Codex, Jules 등 다양한 AI 도구와의 통합을 지원하여 프로젝트에 적합한 AI 선택 가능

**관련 도구**: Gmail, Google Calendar, Google Sheets, n8n

*출처: 2개 문서*

---

#### 6. 도구 선택 전략

**설명**: AI 도구의 강점/약점을 파악하여 적재적소에 활용 (V0 + Claude + Cursor 조합, Model Mixing)

*출처: 2개 문서*

---

#### 7. Guidelines.Md 파일 활용

**설명**: 프로젝트 루트에 가이드라인 파일로 기술 스택, 코딩 스타일, 아키텍처 패턴 정의

*출처: 2개 문서*

---

#### 8. Mcp 서버 토글 기능

**설명**: MCP 서버를 완전히 제거하지 않고 @-멘션으로 활성화/비활성화

**적용 조건**: 외부 MCP 서버를 도입할 때

*출처: 2개 문서*

---

#### 9. 하이브리드 지식 관리

**설명**: Co-pilot, Mistral, Pine Cone 등 다양한 도구를 개인정보 보호 수준에 따라 선택적 사용.

*출처: 2개 문서*

---

#### 10. Ai 도구 학습 곡선 관리

**설명**: 초기에는 AI가 생성한 코드를 수정하는 데 더 많은 시간이 소요될 수 있음을 인지합니다. 지속적인 학습과 적응을 통해 최적의 활용 방안을 모색합니다.

**적용 조건**: 조직 차원에서 AI 도구 도입 시

**예시**: 간단한 작업부터 AI 활용 시작, 점진적으로 복잡한 작업으로 확장

*출처: 2개 문서*

---

#### 11. Prd(Product Requirements Document) 기반 Ai 개발

**설명**: AI 코딩 도구(Bolt, Claude Code, Cursor 등)에게 명확한 PRD 문서를 제공하여 일관성 있고 품질 높은 코드를 생성하는 방법입니다.

*출처: 2개 문서*

---

#### 12. Ci/Cd 파이프라인에서의 Ai 작업 검증

**설명**: GitHub Actions 등 CI/CD 파이프라인에 Task Master를 통합하여 작업 유효성 검사를 자동화하는 기법입니다. `--strict` 모드로 엄격한 검증을 수행하여 품질을 보장합니다.

*출처: 2개 문서*

---

#### 13. Ai를 능력 증폭 도구로 활용

**설명**: - AI는 개발자의 판단력을 대체하지 않지만 능력을 증폭(amplify)

---

#### 14. 사이드 프로젝트 기반 Ai 역량 개발

**설명**: AI 도구를 활용한 사이드 프로젝트로 4가지 핵심 역량(오너십, 문제 정의, 소프트 스킬, AI 활용 능력) 개발

**관련 도구**: 무료 AI 도구들

**적용 조건**: 실무 경험이 없는 신입/주니어 개발자가 역량을 증명해야 할 때

---

#### 15. Ai 증강 개인 (Ai-Augmented Individual)

**설명**: AI 도구를 활용하여 개인의 역량을 극대화하는 방식 ("건담 슈트를 탄 개인")

**관련 도구**: GitHub Copilot, ChatGPT, Claude, Cursor AI

**예시**: 텔레그램 30명, 미드저니 40명, 커서 AI 20명으로 대규모 서비스 운영

---

#### 16. 필수 Mcp만 선별 연결 기법

**설명**: Claude Code 사용 시 진짜 필요한 MCP만 선별해서 연결

---

#### 17. Figma Mcp를 위한 파일 구조화 기법

**설명**: 코딩 에이전트가 Figma MCP를 효과적으로 사용할 수 있도록 Figma 파일을 구조화

**관련 도구**: Claude Code, Figma MCP

---

#### 18. 자율성 슬라이더 (Autonomy Slider) 활용

**설명**: AI에게 부여하는 자율성 수준을 작업에 따라 조절

**예시**: Ask → Tab → ⌘K → 단일 파일 → 다중 파일 → 완전 자율 주행

---

#### 19. 레거시 앱에서 Claude Code 워크플로우

**설명**: /init → GitHub 이슈 상세 작성 → 플랜 모드 → 구현 → 테스트 → 검수 → CLAUDE.md 업데이트

**관련 도구**: Claude Code, GitHub

---

#### 20. Serena Mcp로 토큰 효율화

**설명**: LLM이 코드를 심볼(함수, 클래스, 변수) 단위로 이해하게 하여 토큰 사용량 대폭 절감

**관련 도구**: Serena MCP, Claude Code

**예시**: 기존 8,000 토큰 → 500 토큰

---

#### 21. Think Hard 확장된 사고 기능

**설명**: 복잡한 작업 시 "think hard"를 추가하면 도구 호출 사이에도 사고 가능

**관련 도구**: Claude 4, Claude Code

**예시**: "can you figure out what is in this project. think hard"

---

#### 22. Ideal 문제 해결 프레임워크 프롬프팅

**설명**: Identify(식별), Define(정의), Explore(탐색), Act(실행), Look back(되돌아보기)의 5단계로 구조화

**관련 도구**: ChatGPT, Claude

---

#### 23. Vs Code 원활한 마이그레이션

**설명**: Cursor 설정 > 일반 > 계정에서 "VS Code에서 가져오기"로 설정 이전

**관련 도구**: Cursor AI

---

#### 24. Cursor Tab 예측 코딩

**설명**: Tab으로 수락, Esc로 거부, Ctrl/⌘ + →로 문자별 수락

**관련 도구**: Cursor AI

---

#### 25. 코드베이스 인덱싱 + .Cursorignore

**설명**: 코드베이스 인덱싱 활성화하고 .cursorignore로 불필요한 디렉토리 제외

**관련 도구**: Cursor AI

**예시**: dist/, *.log 등 제외

---

#### 26. .Cursorrules 커스텀 Ai 규칙

**설명**: 프로젝트 루트에 .cursorrules 파일로 팀 코딩 스타일, 언어 제약 등 설정

**관련 도구**: Cursor AI

**예시**: "Always use TypeScript", "Emphasize functional programming"

---

#### 27. 데이터 웨어하우스 연동 (Snowflake-Mcp)

**설명**: LLM이 Snowflake에서 직접 데이터를 쿼리하여 AI 기반 데이터 분석 수행

---

#### 28. 파일 시스템 접근 (Filesystem-Mcp)

**설명**: LLM에게 로컬/원격 파일 시스템 접근 권한 부여

---

#### 29. Github 리포지토리 자동화 (Github-Mcp)

**설명**: 코드 분석, PR 요약, 개발 워크플로우 자동화

---

#### 30. 노트북 기반 코드 실행 (Jupyter-Mcp)

**설명**: Jupyter 노트북에서 코드 실행 및 결과 분석

---

#### 31. 캘린더 및 협업 도구 연동 (Google Calendar/Slack-Mcp)

**설명**: 일정 관리, Slack 채널 요약

---

#### 32. 개인 생산성 Ai 통합

**설명**: 캘린더, 이메일, 여행 예약 등 도구 통합

---

#### 33. Mcp 서버 디렉터리 활용

**설명**: Awesome MCP, Smithery.ai, Mcp.so 등에서 서버 발견

---

#### 34. Magic Ui Mcp Ui 컴포넌트 통합

**설명**: 전문 디자인 템플릿 워크플로우 통합

---

#### 35. Claude-Code-Commands 도구 설치

**설명**: GitHub 도구로 기능 확장

---

#### 36. Cursor와 Claude Code 병행 사용

**설명**: 두 도구 상호보완 활용

---

#### 37. 7일 학습 곡선 투자

**설명**: 집중적인 도구 학습 기간 투자

---

#### 38. 통합 설정 파일 전략

**설명**: .cursorrules 등 분산 파일 대신 단일 AGENTS.md로 통합

---

#### 39. Ai 도구 표준화 가이드라인

**설명**: 팀 내 일관된 AI 출력을 위한 가이드라인 문서화

---

#### 40. 오픈소스 커뮤니티 활용 전략

**설명**: GitHub 등 오픈소스 생태계를 적극 활용하여 최신 AI 발전 흡수

---

#### 41. Ai 도구 직접 경험을 통한 감각 개발

**설명**: "가능한 것/불가능한 것/시간이 필요한 것" 감각을 직접 경험으로 개발

---

#### 42. Github Copilot 활용 코딩 자동화

**설명**: Copilot으로 일상적 코딩 작업의 50% 이상 시간 절약

---

#### 43. Ai 도구를 활용한 팀 규모 최적화

**설명**: 소규모 팀 + AI = 기존 대규모 팀과 동등한 생산성

---

#### 44. 리더의 Ai 직접 사용 원칙

**설명**: 관리자가 직접 AI 도구 경험 후 팀에 권장

---

#### 45. Inside-Out Ai 적용 전략

**설명**: 내부 업무 → 교육/해커톤 → 서비스 적용 순서

---

#### 46. 마이크로 앱 방식의 Ai 통합

**설명**: 단위 업무별 독립된 마이크로 앱 개발

---

#### 47. 도구 선택의 지혜

**설명**: 프로토타이핑 vs 프로덕션 도구 구분

---

#### 48. Ide 연결 관리

**설명**: `/ide` 명령으로 끊긴 IDE 연결을 확인하고 재연결

---

#### 49. 기능 추가 → 테스트 → 빌드 → 커밋 워크플로우

**설명**: 새 기능 요청 → 테스트 작성 요청 → 빌드 검증 → GitHub 커밋까지 일련의 워크플로우

---

#### 50. 대체 Api 엔드포인트 연동

**설명**: `ANTHROPIC_BASE_URL` 환경 변수로 대체 API(예: Moonshot/Kimi K2)를 Claude Code와 통합

---

#### 51. 파일 업로드 및 도구 사용 최소화

**설명**: MCP 도구 사용 시 숨겨진 토큰/API 요청이 발생하므로, 필요한 도구만 연결

---

#### 52. Deepseek Mcp 폴백 설정

**설명**: Claude Desktop에 DeepSeek을 MCP 서버로 추가하여, Claude 사용 한도 도달 시 자동으로 대체 AI로 전환

---

#### 53. 메모리 도구 (Memory Tool)

**설명**: 중요한 지식을 세션 간에 보존하고 컨텍스트 초과/성능 저하를 방지하는 상태 관리 도구

---

#### 54. Vs Code Extension 통합

**설명**: IDE 내에서 Claude Code의 모든 기능을 사용할 수 있는 네이티브 확장 프로그램

---

#### 55. 성능 모니터링 도구 활용

**설명**: 토큰 소비와 응답 시간을 실시간으로 추적

---

#### 56. Pretooluse 훅을 통한 도구 입력 가로채기

**설명**: Claude가 도구를 실행하기 전에 도구 입력을 가로채고 수정

---

#### 57. Mcp 서버를 통한 외부 도구 통합

**설명**: Model Context Protocol을 통해 외부 API와 도구를 Claude Code에 통합

---

#### 58. 플러그인 소스 코드 검토

**설명**: 플러그인이 Claude Code와 동일한 권한으로 실행되므로, 설치 전 소스 코드를 검토

---

#### 59. Claude Code + Obsidian 통합

**설명**: 터미널에서 Claude Code를 Obsidian 볼트 디렉토리에 연결하여 로컬 파일 시스템에 직접 작업

---

#### 60. Ai는 도구일 뿐, 검수는 사용자가

**설명**: AI가 생성한 콘텐츠의 최종 검수는 반드시 사용자가 직접 수행

---

#### 61. Para + Zettelkasten 통합 방법론

**설명**: PARA 방법론과 Zettelkasten을 결합하여 개인 학습과 업무 프로젝트를 통합 관리

---

#### 62. Claude Code Skills - 마크다운 기반 지식 전달

**설명**: Claude에게 특정 작업 수행 방법을 가르치는 마크다운 파일로, 스크립트나 서버 없이 지식 파일만으로 AI의 능력을 확장

---

#### 63. Claude Code 확장 방식 선택 프레임워크

**설명**: Claude Code의 다양한 확장 방식(Ad-hoc, Skills, 슬래시 명령어, MCP, Hooks)의 장단점을 이해하고 선택

---

#### 64. 도메인 특화 출력 형식 학습

**설명**: AI에게 특정 도구나 형식의 세부 규칙을 가르쳐 유효한 결과물을 생성

---

#### 65. 조건부 참조 로딩 (Lazy Loading)

**설명**: Read 도구를 사용하여 스킬이 특정 참조를 로드하기로 결정할 때만 문서를 로드

---

#### 66. Plugin Marketplace

**설명**: 커스텀 슬래시 커맨드, MCP 서버 토글

---

#### 67. 도구 확장 활성화 (Extension Activation)

**설명**: Goose는 Computer Controller와 Developer 확장 기능을 통해 실제 시스템 명령을 실행하고 개발 도구와 통합할 수 있습니다.

**예시**: `goose configure`로 확장 선택 후 `goose session` 시작

---

#### 68. 우발적 복잡성 Vs 본질적 복잡성 구분 활용

**설명**: Fred Brooks의 개념을 적용하여 LLM이 효과적으로 도울 수 있는 영역(우발적 복잡성: 보일러플레이트, 프레임워크 통합, 구문 작성)과 개발자가 주도해야 하는 영역(본질적 복잡성: 명세, 설계, 테스팅)을 구분합니다.

**예시**: CI/CD 파이프라인 설정은 LLM에 위임, 도메인 모델 설계는 개발자가 직접 수행

---

#### 69. 문서 태깅 (Documentation Tagging)

**설명**: 사용 중인 기술의 공식 문서 URL을 Cursor의 문서 추가 기능을 통해 프로젝트에 연결합니다.

**예시**: Next.js 공식 문서 URL을 Cursor에 태깅, Supabase 문서를 프로젝트 컨텍스트로 추가

---

#### 70. 멀티 Ai 모델 앙상블

**설명**: Cursor에서 해결되지 않는 문제가 발생하면 같은 문제를 Claude, GPT 등 다른 AI 모델에 전달합니다.

**예시**: Cursor에서 에러 발생 → 시도한 해결책 기록 → Claude에 동일 문제 + 시도 내역 전달 → 새로운 해결책 도출

---

#### 71. .Cursorignore 인덱싱 최적화

**설명**: `.cursorignore` 파일을 생성하여 AI 인덱싱에서 제외할 파일 패턴을 지정합니다.

**예시**: `*.excalidraw.md`, `*.avif`, `node_modules/` 패턴 추가

---

#### 72. 다중 문서 통합 글쓰기

**설명**: 3개 이상의 관련 노트를 AI에게 전달하고 "통합된 내용으로 새로운 글을 작성해줘"라고 요청합니다.

**예시**: `@파일1.md @파일2.md @파일3.md` 멘션 후 "이 3개의 글을 합쳐서 통합된 내용으로 새로운 글을 작성해줘"

---

#### 73. Ai 도구 조합 프레임워크 (V0 + Claude + Cursor)

**설명**: V0는 UI 컴포넌트 생성, Claude AI는 코드 구조화, Cursor AI는 기능 개발 및 디버깅에 특화하여 각 도구의 강점을 조합합니다.

**예시**: V0로 초기 UI → Claude로 컴포넌트 분리 → Cursor로 기능 추가

---

#### 74. 외부 리소스 Url 참조

**설명**: Pixabay 등 무료 이미지 사이트의 URL을 직접 참조하여 AI에게 에셋 통합을 요청합니다.

**예시**: `@https://cdn.pixabay.com/... 이 이미지를 히어로 섹션의 배경이미지로 넣어줘`

---

#### 75. 도구로서의 Ai 인식 (Ai As Efficiency Tool)

**설명**: 수동 작업 방법을 이미 알고 있을 때 AI를 효율성 도구로 활용하는 것이 최선입니다. AI를 대체재가 아닌 보조 도구로 인식합니다.

**예시**: 먼저 수동으로 해당 작업을 수행하는 방법을 이해한 후, 반복적인 부분만 AI에게 위임

---

#### 76. Ai 역할 한정 전략 (Ai As Gap Filler)

**설명**: AI를 생산성 향상 도구로 활용하되, 아키텍처나 비즈니스 로직이 아닌 기술적 세부사항(boilerplate, 표준 패턴 구현)을 채우는 용도로 제한합니다.

**예시**: 인증/인가 모듈 초기 구현을 AI에게 맡기고, 비즈니스 규칙은 개발자가 직접 추가

---

#### 77. Ai 보조 도구 인식 (지원 도구 Vs 의존 도구)

**설명**: AI를 지원 도구로 사용하되 의존성을 갖지 않도록 주의해야 합니다. 최종 판단은 항상 인간이 내려야 합니다.

**예시**: AI 제안을 그대로 수용하지 않고 항상 검토, 핵심 비즈니스 로직은 직접 작성

---

#### 78. Mcp 도구 통합 및 발견 가능성

**설명**: MCP는 도구 통합에 중요하지만, 어느 시점에서 올바른 도구를 찾고 모델이 도구들 사이에서 혼란스러워하지 않도록 하는 "발견 가능성" 문제를 해결해야 합니다.

**예시**: 사용자 의도에 따라 적합한 MCP 도구를 자동 선택하고, 도구 간 충돌을 방지하는 라우팅 로직

---

#### 79. Multi-Model Integration

**설명**: OpenAI, Anthropic, Ollama(로컬) 등 다양한 AI 모델을 `-m` 옵션으로 쉽게 전환하여 사용합니다.

**적용 조건**: 비용 최적화, 보안이 중요한 작업

---

#### 80. Pkm 도구와 Ai 통합 (Obsidian)

**설명**: Fabric 출력을 Obsidian 노트로 직접 저장하거나, Obsidian 노트를 Fabric 입력으로 활용합니다.

**적용 조건**: 학습 노트 정리, 연구 자료 요약

---

#### 81. 하이브리드 도구 통합 (Hybrid Tool Integration)

**설명**: Claude Code를 Cursor 내 터미널에서 실행하여 두 도구의 장점을 결합합니다.

**적용 조건**: 대규모 프로젝트에서 복잡한 기능 개발과 간단한 버그 수정이 혼재할 때

---

#### 82. Sequential Thinking Mcp 활용

**설명**: Sequential Thinking MCP를 통해 복잡한 문제를 작은 단계로 분해하고 체계적으로 해결합니다.

**적용 조건**: 복잡한 비즈니스 로직 구현 시

---

#### 83. 터미널 기반 Cli 통합 워크플로우

**설명**: Claude Code의 터미널 환경 친화성을 활용하여 CLI 기반 작업을 자연스럽게 통합합니다.

**적용 조건**: DevOps 작업, CI/CD 파이프라인 구성 시

---

#### 84. Ide 내장 Ai 코딩 어시스턴트 통합

**설명**: Avante.nvim을 통해 Neovim 환경에서 Cursor AI와 유사한 AI 코딩 지원을 받을 수 있습니다.

**적용 조건**: Neovim 사용자가 기존 환경에서 AI 코딩 어시스턴트를 사용하고 싶을 때

---

#### 85. 6대 필수 Mcp 서버

**설명**: Bright Data, Graphiti, GitIngest, Terminal, Code Executor, MindsDB

---

#### 86. Ai 도구 체이닝

**설명**: Goose AI → JetBrains AI → Junie 순차 활용

---

#### 87. 사전 구축된 Mcp 서버 활용

**설명**: Google Drive, Slack, GitHub, Git, Postgres, Puppeteer 등 오픈소스 MCP 서버 레포지토리 즉시 활용

---

#### 88. Claude 3.5 Sonnet으로 Mcp 서버 구현

**설명**: Claude 3.5 Sonnet이 MCP 서버 구현에 능숙하므로, AI를 활용하여 커스텀 데이터 소스 연결 신속 개발

---

#### 89. 개발 도구와 Mcp 통합

**설명**: Zed, Replit, Codeium, Sourcegraph에 MCP 적용하여 AI 에이전트가 코딩 작업 맥락을 더 잘 이해

---

#### 90. 표준화된 인터페이스로 통합 단순화

**설명**: 단일 MCP 프로토콜에 맞게 구축하여 유지보수 부담 감소

---

#### 91. @Action으로 개별 기능 정의

**설명**: 에이전트가 수행할 기능을 `@Action` 어노테이션으로 표시, `toolGroups`로 외부 도구 접근 권한 부여

---

#### 92. Ai Assistant Vs Junie 역할 구분 활용

**설명**: 작업 성격에 따라 적절한 도구 선택

---

#### 93. 팀 내 Ai 도구 베스트 프랙티스 공유

**설명**: - AI 도구 사용 경험과 효과적인 활용법을 팀 내에서 공유

---

#### 94. 2: Ai를 Code Assistant로 활용

**설명**: AI를 단순 코드 생성기가 아닌 보조 도구로 활용, 개발자가 주도권 유지

---

#### 95. 3: 하이브리드 학습 전략 (전통적 코딩 + Ai 도구)

**설명**: "둘 중 하나"가 아닌 "둘 다" 마스터하는 전략

---

#### 96. 6: Git Worktrees를 활용한 병렬 개발

**설명**: 여러 Claude Code 인스턴스를 동시에 실행, 컨텍스트 전환 비용 제거

---

#### 97. 6: Spring Ai를 활용한 Mcp 서버 개발

**설명**: `@Tool` 어노테이션으로 Java 메서드를 AI 도구로 자동 등록

---

#### 98. 7: 멀티 Mcp 서버 통합 아키텍처

**설명**: 도메인별 전문화된 MCP 서버를 마이크로서비스 패턴으로 운영

---

#### 99. Vercel Grep Mcp를 통한 실시간 Github 검색 통합

**설명**: Claude Desktop, Cursor, Claude Code에서 100만 개 이상의 GitHub 저장소를 실시간으로 검색하여 실제 프로덕션 코드 예제를 얻는 방법. `mcp-remote`를 사용하여 프로토콜 호환성 문제를 해결함.

---

#### 100. Mcp-Remote를 활용한 프로토콜 브리징

**설명**: HTTP 기반 MCP 서버를 stdio 프로토콜로 변환하여 Claude Desktop에서도 사용 가능하게 만드는 기법

---

#### 101. 도구 그룹(Toolgroup) 활용

**설명**: `CoreToolGroups.WEB`과 같이 미리 정의된 도구 그룹으로 외부 리소스 접근

---

#### 102. 데모 패턴 우선 활용

**설명**: `get_component_demo` 도구를 사용하여 올바른 컴포넌트 사용 예제를 먼저 확인

---

#### 103. Github Api 토큰으로 요청 제한 확장

**설명**: 시간당 요청 한도를 60회에서 5,000회로 확장

---

#### 104. 도구 권한 세분화

**설명**: `--allowedTools`, `--disallowedTools`

---

#### 105. 샌드박스 환경 사용

**설명**: GitHub Codespaces를 활용한 격리 환경

---

#### 106. Json 형식으로 Mcp 서버 추가

**설명**: `claude mcp add` 명령어

---

#### 107. 토큰 효율성 플래그

**설명**: `token_efficient_tool_use_beta` 플래그로 약 5.7% 토큰 절감

---

#### 108. 10단계 숙련도 모델

**설명**: Claude Code 활용의 단계적 학습 경로

---

#### 109. 중복 제거 및 구조 개선

**설명**: 여러 원본 통합 시 단순 병합이 아닌 고차원적 통합 요청.

---

#### 110. Ide 내장 도구 선택과 활용

**설명**: Windsurf, Cursor, JetBrains 등 GenAI 통합 IDE 도구 활용.

---

#### 111. Ide 내 대화형 개발

**설명**: IDE를 떠나지 않고 도구와 대화하며 학습, 현재 컨텍스트 자동 활용.

---

#### 112. 멀티모달 소스 통합 분석

**설명**: PDF, 문서, YouTube URL 등 다양한 형식을 하나의 프로젝트에서 통합 분석.

---

#### 113. 점진적 기능 확장 전략

**설명**: 핵심 기능으로 시작 후 이슈 트래커 통합, API 공개, CI 자동 통합 단계적 추가.

---

#### 114. 명시적 작업 분할

**설명**: "CRUD API 구축" 같은 모호한 요청 대신 GitHub 이슈 수준의 구체적인 태스크 분할.

---

#### 115. Ide 기반 Ai 도구의 전략적 활용

**설명**: Cursor(Claude Sonnet 4 기반) 활용, 파일 참조로 대화형 코딩.

---

#### 116. 개발 단계 세분화(Phased Development)

**설명**: 9단계로 개발 순서를 명시하여 논리적이고 통합된 구현 가이드.

---

#### 117. Mcp 기반 도구 통합

**설명**: LLM이 실제 애플리케이션과 직접 상호작용하는 중간 인터프리터 프로토콜 활용.

---

#### 118. 자동 승인 설정(Auto-Approval)

**설명**: `"chat.tools.autoApprove": true`로 반복 인증 제거.

---

#### 119. Claude Artifacts + Api 통합 웹앱 생성

**설명**: Claude에게 무료 API를 활용한 웹앱을 5분 만에 생성하도록 요청

**적용 조건**: 빠른 프로토타이핑이나 API 연동 데모가 필요할 때

---

#### 120. Terminal Floating Mode 활용

**설명**: Claude Code 터미널에서 3 dot 메뉴 → view mode → floating을 선택하여 터미널을 크게 확장

**적용 조건**: 터미널 출력을 더 자세히 확인하거나 복잡한 명령어 작업을 할 때

---

#### 121. 외부 Api/도구 통합 (Zapier 등)

**설명**: GPT를 외부 서비스와 연동하여 자동화

**적용 조건**: 업무 자동화, 워크플로우 구축

---

#### 122. 검색 엔진 통합 (Serpapi)

**설명**: 실시간 검색 결과를 활용한 정보 수집

**적용 조건**: 최신 정보 필요 시, 시장 조사

---

#### 123. Autodev를 이용한 Ai 코드 생성 및 Ui 구현

**설명**: AutoDev 도구와 LLM을 연동하여 실시간 코드 생성 및 웹 UI 구현

**적용 조건**: React 기반 웹 애플리케이션 프로토타이핑, Tailwind CSS를 사용한 빠른 UI 개발

---

#### 124. Ast 기반 코드 분석

**설명**: Serena MCP를 활용한 심볼 탐색, 패턴 검색, 선택적 코드 읽기

---

#### 125. Plan Mode For Code Analysis

**설명**: Claude Code의 plan mode에서 코드 수정 요청 시 AI가 문제를 분석하고 구체적인 수정 방안(파일 위치, 메서드명, 라인 번호, 수정 코드) 제시

**적용 조건**: 코드 수정 전에 영향 범위와 수정 방안 검토, 복잡한 수정 작업의 계획 수립

---

#### 126. Mcp 도구 자동 등록 (Annotation 기반)

**설명**: `@McpTool`과 `@McpToolParam` 애노테이션으로 일반 메서드를 AI가 호출할 수 있는 도구로 자동 노출

**적용 조건**: 기존 서비스의 기능을 AI 에이전트가 사용할 수 있도록 빠르게 노출

---

#### 127. Llm 주도 도구 호출 위임 (Tool Ownership By Llm)

**설명**: 도구의 호출 시점과 순서를 호스트가 아닌 LLM이 결정하도록 위임. 더 자연스러운 AI 에이전트 행동 가능

**적용 조건**: AI 에이전트가 복잡한 워크플로우를 자율적으로 처리해야 할 때

---

#### 128. Toolcallbackprovider를 통한 다중 Mcp 서버 통합

**설명**: 여러 MCP 서버를 단일 ChatClient에 연결하여 LLM이 다양한 외부 서비스를 통합적으로 활용

**적용 조건**: AI 에이전트가 날씨 API, 웹 검색, 데이터베이스 등 여러 외부 서비스를 동시에 활용

---

#### 129. 양방향 Ai 상호작용 (서버-클라이언트 샘플링)

**설명**: MCP 서버가 클라이언트의 LLM에게 서버 데이터를 기반으로 콘텐츠 생성을 요청(Sampling)하는 양방향 패턴

**적용 조건**: 서버가 보유한 데이터를 AI가 창의적으로 가공/해석해야 할 때

---

#### 130. 설계 문서-코드 동일 저장소 구조 패턴

**설명**: 설계 문서를 코드 패키지 구조와 미러링하여 동일 저장소에 배치. Git 버전 관리, diff 추적 가능

**적용 조건**: 설계 변경 이력을 코드와 함께 추적, AI 생성 코드의 근거 명확화

---

#### 131. Task Master Ai를 이용한 프로젝트 초기화 자동화

**설명**: `task-master init` 명령으로 cursor rules, mcp.json, PRD 템플릿, 환경 설정 파일 등 자동 생성

**적용 조건**: 새 프로젝트를 시작할 때 AI 도구(특히 Cursor)와의 통합 환경 빠르게 구축

---

#### 132. Git 생태계 통합 Ai 워크플로우

**설명**: Git 저장소와 완전히 통합되어 AI가 수행한 작업이 자연스럽게 버전 관리되고 추적 가능

---

#### 133. 가이드라인 파일을 통한 Ai 커스터마이징

**설명**: 프로젝트에 `.juni/guidelines` 파일을 생성하여 Java 버전, 빌드 도구, 패키지 구조, HTTP 클라이언트 선호도, 불변 객체(record) 사용, 테스트 지침 등을 명시하면 AI가 개발자의 코딩 스타일에 맞는 코드를 생성함

---

#### 134. Ai 어시스턴트 컨텍스트 브릿징

**설명**: 브라우저 콘솔 로그를 터미널로 스트리밍하여 AI 코딩 어시스턴트(Cursor, Claude Code, Copilot CLI 등)가 클라이언트 측 상태를 파악할 수 있게 함. AI가 터미널 출력만 읽을 수 있는 한계를 극복하는 기법

---

#### 135. 제로 설정(Zero Setup) Ai 도구 통합

**설명**: 복잡한 설정 없이 AI 도구가 전체 애플리케이션 컨텍스트(서버 + 클라이언트)를 이해할 수 있도록 환경 구축. 개발자 마찰을 최소화하면서 AI 협업 효과를 극대화

---

#### 136. 개발 환경 한정 Ai 도구 통합

**설명**: 프로덕션에는 영향을 주지 않으면서 개발 환경에서만 AI 협업 기능 활성화. 안전하게 AI 도구를 개발 워크플로우에 통합하는 패턴

---

#### 137. 크로스 프레임워크 Ai 통합 패턴

**설명**: React, Vue, Next.js, Nuxt 등 다양한 프레임워크에서 일관된 방식으로 AI 도구와 연동할 수 있는 프로바이더 패턴 적용

---

#### 138. 이미지 분석 통합

**설명**: 스크린샷, 다이어그램, UI 목업을 드래그앤드롭/붙여넣기/경로 제공으로 Claude에 전달하여 분석 및 코드 생성

---

#### 139. Cli 도구를 통한 Mcp 대체

**설명**: MCP가 수만 개의 컨텍스트 토큰을 소비하는 반면, LLM은 `cli-tool --help` 호출로 사용법을 스스로 파악할 수 있어 CLI 도구가 더 효율적인 대안이 됨

---

#### 140. 크로스 모델 호환 Skills 설계

**설명**: Skills 폴더를 Codex CLI나 Gemini CLI 등 다른 도구에 연결해도 작동하도록 설계하여 특정 모델/도구에 종속되지 않는 범용 능력 확장

---

#### 141. Github 통합 활용

**설명**: 쉬운 작업의 경우 GitHub 이슈에서 @Claude를 태그하여 자동으로 PR을 작성하게 하여 터미널을 자유롭게 유지

---

#### 142. Git 히스토리 탐색을 통한 학습

**설명**: Claude Code가 코드베이스 탐색 및 Git 히스토리 분석을 통해 "이 함수가 왜 이렇게 설계되었는지" 등의 맥락 파악을 도울 수 있음

---

#### 143. Rag 기반 대화 검색 (Rag-Based Conversation Search)

**설명**: AI가 생성한 요약 대신 실제 대화 내용을 RAG로 검색. conversation_search, recent_chats 도구로 의미론적 검색과 시간순 검색 수행.

**적용 조건**: 장기 프로젝트에서 과거 결정사항 추적, 아키텍처 결정 기록(ADR) 관리

---

#### 144. 도구 호출 감사 (Tool Call Auditing)

**설명**: AI가 메모리를 검색하거나 업데이트할 때 실행되는 함수 호출을 실시간으로 모니터링.

**적용 조건**: AI 응답 신뢰성 검증, 디버깅, 프라이버시 감사

---

#### 145. Mcp Code Execution Pattern

**설명**: AI 에이전트가 Tool을 직접 호출하는 대신, Tool을 호출하는 코드를 작성하고 실행하도록 설계. 필요한 툴만 동적으로 로드.

**적용 조건**: 다수의 MCP 서버를 연결해야 하는 복잡한 환경

---

#### 146. Pre-Model Data Filtering & Aggregation

**설명**: Tool 간 데이터 이동 시 중간 결과를 모델에 전달하지 않고 코드 실행 환경에서 필터링/집계. 토큰 소비 최대 98% 감소.

**적용 조건**: 대용량 데이터를 반환하는 API/Tool 사용 시

---

#### 147. 멀티 소스 콘텐츠 자동 처리 파이프라인

**설명**: YouTube 플레이리스트, 블로그, GitHub 등 다양한 콘텐츠 소스를 자동으로 수집, 처리, 분류. CSV 기반 메타데이터 관리.

**적용 조건**: 개인 지식 베이스 구축, 팀 지식 관리

---

#### 148. Mcp 리소스 서버 패턴

**설명**: 처리된 콘텐츠를 MCP 형식으로 변환하고 STDIO/HTTP 모드로 제공하는 서버 구축.

**적용 조건**: Claude Desktop 확장, 외부 시스템에서 지식 베이스 활용

---

#### 149. Obsidian 파일 자동 분류 및 태깅 시스템

**설명**: Claude Code slash command로 Obsidian 문서를 자동으로 분석하고 hierarchical tag를 부여 후 최적의 디렉토리로 이동.

**적용 조건**: PKM 시스템에서 새 문서 추가, 분류 체계 재정비

---

#### 150. Ai를 대체가 아닌 보조 도구로 활용

**설명**: 개발자가 코드베이스를 정확히 이해하고 주도하면서 반복적인 작업을 AI에게 위임.

**적용 조건**: 코드 품질과 이해도를 유지하면서 생산성 향상

---

#### 151. Mcp 도구 통합 (Context7, Sequential, Magic, Puppeteer)

**설명**: 4가지 전문 도구를 통합 운용. 트리거 계층 구조로 적절한 도구 자동 선택.

**적용 조건**: 복잡한 개발 작업에서 적절한 도구 자동 선택

---

#### 152. 세션 상태 체크포인트 및 롤백

**설명**: `/user:git --checkpoint`로 대화와 코드의 전체 상태 저장, `--rollback`으로 복원.

**적용 조건**: 실험적인 코드 변경을 시도하다 실패했을 때

---

#### 153. 복잡한 종속성 없는 빠른 온보딩

**설명**: 간단한 git clone과 install.sh 실행만으로 설치 완료.

**적용 조건**: 팀원들이 빠르게 AI 도구를 도입

---

#### 154. Mcp Integration For Enhanced Ai Capabilities

**설명**: Context7, Sequential, Magic, Puppeteer 같은 MCP 서버를 플래그로 통합.

**적용 조건**: 복잡한 추론, 최신 라이브러리 문서 참조, UI 컴포넌트 생성

---

#### 155. 다중 Ai 제공업체 통합 (Multi-Provider Ai Integration)

**설명**: Claude, Perplexity, OpenAI, Gemini, X AI, OpenRouter 등 여러 AI 제공업체를 단일 워크플로우에서 통합 활용하는 기법입니다. 단일 AI에 의존하지 않고 각 모델의 강점을 활용하며 장애 시 대체 모델로 전환할 수 있습니다.

---

#### 156. 협력적 디자인 파트너 패턴 (Collaborative Design Partner Pattern)

**설명**: AI를 단순한 코드 생성 도구가 아닌 협력적 디자인 파트너로 활용합니다.

---

#### 157. 비코딩 Ai 활용 패턴

**설명**: Claude Code를 코딩 도구가 아닌 일상 생활 관리 도구로 활용하는 패턴입니다.

---

#### 158. 다중 Ai 플랫폼 전략적 활용

**설명**: Claude(감정 표현, 문서 작성), ChatGPT(다목적), Gemini(구글 스페이스 연동) 등 각 AI의 특성을 파악하여 업무별로 적합한 도구를 선택하여 활용하는 전략.

---

#### 159. 음성 Ai 일상 통합

**설명**: 운전 중에도 음성 AI를 활용하여 날씨 정보 조회, 시장 정보 검색 등 손을 사용하지 않고도 정보를 얻는 방식.

---

#### 160. Ai 보조 철학 (Ai As Augmentation)

**설명**: "AI는 사람을 대체하는 것이 아니라, 사람이 더 가치 있는 일에 집중할 수 있게 만드는 도구"라는 경영 철학.

---

#### 161. Plan Mode를 활용한 체계적 개발

**설명**: Claude Code에서 Shift+Tab으로 'Plan Mode'를 선택한 후 PRD 문서를 기반으로 빌드를 요청하면, Claude가 계획을 세우고 체계적으로 개발을 진행합니다.

---

#### 162. Ai 도구 간 연계 워크플로우

**설명**: Bolt에서 빠르게 프로토타입을 구현하고, 세부 설정은 Claude Code에게 질문하여 확인하는 방식으로 여러 AI 도구를 연계하여 활용하는 방법입니다.

---

#### 163. 대화 기록 관리 및 Ide 간 이동

**설명**: /resume으로 이전 대화 기록으로 돌아가고, /export로 전체 대화 기록을 내보냅니다.

---

#### 164. Cc-Undo를 통한 변경사항 관리

**설명**: cc-undo 패키지를 활용하여 Claude Code의 변경사항을 관리합니다.

---

#### 165. 대체 모델 연결 (비용 최적화)

**설명**: Claude Code에 다른 LLM 모델(예: Kimi K2)을 연결하여 비용을 절감하는 기법.

---

#### 166. Llm-Mcp 역할 분담 아키텍처

**설명**: LLM은 "사고"를 담당하고, MCP는 "실행"을 담당하는 명확한 역할 분담 아키텍처입니다.

---

#### 167. Multi Clauding (병렬 Ai 개발)

**설명**: Git worktree를 활용하여 여러 GitHub 이슈를 병렬로 처리합니다.

---

#### 168. Mcp 도구 확장을 통한 에이전트 역량 확장

**설명**: Model Context Protocol(MCP)을 추가하거나 커스텀 tool을 직접 추가하여 에이전트의 역량을 확장합니다.

---

#### 169. Mcp 기반 개인 지식베이스 구축

**설명**: MCP 서버를 구축하여 600개 이상의 개인 콘텐츠를 체계화하고, AI가 검색 및 활용할 수 있도록 합니다.

---

#### 170. Ai 도구를 활용한 지식 큐레이션

**설명**: 방대한 양의 개인 콘텐츠를 AI 도구를 활용하여 특정 주제별로 큐레이션하고 요약합니다.

---

#### 171. Claude Code 계획 모드 (Planning Mode) 활용

**설명**: 코드를 즉시 생성하는 대신 구현 전략과 아키텍처에 대해 먼저 반복적으로 개선하는 접근 방식입니다.

---

#### 172. 에이전틱 Ai 도구를 통한 프로젝트 컨텍스트 이해

**설명**: Claude Code와 같은 에이전틱 도구는 전체 프로젝트 컨텍스트를 이해하고 완전한 애플리케이션을 구축할 수 있습니다.

---

#### 173. Ai 도구의 샌드박스 접근 방식

**설명**: Claude Code의 샌드박스 접근 방식은 프로젝트 디렉토리 내에서만 작동하여 보안 경계를 유지합니다.

---

#### 174. Claude Desktop과 Mcp 통합 워크플로우

**설명**: Claude Desktop에 자연어로 명령을 내려 MCP 서버가 제공하는 도구를 활용합니다.

---

#### 175. 단계적 구현 가이드 (Phased Implementation Guide)

**설명**: 복잡한 프로젝트를 8단계로 나누어 체계적으로 구현합니다.

---

#### 176. 문제 이해 우선 원칙

**설명**: AI 도구를 활용할 때도 문제 이해가 코딩보다 더 중요.

---

#### 177. Ai는 도구이고 문제 해결은 인간의 몫

**설명**: AI를 활용할 때 최종 판단과 문제 해결 책임은 개발자에게 있음.

---

#### 178. Ai 생성 코드 거버넌스 프레임워크

**설명**: AI 코드 생성 도구 사용을 위한 화이트리스트 구축, 출처 표준 시행, AI 생성 코드 패턴 감지 및 커밋 태깅.

---

#### 179. 레거시 시스템 Ai 통합 전략

**설명**: 레거시 앱에서 AI 생성 코드의 위험을 관리하는 전략.

---

### Quality & Security (122개)

#### 1. 보안 검토 프롬프트

**설명**: "작성한 코드가 보안 모범 사례를 따르는지 확인하고, 프론트엔드에 민감한 정보가 없으며 악용 가능한 취약점이 없는지 점검해달라"는 표준 프롬프트 활용

*출처: 7개 문서*

---

#### 2. 보안 리뷰 자동화

**설명**: CWE/OWASP 매핑을 포함한 구조화된 보안 발견사항 테이블 생성, 시크릿 탐지, AuthZ/AuthN 검사, 입력 검증, 암호화 취약점, 공급망 보안을 자동으로 스캔하는 전용 Security Review 워크플로우

**관련 도구**: Claude Code, GitHub Actions

*출처: 5개 문서*

---

#### 3. 검증 우선 Ai 활용

**설명**: "검증할 수 있는 것보다 빠르게 소프트웨어를 생산하는 것"이 새로운 위험. AI 코드 생성 속도를 검증 속도에 맞춰 조절

**적용 조건**: AI 도구로 빠르게 프로토타이핑할 때, 생성된 코드의 품질과 정확성 확보

*출처: 3개 문서*

---

#### 4. 점진적 Ai 코드 생성 (Incremental Development)

**설명**: AI 코드 생성 시에도 작고 관리 가능한 단계로 변경을 분해하여 오류를 감소시키고 디버깅을 단순화합니다.

**관련 도구**: GitHub Copilot, Cursor AI

**예시**: 간단한 코드 자동완성 → 복잡한 로직 생성 → 전체 워크플로우 통합

*출처: 2개 문서*

---

#### 5. 자동화된 코드 리뷰

**설명**: `git diff HEAD~1 | claude -p "review this PR"`

*출처: 2개 문서*

---

#### 6. Ai 생성 코드 정기 감사

**설명**: AI 도구가 제안하는 코드의 품질과 수용률을 정기적으로 추적하고 감사합니다.

**적용 조건**: 분기별 코드 품질 리뷰 시

*출처: 2개 문서*

---

#### 7. 0% 오류율 코드 편집

**설명**: 내부 코드 편집 벤치마크에서 오류율을 최소화하는 정밀한 코드 편집 능력

*출처: 2개 문서*

---

#### 8. 서브에이전트 활용

**설명**: `/security-review` 슬래시 명령이 전용 도구/validators와 예시 문서를 가진 "security-reviewer" 서브에이전트를 호출하도록 구성하여 전문화된 리뷰 수행

*출처: 2개 문서*

---

#### 9. 행동 가이드라인 명시

**설명**: 보안 우선, 프로덕션 준비 상태, 에러 처리, 문서화 등 개발 원칙 명시.

*출처: 2개 문서*

---

#### 10. 반복적 검증 루프

**설명**: 문제 재현 → 수정 → 린팅 → 포맷 → 테스트 → 커밋 → PR → 리뷰 자동화.

*출처: 2개 문서*

---

#### 11. 역할 기반 프롬프트 엔지니어링

**설명**: AI 에이전트에게 "Staff Security Engineer" 또는 "Principal Frontend Reviewer" 같은 구체적인 역할을 부여하여 전문가 관점에서 리뷰하도록 유도

*출처: 2개 문서*

---

#### 12. 테스트를 Ai 환각 방지 안전장치로 활용

**설명**: - 테스트 스위트가 AI 생성 코드의 품질 검증 역할

---

#### 13. Ai 생성 코드 품질 체크 프로세스

**설명**: - SRP 위반, DI 부적절한 적용, 계층간 경계 불분명 등 사전 체크

---

#### 14. 에러 로그 분석

**설명**: `cat error.log | claude -p "find the root cause"`

---

#### 15. 비기능 요구사항 명시

**설명**: 성능(페이지 로드 < 2초), 보안, 확장성(10,000+ 동시 사용자) 등 명확히 정의.

---

#### 16. 점진적 Ai 도입 (9주 로드맵)

**설명**: 1주차 CRUD → 2-3주차 비즈니스 로직 → 4-6주차 도메인 모델링 → 7-8주차 성능/보안 → 9주차+ 팀 통합

**관련 도구**: Claude, Cursor

---

#### 17. 씨앗을 먹어버리지 않기 (Eating The Seed Corn 방지)

**설명**: AI가 "일단 돌아가기만 하면 된다"는 코드를 생성하면 확장성이 망가짐. 미래를 위한 코드 품질 유지

**적용 조건**: 바이브 코딩 시 품질 관리

---

#### 18. 다중 페르소나 코드 리뷰

**설명**: 보안 전문가, 성능 엔지니어, 유지 관리성 전문가 등 다양한 관점에서 코드 검토 요청

**관련 도구**: ChatGPT, Claude

---

#### 19. 아키텍처 결정 프레임워크

**설명**: 성능, 개발 복잡성, 운영, 확장성, 보안, 비용 등 다차원 분석으로 아키텍처 옵션 평가

**관련 도구**: ChatGPT, Claude

---

#### 20. 반복적 개선 피드백 루프

**설명**: 성능, 유지 관리성, 오류 처리, 보안, 테스트 커버리지 기준으로 AI 솔루션을 평가하고 피드백

**관련 도구**: ChatGPT, Claude

---

#### 21. Cmd K + Ai 리뷰 조합

**설명**: 코드 선택 → Cmd K 리팩토링 → 변경 적용 → AI 리뷰로 검증

**관련 도구**: Cursor AI

---

#### 22. 개발 프로세스 지원 에이전트

**설명**: Code Reviewer, Debugger, Documenter 등 라이프사이클 지원

---

#### 23. 계층적 전문성 정의

**설명**: Technical Expertise → Development Standards → Output Quality 순 구체화

---

#### 24. Review Categories 구조화

**설명**: Critical → Major → Minor → Praise 순 이슈 우선순위 정의

---

#### 25. Security Assessment Framework

**설명**: 8단계 보안 평가 체계

---

#### 26. Exa Search 실시간 검색

**설명**: 개발 환경 내 검증 가능한 정보 스트리밍

---

#### 27. Ai를 통한 디버깅

**설명**: 정확한 오류 메시지 제공, 엣지 케이스 식별

---

#### 28. 개선사항 요청하기

**설명**: 가독성, 모듈화, 오류 처리 제안 요청

---

#### 29. Ai 코드 3차원 검증 프레임워크

**설명**: AI 생성 코드를 정확성, 효율성, 품질 세 가지 차원에서 모두 검증

---

#### 30. 코드 품질과 성능의 분리 인식

**설명**: 가독성 메트릭과 성능 메트릭을 별도로 평가

---

#### 31. 환경 변수를 통한 Api 키 관리

**설명**: API 키를 환경 변수로 관리하여 보안 강화

---

#### 32. 빠르고 저렴한 실패 문화

**설명**: 작은 MVP → 2-4주 검증 → 빠른 피벗

---

#### 33. 장기 작업 집중력 유지

**설명**: 복잡하고 다단계 작업에서 30시간 이상 집중력을 유지하여 일관된 코드 품질 제공

---

#### 34. 의도 명확화 기법

**설명**: XML 태그를 사용하여 프롬프트의 의도를 명확하게 구분함으로써 환각(hallucination)을 감소

---

#### 35. 환경 변수 기반 권한 제어

**설명**: 권한 프레임워크가 환경 변수를 이해하여 세밀한 보안 제어 가능

---

#### 36. 보안 스캐너 플러그인

**설명**: 플러그인으로 보안 스캐너를 통합하여 코드 보안 취약점을 자동으로 검사

---

#### 37. 점진적 솔루션 탐색 (Gradual Complexity Approach)

**설명**: 복잡한 솔루션에 투자하기 전에 가장 간단한 방식으로 시작하여 품질과 실현 가능성을 먼저 검증

---

#### 38. Ai Resilience Layer

**설명**: Claude가 엣지 케이스, 오류 해석, 사용자 경험을 위한 지능 레이어 제공

---

#### 39. 보안 인식 사용 (Security-Aware Usage)

**설명**: AI 에이전트가 실제 시스템 명령을 실행할 수 있으므로, 무엇이 실행되는지 항상 주의해야 합니다.

**예시**: Goose가 스크립트 실행을 제안할 때 내용을 먼저 확인 후 실행 결정

---

#### 40. Cursor Composer 활용

**설명**: Cursor의 Composer 기능(Cmd + I)을 사용하여 프로젝트 전체의 TypeScript 오류를 일괄 수정합니다.

**예시**: Cmd + I → "Fix all the typescript errors on my page"

---

#### 41. 단계별 검토 프롬프팅 (Step-By-Step Review)

**설명**: AI에게 단순히 "고쳐라"라고 명령하는 대신, 코드를 단계별로 검토하고 문제점을 식별하도록 요청합니다.

**예시**: "이 코드를 단계별로 검토하고, 각 단계에서 발생할 수 있는 문제점을 식별해줘"

---

#### 42. Ai 코드 검증 습관화

**설명**: AI가 생성한 코드의 오류를 식별하고 수정할 수 있는 능력이 필수입니다. 모든 AI 생성 코드는 철저한 리뷰가 필요합니다.

**예시**: AI 생성 코드에 대해 보안 취약점 검토 수행, 비즈니스 요구사항과의 일치 여부 확인

---

#### 43. 플랫폼 추상화 계층

**설명**: 프로그래밍 모델과 플랫폼 개념을 분리하여 애플리케이션 코드 변경 없이 로컬부터 고품질 서비스 환경까지 전환 가능합니다.

**예시**: 개발 시 로컬에서 테스트하고, 프로덕션에서는 클라우드 기반 고가용성 환경으로 배포

---

#### 44. 품질 모니터링

**설명**: SonarQube, CodeScene 등 도구를 활용한 AI 생성 코드 품질 추적

---

#### 45. 역할 기반 Ai 액세스 제어

**설명**: 개발자 경험 수준에 따라 AI 사용 권한을 차등 부여합니다. 주니어 개발자가 AI로 생성한 보안 관련 코드는 시니어 개발자의 리뷰를 필수로 거치도록 합니다.

**적용 조건**: 신규 개발자 온보딩 시

---

#### 46. Shift-Left 검증 전략

**설명**: 검토, 린트, 보안 검사를 최대한 왼쪽(개발 단계)으로 이동시킵니다.

**적용 조건**: AI 생성 코드의 품질 문제가 PR 리뷰 단계에서 자주 발견될 때

---

#### 47. Analyze_Claims 패턴 활용

**설명**: 입력된 주장에 대해 지지 증거, 반박 증거, 논리적 오류를 체계적으로 분석하고 신뢰도를 평가합니다.

**적용 조건**: 기술 논쟁 평가, 의사결정 전 주장 검증

---

#### 48. Create_Design_Document 패턴

**설명**: 간단한 프로젝트 설명을 입력하면 비즈니스 포스처, 리스크 분석, 보안 고려사항 등을 포함한 설계 문서를 자동 생성합니다.

**적용 조건**: 신규 프로젝트 시작 시

---

#### 49. Pre-Commit 단계 Ai 코드 리뷰

**설명**: AI 코드 리뷰를 PR 단계가 아닌 pre-commit 단계로 이동시킵니다.

**적용 조건**: AI가 생성한 코드의 품질을 조기에 검증하고 싶을 때

---

#### 50. 코드 품질 메트릭 모니터링

**설명**: SonarQube, CodeScene 같은 도구로 AI 사용 후 코드 품질 변화를 추적합니다.

**적용 조건**: AI 도입 효과를 객관적으로 측정하고 싶을 때

---

#### 51. 도구 비용 대비 가치 평가 프레임워크

**설명**: AI 도구 선택 시 생산성 향상, 코드 품질, 무제한 사용 여부 등을 종합적으로 평가합니다.

**적용 조건**: 팀 또는 개인의 AI 도구 선택 시

---

#### 52. 코드 사전 리뷰(Pre-Review)

**설명**: PR 제출 전 AI에게 먼저 코드 리뷰 요청하여 리뷰 라운드를 2.3회에서 1.2회로 단축.

---

#### 53. 모든 것을 측정

**설명**: 데이터로 회의론과 과도한 열정 모두를 해결. 기능 완료 시간, 버그 발생률, 코드 리뷰 라운드, 팀 만족도 추적.

---

#### 54. 8가지 역할 기반 팀 구성

**설명**: AI 아키텍트, 클라우드 제공사, AI 엔지니어, SI/도메인 벤더, 데이터 과학자, 개발자, 보안/컴플라이언스, 변화 관리

---

#### 55. Ai 기여 코드의 품질 기반 평가

**설명**: - 코드의 양(quantity)보다 질(quality) 중심 평가

---

#### 56. 주요 기법 (역방향 추출, 5개)

**설명**: 1. **AI 생성 코드 품질 검증 필수화**

---

#### 57. 실용적 대응 지침

**설명**: 1. 품질이 속도보다 중요

---

#### 58. 제외 단어 목록 활용

**설명**: 사용하지 않을 단어 목록으로 품질 관리

---

#### 59. Soc 체크리스트

**설명**: High Level vs Low Level, Business vs Infra 등 관심사 분리 검증 항목 명시.

---

#### 60. Rag 3단계 프롬프팅 패턴

**설명**: 검색 → 증강 → 생성 단계로 구조화하여 환각 감소.

---

#### 61. 네트워크 모니터링 보안 검증

**설명**: Net Limiter로 로컬 RAG에서 데이터 유출 여부 실시간 모니터링.

---

#### 62. 플러그인 간 성능 비교 평가

**설명**: Co-pilot과 Smart Second Brain의 응답 품질 체계적 비교.

---

#### 63. Api 키 보안 분리

**설명**: ChatGPT용과 임베딩용 별도 API 키 관리.

---

#### 64. 응답 소스 추적 및 인용

**설명**: 유사성 점수와 인용으로 AI 응답 신뢰도 검증.

---

#### 65. 성능 측정 기반의 의사결정

**설명**: 벤치마크로 객관적 효과 검증 (7분 → 0.5초, 메모리 74MB → 19MB).

---

#### 66. 보안 및 준수 기준 사전 정의

**설명**: OWASP Top 10, WCAG 2.1 AA, OpenAPI 3.0 규정 준수 명시.

---

#### 67. 다중 관점 코드 리뷰 프롬프트

**설명**: 보안/성능/시니어/신입 개발자 관점에서 동일 PR 검토.

---

#### 68. 구조화된 리뷰-계획 패턴

**설명**: `<CODE_REVIEW>` 태그로 분석 후 `<PLANNING>` 태그로 계획 수립.

---

#### 69. 사실 검증 및 한계 인식

**설명**: ChatGPT는 "글을 잘 쓰는 AI"이므로 사실성 더블체크 필요.

---

#### 70. 에러 핸들링 및 사용자 경험

**설명**: validation, loading states, tooltips 명시적 요청.

---

#### 71. 오디오 전사 오류 교정

**설명**: 음성 인식 오류를 맥락 단서로 추론하여 해석.

---

#### 72. Instructions 보호 기법

**설명**: GPT의 instructions를 사용자가 조회하지 못하도록 숨기는 보안 설정

**적용 조건**: 프롬프트 엔지니어링 노하우를 보호하거나 비즈니스 로직 노출 방지

---

#### 73. Api Key 보안 관리 (Schema Enum)

**설명**: OpenAPI 스키마에서 API key를 enum으로 하드코딩하여 GPT가 자동으로 사용하도록 설정

**적용 조건**: 개인용 GPT에서 API key를 매번 입력하지 않고 자동화하고 싶을 때

---

#### 74. Claude Artifacts Cors 우회 전략

**설명**: Claude Artifacts에서 API 호출 시 CORS 오류 발생 시 Repl.it 등 외부 플랫폼에서 실행

**적용 조건**: 브라우저 환경에서 외부 API 호출 시 CORS 정책으로 차단될 때

---

#### 75. 점진적 구현 전략 (Progressive Implementation Strategy)

**설명**: 본격적인 구현 전에 Mock API를 먼저 구축하여 인터페이스와 데이터 구조를 검증

**적용 조건**: 복잡한 API 개발 시작 시, 프론트엔드-백엔드 병렬 개발이 필요할 때

---

#### 76. 전문가 페르소나를 활용한 아웃라인 생성

**설명**: AI에게 경력이 풍부한 전문가 역할을 부여하여 고품질 콘텐츠 개요를 생성

**적용 조건**: 많은 아이디어가 있지만 구조화에 어려움을 겪을 때, 긴 글의 개요 작성 시

---

#### 77. 환각(Hallucination) 방지 기법

**설명**: LLM이 잘못된 정보를 생성하는 것을 방지하는 기법

**적용 조건**: 정확한 정보가 중요한 업무, 사실 기반 답변 필요 시

**예시**: "모르는 정보면 모른다고 확실히 대답해주세요"

---

#### 78. 감정적 미사여구 활용

**설명**: '제발', '꼭' 등의 미사여구나 상황 설명으로 답변 품질 향상

**적용 조건**: 중요한 작업, 고품질 답변 필요 시

---

#### 79. 검증 및 피드백 메커니즘 (Validation And Feedback Loop)

**설명**: AI에게 자체 검증과 불확실성 표현을 요구하여 신뢰성 향상

**적용 조건**: AI 응답의 정확성이 중요한 기술적 의사결정 시

---

#### 80. Ai Hallucination Verification

**설명**: AI가 제공하는 정보를 무조건 신뢰하지 않고, 중요한 결정이나 복구 작업 시 AI의 응답을 독립적으로 검증

**적용 조건**: AI가 시스템 상태나 복구 가능성에 대해 답변할 때, 위기 상황에서 AI의 조언을 받을 때

---

#### 81. Ai 기반 요구사항 검증

**설명**: AI에게 사양 문서 분석을 요청하여 모호성과 격차를 식별하고 실행 가능한 권장사항 제공

**적용 조건**: 새 프로젝트 시작 전, 요구사항 검토 단계

---

#### 82. 숫자 답변 3회 검증 규칙 (Triple Verification For Numbers)

**설명**: 숫자 관련 답변을 요청할 때 최소 3번 이상 물어봐서 변동성 파악. LLM의 환각 특성상 숫자 데이터는 특히 신뢰성이 낮음

**적용 조건**: 통계 데이터, 성능 수치, 날짜, 버전 정보 등 정확한 숫자 필요 시

---

#### 83. Ai 에이전트 보안 삼위일체 체크 (Lethal Trifecta Security Check)

**설명**: AI 에이전트 설계 시 "치명적인 삼위일체" 조건(개인 데이터 접근 + 신뢰할 수 없는 콘텐츠 노출 + 외부 통신 방법)이 동시에 충족되지 않도록 격리

**적용 조건**: AI 에이전트 아키텍처 설계, 보안 검토, AI 기반 자동화 시스템 구축

---

#### 84. 자동 메트릭 평가 및 최적화

**설명**: `dspy.evaluate.answer_exact_match`와 같은 메트릭으로 AI 시스템 출력 품질 정량 측정 및 최적화

**적용 조건**: AI 시스템 성능 객관적 측정 및 개선, 최적화 효과 검증

---

#### 85. Ai Hallucination 감소를 위한 명시적 명세 제공

**설명**: 테이블 형식의 Members 정의와 메서드별 Logic 설명을 구조화된 형태로 제공하여 AI가 "추측하지 않고" 명시된 규칙 구현

**적용 조건**: AI 생성 코드의 정확성 향상, hallucination 감소

---

#### 86. 사용자 확인 체크포인트

**설명**: AI가 작업을 시작하기 전 반드시 사용자에게 계획을 확인받는 단계를 포함하여 방향성 오류를 조기에 방지

---

#### 87. 3단계 보안 점검 워크플로우

**설명**: Plan → Execute → Security Check 순서로 진행하며, 기능 완료 시마다 보안 모범 사례 준수 여부를 AI에게 검토 요청

---

#### 88. Ai 퍼스트 패스 리뷰 워크플로우

**설명**: AI 에이전트가 보안 스캔, 스타일/아키텍처 적합성, 테스트 적절성, 스펙 체크 등 반복적인 첫 번째 리뷰를 담당하고, 인간은 아키텍처적 의도, 비즈니스 맥락, UX 검증 등 판단이 필요한 영역에 집중하는 역할 분담 모델

---

#### 89. Inner/Outer Loop 리뷰 구조

**설명**: Inner loop(개발자)에서는 로컬에서 `/review`, `/security-review` 슬래시 명령을 실행하고, Outer loop(CI)에서는 GitHub Actions가 헤드리스 모드로 Claude Code를 자동 실행하여 심각도에 따라 머지를 게이트하는 이중 루프 구조

---

#### 90. Kpi 기반 효과 측정

**설명**: PR 사이클 시간(목표 -25~40%), 리뷰 대기시간(목표 <30분), 누출된 결함, 재오픈율, 보안 사고율, 테스트/문서 업데이트 비율 등 객관적 지표로 AI 리뷰 시스템 효과성 측정

---

#### 91. Delta-Aware Editing

**설명**: diff 스타일 편집으로 전체 파일 대신 변경된 부분만 처리하여 토큰 오버헤드를 최소화하고 AI 환각(hallucination)을 감소시키는 기법

---

#### 92. 메모리 검증 루프 (Memory Verification Loops)

**설명**: 주기적으로 AI에게 무엇을 기억하는지 요약하도록 요청하여 메모리 정확성을 검증.

**적용 조건**: 중요한 기술 결정 후 확인, 장기 프로젝트에서 컨텍스트 드리프트 방지

---

#### 93. 점진적 오류 처리 및 자동 수정

**설명**: AI가 작업 중 발생하는 오류를 자동으로 탐지하고 분석 후 수정하여 재시도.

**적용 조건**: 자동화 스크립트, CI/CD 파이프라인

---

#### 94. Four-Step Validation Workflow

**설명**: Specify → Plan → Tasks → Implement의 4단계 검증 프로세스. 각 단계는 명확한 검증 지점 제공.

**적용 조건**: 대규모 프로젝트를 AI와 협업하여 개발

---

#### 95. Security & Compliance Integration In Specs

**설명**: 보안 정책, 컴플라이언스 규칙을 명세와 계획 단계에 초기부터 통합.

**적용 조건**: 엔터프라이즈 환경, 규제 산업

---

#### 96. 구조화된 템플릿을 통한 Llm 품질 향상

**설명**: 구조화된 템플릿으로 LLM 출력을 제약. `[NEEDS CLARIFICATION]` 마커로 추측 방지, 체크리스트로 완전성 검증.

**적용 조건**: LLM 출력 품질을 높이고 일관된 문서 형식

---

#### 97. 능동적 Ai 파트너십

**설명**: AI가 수동적 도구가 아닌 능동적 파트너로 작동. 비효율적 접근방식이나 보안 위험에 대해 반박.

**적용 조건**: 시니어 개발자의 코드 리뷰 역할, 주니어 멘토링

---

#### 98. Auto-Persona Activation

**설명**: 작업 유형에 따라 자동으로 적절한 전문가 페르소나를 활성화. `/analyze auth.js`는 보안 전문가 자동 호출.

**적용 조건**: 다양한 도메인 작업에서 최적의 컨텍스트 적용

---

#### 99. Multi-Aspect Code Analysis

**설명**: `/analyze` 명령이 보안, 성능, 품질을 동시에 자동 감지하고 분석.

**적용 조건**: 코드 리뷰, 레거시 코드 분석

---

#### 100. Systematic Troubleshooting Protocol

**설명**: `/troubleshoot` 명령이 증상 분석 → 가설 수립 → 검증 → 해결책 제시의 구조화된 접근.

**적용 조건**: 복잡한 버그, 예상치 못한 동작 진단

---

#### 101. Preview-Then-Apply Pattern

**설명**: `/improve --preview` 명령으로 변경사항을 미리 확인한 후 적용.

**적용 조건**: 대규모 리팩토링의 부작용 방지

---

#### 102. Validation-First Execution

**설명**: `--validate` 플래그로 모든 작업 실행 전에 자동 검증. 타입 체크, 린팅, 유닛 테스트 사전 실행.

**적용 조건**: CI/CD 파이프라인 통합, 고품질 코드 유지

---

#### 103. Focus-Driven Analysis

**설명**: `/analyze --focus architecture|security|quality` 명령으로 특정 관점에 집중한 분석.

**적용 조건**: 보안 감사, 성능 최적화, 아키텍처 평가

---

#### 104. Evidence-Based Ai Development Methodology

**설명**: AI 작업에 대해 문서화, 테스트, 메트릭, 보안 검증, 분석을 체계적으로 요구.

**적용 조건**: AI가 생성한 코드/설계의 품질과 근거 명확화

---

#### 105. Thinking Depth Control For Analysis Quality

**설명**: 작업 복잡도에 따라 AI의 사고 깊이를 3단계로 조절.

**적용 조건**: 빠른 응답 필요한 질문과 깊은 분석 필요한 작업 구분

---

#### 106. Production Issue Resolution Pattern

**설명**: 문제 분석 → 성능 리뷰 → 최적화 → 검증의 4단계 패턴.

**적용 조건**: 프로덕션 장애 대응

---

#### 107. Full-Stack Feature Development With Ai Components

**설명**: 프론트엔드 개발 → QA → 보안 검증을 페르소나와 함께 통합한 풀스택 워크플로우.

**적용 조건**: 전체 스택을 AI 도움으로 일관되게 개발

---

#### 108. Ai-Powered Code Review With Evidence-Based Recommendations

**설명**: QA 페르소나가 코드 품질을 분석하고 증거 기반 개선 권고사항 제공.

**적용 조건**: PR 리뷰 시 AI에게 초기 품질 검사

---

#### 109. Security Scan With Owasp And Dependency Checks

**설명**: OWASP 보안 기준과 의존성 취약점을 체계적으로 검사.

**적용 조건**: 배포 전 보안 취약점 검사

---

#### 110. Safe Database Migration With Dry-Run And Rollback

**설명**: DB 마이그레이션 계획을 미리 검증하고 롤백 전략 수립.

**적용 조건**: DB 스키마 변경의 리스크 감소

---

#### 111. Ai 러버덕 디버깅 (Ai Rubber Duck Debugging)

**설명**: AI에게 구현 접근법을 설명하는 과정 자체가 문제를 더 잘 이해하도록 돕는 러버덕 디버깅 효과를 제공합니다.

---

#### 112. 계획 기반 코드 리뷰 (Plan-Based Code Review)

**설명**: 최종 코드를 검토할 때 업데이트된 계획 문서를 참조하여 구현 중에 이루어진 기술적 선택에 대한 컨텍스트를 파악합니다.

---

#### 113. 휴먼인더루프(Human-In-The-Loop) 점진적 자동화

**설명**: AI의 환각(Hallucination) 문제를 해결하기 위해 초기에는 중요한 결정 단계마다 사용자 확인을 받고, AI가 학습하면서 점진적으로 자동화 범위를 확대하는 전략입니다.

---

#### 114. 보안과 샌드박스

**설명**: 샌드박스 환경 실행, AI 도구의 보안 경계 (277, 278)

---

#### 115. 보안 중심 테스트 계획 프롬프트

**설명**: AI에게 OWASP Top 10 취약점을 포함한 보안 중심 테스트 계획을 작성하도록 명시적으로 요청합니다.

---

#### 116. Ai 생성 코드 품질 평가 기준: 변경 용이성

**설명**: AI가 생성한 코드의 품질을 평가할 때 "변경 용이성"을 핵심 척도로 사용합니다.

---

#### 117. 저수준 작업 위임 (Fun)

**설명**: 타이핑, 문법 오류 수정, 보일러플레이트 코드 작성 등을 AI에 위임.

---

#### 118. Llm 언어 향상 도구 활용

**설명**: LLM을 영어가 모국어가 아닌 사용자의 글쓰기 품질 향상 도구로 활용.

---

#### 119. Llm 출력물 검증 필수 원칙

**설명**: LLM이 생성한 텍스트는 환각 현상으로 인해 오류가 있을 수 있으므로 철저한 검토와 검증이 필수.

---

#### 120. Ai 의존성 공급망 보안 관리

**설명**: AI 어시스턴트가 자동으로 가져오는 OSS 의존성에 대한 체계적인 감독.

---

#### 121. 기술 부채 속도(Velocity) 측정

**설명**: 취약점이 도입되고 수정되는 속도를 추적하고 스프린트 기반 SLA를 설정.

---

#### 122. Ai 커밋 추가 리뷰 프로세스

**설명**: AI가 생성한 커밋에 대해 별도의 추가 리뷰를 표시.

---

### Learning & Mindset (69개)

#### 1. Ai를 멘토로 활용

**설명**: 기능 구현 후 "시니어 엔지니어처럼 내가 작성한 기능과 코드를 상세히 설명해달라"는 프롬프트로 코드 학습 및 이해도 향상

**관련 도구**: Claude, ChatGPT, GitHub Copilot

**적용 조건**: AI 결과물의 품질을 보장해야 할 때

*출처: 4개 문서*

---

#### 2. 팀 표준화 구성

**설명**: `claude --config-file team-config.json`

**관련 도구**: Cursor AI

**적용 조건**: 프로토타이핑, 빠른 웹페이지 개발

*출처: 4개 문서*

---

#### 3. Ai를 "지식이 풍부한 주니어 개발자"로 인식

**설명**: AI를 마법같은 코드 생성기로 대하지 말고, Stack Overflow 데이터베이스 전체를 외운 주니어 개발자라고 생각. 기대치 조정이 효과적인 협업의 핵심.

*출처: 2개 문서*

---

#### 4. Ai 페어 프로그래밍 방식

**설명**: AI를 최종 검토자가 아닌 제안자로 취급합니다. 개발자가 AI의 제안을 비판적으로 검토하고 최종 결정을 내리는 협업 방식을 채택합니다.

**적용 조건**: 복잡한 기능 구현, 리팩토링, 아키텍처 변경 등 중요한 작업 시

*출처: 2개 문서*

---

#### 5. Ai 정기 교육 프로그램

**설명**: AI 도구가 발전함에 따라 모범 사례도 함께 발전합니다. 개발팀에 정기적인 AI 활용 교육을 제공합니다.

**적용 조건**: 분기별 개발자 교육 시

*출처: 2개 문서*

---

#### 6. Ai 활용의 경계

**설명**: 핵심 역량 훈련은 AI로 대체하지 말 것, 보일러플레이트 작업에 집중

*출처: 2개 문서*

---

#### 7. 추상화 레벨 상향

**설명**: 개별 파일 변경 → 전체 PR 변경 → 앱 구축 목표 순으로 점점 더 높은 추상화 레벨에서 작업하도록 역량 전환

*출처: 2개 문서*

---

#### 8. 페어 프로그래밍 마인드셋 적용

**설명**: Pull Request 스타일보다 페어 프로그래밍 스타일(높은 빈도의 상호작용, 유동적 역할 교체)로 LLM과 작업할 때 더 효과적입니다.

**예시**: 작은 단위로 나누어 LLM과 대화하며 점진적으로 구현 방향을 조정

---

#### 9. Skills 기반 능력 확장

**설명**: AI 모델에 새로운 능력을 부여할 때 Markdown 파일과 YAML 메타데이터, 선택적 스크립트를 폴더 형태로 제공하여 모델이 특정 작업 수행에 필요한 지침, 스크립트, 리소스에 접근하게 하는 방식

---

#### 10. 클라우드 Gpu 활용

**설명**: AWS나 Google Cloud의 GPU 인스턴스를 활용하여 딥러닝 학습 가속화

**관련 도구**: AWS EC2 GPU, Google Cloud ML

---

#### 11. Pre-Built Ai 서비스 활용 패턴

**설명**: 전문가 없이 기존에 학습된 AI 서비스를 API로 호출하여 프로젝트에 즉시 적용

**관련 도구**: AWS Comprehend, Personalize, SageMaker

---

#### 12. Ai와의 협업 워크스타일 전환

**설명**: AI를 "동료"로 인식하고 협업하는 방식으로 업무 패러다임 전환

**예시**: 월 200달러로 2만 달러 수익 창출하는 개인사업자들

---

#### 13. 포트폴리오 기반 역량 증명

**설명**: 학위나 경력보다 실제 성과물(포트폴리오)로 역량을 증명

**예시**: 3주 프로젝트로 성과를 증명하는 것이 30년 경력보다 중요

---

#### 14. 린 제조업 마인드셋 (Lean Manufacturing Mindset)

**설명**: 재고를 부채로 간주하는 린 제조업처럼, 코드도 재고로 인식하여 최소화 추구

**적용 조건**: 레거시 코드 정리, 새 프로젝트 설계 시

---

#### 15. 워크 차트 (Work Chart) 모델

**설명**: 기능 중심 조직도 대신 목표 중심으로 팀이 구성되는 역동적 모델. 영화 제작처럼 프로젝트별 맞춤형 팀 구성

**적용 조건**: 조직 구조 재편 시

---

#### 16. 서브에이전트 기반 전문화된 Ai 워크포스

**설명**: 특정 도메인에 전문화된 여러 서브에이전트를 팀처럼 운영

---

#### 17. Fine Tuning (파인튜닝)

**설명**: AI 모델을 특정 분야에 특화되도록 재학습

---

#### 18. Ai 의존도 조절 (Mute Ai)

**설명**: 학습 단계에서는 기본기 우선, AI 과의존 방지

---

#### 19. Ai 시대의 개발자 역할 재정의

**설명**: AI와 협업하며 발전하는 역할 이해

---

#### 20. 창의적 파트너로서의 Ai 활용

**설명**: 아이디어 생성, 선택지 탐색, 설계 개선 협업

---

#### 21. 베타 테스팅 기반 반복적 개선 문화

**설명**: MVP 빠르게 배포 → 사용자 피드백 수집 → 신속한 이터레이션

---

#### 22. Ai와의 협업자 마인드셋

**설명**: "인간 vs 기계"가 아닌 "AI를 잘 활용하는 인간"과의 경쟁으로 관점 전환

---

#### 23. 실수 기반 학습 업데이트

**설명**: AI 실수를 CLAUDE.md 등에 기록하여 반복 방지

---

#### 24. Ai 시대 개발자 하이브리드 학습 모델

**설명**: AI가 코드 생성, 인간이 코드 리뷰와 멘토링 담당

---

#### 25. Ai 한계 인식 기반 인간 역량 강화

**설명**: AI가 대체 어려운 영역(아키텍처, 멘토링)에 집중

---

#### 26. Renaissance Developer

**설명**: AI 시대의 다재다능한 개발자 마인드셋

---

#### 27. 코드베이스 패턴 학습

**설명**: 기존 코드베이스의 패턴을 학습하여 일관된 스타일로 정확한 구현을 제공

---

#### 28. 리포지토리 수준 플러그인 구성

**설명**: `.claude/settings.json`에 팀 플러그인을 정의하여 프로젝트 클론 시 자동으로 표준화된 환경 구성

---

#### 29. 멘토링 자료 구축

**설명**: 후배 개발자 지도를 위한 구조화된 지식 베이스를 구축

---

#### 30. 반복적 디버깅을 통한 Skill 개선

**설명**: AI가 생성한 결과물의 문제점을 분석하고, Skill 정의를 반복적으로 개선

---

#### 31. 범용 Skill 설계

**설명**: 특정 언어나 프레임워크에 종속되지 않고 다양한 코드베이스에서 동작하는 범용 Skill을 설계

---

#### 32. 스킬 디렉토리 구조 표준화

**설명**: `.claude/skills/` 디렉토리 아래 각 스킬별 디렉토리를 만들고 표준 구조로 조직화

---

#### 33. Skills 시스템

**설명**: 마크다운 기반 지식 전달, Progressive Disclosure Architecture, 스킬 조합

---

#### 34. 도메인 어휘 명시 (Ubiquitous Language)

**설명**: LLM과 작업할 때 팀의 공유 도메인 어휘를 명시적으로 제공하지 않으면, 모델이 의미를 추측해야 하므로 비효율적입니다.

**예시**: 프롬프트에 "우리 시스템에서 'Order'는 주문 생성부터 배송 완료까지의 전체 생명주기를 나타내며..."와 같이 도메인 용어 정의 포함

---

#### 35. 작업 어휘 구축 협업 (Growing A Language)

**설명**: Guy Steele의 개념에 따라, 도메인에서 확립된 개념을 차용하고 잘 알려진 패턴을 활용하여 공유 언어 체계를 형성합니다.

**예시**: "Repository 패턴을 사용해서...", "Factory 메서드로 생성하고..." 등 표준화된 패턴 용어를 프롬프트에 활용

---

#### 36. Ai 실패를 학습 기회로 전환

**설명**: AI가 해결책을 제시하지 못했을 때, 그 과정에서 시스템이 실제로 어떻게 작동하는지 이해하는 기회로 활용합니다.

**예시**: AI가 파티션 오프셋 계산에 실패했을 때, 직접 관련 문서를 읽고 원리를 이해

---

#### 37. 페어 프로그래밍 방식의 Ai 협업

**설명**: 엔지니어와 페어 프로그래밍할 때처럼 AI와 협력하여 근본 원인을 찾고, 문제를 이해하며, 수정사항을 반복적으로 개선합니다.

**예시**: "이 문제의 근본 원인이 무엇이라고 생각해? 함께 분석해보자"

---

#### 38. "잘못된 방향" 로그 유지 및 주간 회고

**설명**: AI 생성 코드가 팀에 마찰을 일으키거나 유지보수성에 영향을 미친 이벤트를 로그로 유지하고, 주간 회고합니다.

**적용 조건**: AI 도구 도입 초기

---

#### 39. Ai 도입 시 팀 문화 관리

**설명**: 높은 신뢰와 심리적 안전성을 가진 팀에서 개발자들은 AI 채택의 과제를 공유하고 더 빨리 배울 수 있습니다.

**적용 조건**: 조직 차원에서 AI 도구를 도입할 때

---

#### 40. 영향 범위별 Ai 실수 모니터링

**설명**: AI 실수를 세 가지 수준(커밋/팀/코드베이스)으로 분류하여 모니터링합니다.

**적용 조건**: AI 도입 후 품질 저하를 체계적으로 추적하고 싶을 때

---

#### 41. 팀 문화 균형 조성

**설명**: AI 회의론자와 열광자 모두를 포용하는 문화를 조성합니다. 현실적인 생산성 향상 기대치는 8-13% 수준입니다.

**적용 조건**: 팀에 AI 도구를 도입할 때

---

#### 42. Ai 활용의 경계 설정

**설명**: 핵심 역량 훈련(코딩의 설계 능력, 글쓰기의 논리력)은 AI로 대체하지 말 것

---

#### 43. Ai 시대 필수 역량 개발

**설명**: - 비판적 사고력, 문제 해결 능력, 창의성, 학습 마인드셋

---

#### 44. Ai 위임 원칙 수립

**설명**: - 팀 차원에서 "AI에게 무엇을 위임하고 무엇을 절대 위임하지 않을지" 원칙 세트 수립

---

#### 45. 이론 멘토(Theory Mentor) 지정

**설명**: - 새로운 팀원에게 코드베이스뿐만 아니라 "이론"을 전수하는 멘토 시스템

---

#### 46. 비대칭 엔지니어링 마인드셋

**설명**: "시스템을 구축하는 시스템"을 만드는 사고방식

---

#### 47. Ai와 협업하는 문제 해결 능력

**설명**: 코드 작성보다 시스템 설계, 프롬프트 작성 능력으로 역량 재정의.

---

#### 48. 단계별 팀 온보딩 로드맵

**설명**: 1주차(개인) → 2주차(팀) → 3주차(고급)로 점진적 도입.

---

#### 49. 예제 기반 학습 (Example-Based Learning)

**설명**: Before/After 예제를 제공하여 AI가 원하는 스타일과 품질을 학습하도록 유도

**적용 조건**: 특정 코딩 스타일이나 패턴을 AI에게 명확히 전달하고자 할 때

---

#### 50. 실험 및 워크플로우 관찰 학습법 (Experimental Learning Approach)

**설명**: LLM 활용 능력을 높이기 위해 다른 사람들의 워크플로우 세부사항을 관찰하고, 직접 실험하며, 경험 공유

**적용 조건**: AI 도구 도입 초기, 새로운 LLM 기능 탐색, 팀 내 AI 활용 역량 강화

---

#### 51. Genie Metaphor Mindset

**설명**: AI를 "예측 불가능한 지니"로 인식. 비결정적 특성을 이해하고 대응 전략 수립

**적용 조건**: AI 코딩 도구 사용 시 기대치 적절히 설정, 예상치 못한 결과 대비

---

#### 52. Experiment-Based Prototyping

**설명**: AI를 활용하여 10배 많은 실험을 빠르게 시도. "완료된 실험을 버리는 것"에 대해 칭찬하는 문화

**적용 조건**: 새로운 아이디어 검증, 빠른 프로토타이핑, 기술적 가능성 탐색

---

#### 53. 4단계 학습 사이클

**설명**: Plan → Build → Security → Learn의 사이클을 반복하여 개발과 학습을 병행하는 습관 형성

---

#### 54. 점진적 게이팅 롤아웃 전략

**설명**: 섀도우 모드(1주차: 게이트 없이 실행) → 라이트 게이트(2주차: critical만 차단) → 범위 확장(3주차: Playwright, SBOM 추가) → 제도화(4주차: 머지 정책화)의 4단계로 팀 저항 최소화

---

#### 55. 조직 암묵지의 명시화

**설명**: 경험 많은 개발자의 노하우, 문제 해결 방법, 최적화 전략 등을 Skills로 포착하여 조직 전체가 재사용 가능한 AI 활용 지식으로 전환

---

#### 56. 기술 기반 위에서의 창의성 발휘

**설명**: 코딩 언어, 컴파일러, 런타임, 시스템 설계 등 기술 기반은 여전히 학습해야 하며, 그 위에서 스타트업/제품 아이디어를 구현하는 창의성을 발휘

---

#### 57. 오케스트레이터 Vs 모놀리식 에이전트

**설명**: 마스터 에이전트가 조정하는 각각 집중된 강점을 가진 AI 팀 구성. 복잡한 작업을 여러 전문화된 에이전트로 분산

---

#### 58. `/Share` 명령을 통한 Ai 대화 공유

**설명**: `/share` (Ctrl+X+S) 명령으로 현재 AI 세션의 URL을 클립보드에 복사하여 팀원과 공유.

**적용 조건**: AI가 제안한 솔루션을 팀원과 논의할 때

---

#### 59. Pedagogical Explanation Mode

**설명**: `/explain` 명령과 `mentor` 페르소나로 교육적으로 설명. 학습 중심의 상세한 설명 제공.

**적용 조건**: 팀원 온보딩, 복잡한 코드 리뷰, 새로운 패턴 학습

---

#### 60. Ai 컴패니언 기반 초개인화 교육

**설명**: 평생 동안 학습자와 함께 성장하는 AI 컴패니언 형태의 교육 시스템입니다.

---

#### 61. Ai 데이터 축적 전략

**설명**: 월 100만 건 이상의 상품 처리 데이터를 지속적으로 축적하고, 이를 통해 AI 모델을 학습시켜 4년간 성능을 3배 향상시킴.

---

#### 62. 아키텍처 중심 Ai 협업 (Architecture-First Ai Collaboration)

**설명**: AI와 협업할 때 코딩 능력보다 디자인 패턴과 아키텍처적 사고를 우선시합니다.

---

#### 63. Claude.Md 파일을 통한 코딩 가이드라인 제공

**설명**: claude.md 파일에 팀의 코딩 가이드라인과 컨벤션을 저장하여 AI가 일관된 코드를 생성하도록 합니다.

---

#### 64. 학습 및 역량 개발

**설명**: AI 기반 맥락적 학습, AI 보안 위험 교육, 하이브리드 역량 개발 (282, 286)

---

#### 65. 슈퍼 인턴 협업 모델

**설명**: AI를 "손이 굉장히 빠른 인턴"으로 비유하여, 빠른 작업 수행 능력을 활용하되 개발자가 관리.

---

#### 66. 세분화된 Ai 협업 개발

**설명**: AI와의 협업 시 범위를 좁게 유지하고 한 번에 하나의 동작에만 집중.

---

#### 67. 빠른 "완료" 증분 전략

**설명**: AI와 협업 시 작은 단위의 "완료된" 증분을 신속하게 생산.

---

#### 68. 협업 마찰 감소를 위한 Ai 활용 (Autonomous)

**설명**: 다수의 팀원과 협업 시 발생하는 마찰을 AI를 활용하여 감소.

---

#### 69. 하이브리드 기술 역량 개발

**설명**: 개발자가 레거시 맥락에서 AI 생성 변경사항을 검증하는 방법을 학습.

---

## TOP 30 핵심 기법

출처 문서가 많은 순으로 선정한 핵심 기법입니다.

| # | 기법명 | 카테고리 | 출처 수 |
|---|--------|----------|--------|
| 1 | mcp 생태계 확장 | Prompt Engineering | 10 |
| 2 | pr 문서화 | AI-Assisted Development | 10 |
| 3 | human-in-the-loop 확인 패턴 | Agent & Workflow | 9 |
| 4 | mcp(model context protocol) 기반 워크플로우 생성 | Tools & Integration | 8 |
| 5 | 보안 검토 프롬프트 | Quality & Security | 7 |
| 6 | rag 패턴 | Prompt Engineering | 6 |
| 7 | 스펙 주도 개발 (spec-driven development) | AI-Assisted Development | 6 |
| 8 | 출력 형식 명시 | AI-Assisted Development | 6 |
| 9 | ddd + ai 통합 | Prompt Engineering | 6 |
| 10 | 보안 리뷰 자동화 | Quality & Security | 5 |
| 11 | 자율적 에이전트 오케스트레이션 | Agent & Workflow | 5 |
| 12 | 프롬프트 체이닝 | Prompt Engineering | 5 |
| 13 | 모델별 역할 분리 | AI-Assisted Development | 5 |
| 14 | ai 기반 qa | AI-Assisted Development | 5 |
| 15 | 계획 우선 접근법 | AI-Assisted Development | 5 |
| 16 | 파일 구조 자동 생성 | Tools & Integration | 5 |
| 17 | claude code 도구 생태계 | Tools & Integration | 5 |
| 18 | ai를 멘토로 활용 | Learning & Mindset | 4 |
| 19 | 팀 표준화 구성 | Learning & Mindset | 4 |
| 20 | claude.md 파일로 컨텍스트 제공 | Prompt Engineering | 4 |
| 21 | 세션 연속성 관리 | AI-Assisted Development | 4 |
| 22 | 투명한 변경 추적 | Agent & Workflow | 4 |
| 23 | 문서 청킹 전략 | AI-Assisted Development | 4 |
| 24 | rag 기반 지식베이스 구축 | Tools & Integration | 4 |
| 25 | 단계적 사고 유도 | AI-Assisted Development | 4 |
| 26 | vibe coding 리스크 관리 | Prompt Engineering | 4 |
| 27 | sdd 워크플로우 | Agent & Workflow | 4 |
| 28 | 컨텍스트 체이닝 (context chaining) | Prompt Engineering | 3 |
| 29 | 동적 테스트 적응 | Prompt Engineering | 3 |
| 30 | 롱 컨텍스트 채팅 | Prompt Engineering | 3 |

---

## 주요 도구별 기법

| 도구 | 관련 기법 수 |
|------|------------|
| Claude Code | 20 |
| Claude | 18 |
| Chatgpt | 16 |
| Cursor Ai | 12 |
| Cursor | 6 |
| Github Copilot | 4 |
| N8N | 4 |
| Obsidian | 3 |
| Git | 3 |
| 모든 Llm | 3 |

