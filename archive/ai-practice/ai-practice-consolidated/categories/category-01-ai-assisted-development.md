# AI-Assisted Development 심층 분석

**생성일**: 2026-01-04
**기법 수**: 574개
**전체 비율**: 40.9%

## 개요

AI 도구를 활용한 개발 방법론입니다. TDD+AI, Spec-Driven Development, Vibe Coding 등
AI와 함께 코드를 작성하고 검증하는 실천적 기법들을 다룹니다.

---

## 핵심 기법 TOP 10

| # | 기법명 | 출처 수 | 주요 도구 |
|---|--------|--------|----------|
| 1 | pr 문서화 | 10 | - |
| 2 | 스펙 주도 개발 (spec-driven development) | 6 | - |
| 3 | 출력 형식 명시 | 6 | - |
| 4 | 모델별 역할 분리 | 5 | - |
| 5 | ai 기반 qa | 5 | - |
| 6 | 계획 우선 접근법 | 5 | - |
| 7 | 세션 연속성 관리 | 4 | - |
| 8 | 문서 청킹 전략 | 4 | - |
| 9 | 단계적 사고 유도 | 4 | - |
| 10 | 점진적 도입 전략 | 3 | - |

## 기법 관계도

```mermaid
mindmap
  root((AI-Assisted Developm))
    기타
      pr 문서화
      출력 형식 명시
      모델별 역할 분리
    명세 기반
      스펙 주도 개발 (spec-drive
    테스트 기반
      tdd red-green-refact
```

## 실무 적용 체크리스트

- [ ] CLAUDE.md 파일에 프로젝트 규칙 정의
- [ ] TDD 사이클에 AI 통합 (Red: 개발자, Green/Blue: AI)
- [ ] Spec-First 접근법 적용 (코드 전 명세 작성)
- [ ] AI 생성 코드 리뷰 프로세스 수립
- [ ] 테스트 커버리지 목표 설정 및 모니터링

## 학습 경로

### 입문 (1-2주)

- **pr 문서화**: Claude에게 직접 PR 생성을 요청하면 변경사항, 테스트 세부정보, 잠재적 위험을 포함한 포괄적 PR 생성...
- **스펙 주도 개발 (spec-driven development)**: 코드를 먼저 작성하는 대신 명세서(specification)를 먼저 작성하는 개발 방법론입니다. AI 에이전트가 명확한 문서를 기반으로 작업을 ...
- **출력 형식 명시**: `<format>` 또는 `<output_format>` 태그를 사용하여 원하는 출력 형식을 명확히 지정...
- **모델별 역할 분리**: Plan Mode에는 Opus(추론 강화), Execution Mode에는 Sonnet(실행 효율)을 사용하여 각 모델의 강점을 활용...
- **ai 기반 qa**: 예측 분석, 테스트 자동 생성, 리스크 기반 테스팅, 자가 치유 테스트...

### 중급 (3-4주)

- **계획 우선 접근법**: SPARC 방법론, Plan Mode, Plan-First Execution (275, 277, 278)...
- **세션 연속성 관리**: `-c`와 `-r` 플래그를 사용해 이전 대화를 이어가거나 특정 세션을 선택하여 문맥을 유지...
- **문서 청킹 전략**: RAG 시스템에서 문서를 임베딩 모델이 처리할 수 있는 적절한 크기로 분할하는 기법. 단순 문장 분할, 고정 크기 청킹, 오버래핑 청킹 등...
- **단계적 사고 유도**: "Take a step back and think step-by-step about how to achieve the best possible ...
- **점진적 도입 전략**: 작게 시작. 전사적인 미팅에서 발표하지 말고 소규모 파일럿으로 시작....

### 고급 (5주+)

- **계획 모드(plan mode) 활용**: 중간 난이도 작업에서는 Shift + Tab으로 계획 모드에 진입, Claude와 계획을 먼저 정렬한 후 자동 수락 모드로 구현 진행...
- **바이브 코딩의 제한적 활용**: 코드를 직접 보지 않고 AI에게 원하는 것만 말하는 "바이브 코딩"은 빠른 프로토타입에만 한정합니다....
- **반복적·점진적 개발 프로세스**: 요구사항 → 도메인 모델링 → 유스케이스 → TDD → 통합....
- **sparc 방법론**: AI 기반 개발을 위한 구조화된 접근법 - Specification(명세) → Pseudocode(의사코드) → Architecture(아키텍처...
- **동적 상호작용 설계**: 코드베이스와 동적으로 상호작용, 좋은 테스트와 모듈식 코드베이스에서 성능 향상....

---

## 관련 도구

- Claude Code
- Cursor
- GitHub Copilot
- Jest
- pytest

## 전체 기법 목록

<details>
<summary>574개 기법 펼치기</summary>

1. **pr 문서화**: Claude에게 직접 PR 생성을 요청하면 변경사항, 테스트 세부정보, 잠재적 위험을 포함한 포괄적 PR 생성
2. **스펙 주도 개발 (spec-driven development)**: 코드를 먼저 작성하는 대신 명세서(specification)를 먼저 작성하는 개발 방법론입니다. AI 에이전트가 명확한 문서를 기반으로 작업을 수행하도록 하여 5배의 생산성 향상을
3. **출력 형식 명시**: `<format>` 또는 `<output_format>` 태그를 사용하여 원하는 출력 형식을 명확히 지정
4. **모델별 역할 분리**: Plan Mode에는 Opus(추론 강화), Execution Mode에는 Sonnet(실행 효율)을 사용하여 각 모델의 강점을 활용
5. **ai 기반 qa**: 예측 분석, 테스트 자동 생성, 리스크 기반 테스팅, 자가 치유 테스트
6. **계획 우선 접근법**: SPARC 방법론, Plan Mode, Plan-First Execution (275, 277, 278)
7. **세션 연속성 관리**: `-c`와 `-r` 플래그를 사용해 이전 대화를 이어가거나 특정 세션을 선택하여 문맥을 유지
8. **문서 청킹 전략**: RAG 시스템에서 문서를 임베딩 모델이 처리할 수 있는 적절한 크기로 분할하는 기법. 단순 문장 분할, 고정 크기 청킹, 오버래핑 청킹 등
9. **단계적 사고 유도**: "Take a step back and think step-by-step about how to achieve the best possible results"
10. **점진적 도입 전략**: 작게 시작. 전사적인 미팅에서 발표하지 말고 소규모 파일럿으로 시작.
11. **계획 모드(plan mode) 활용**: 중간 난이도 작업에서는 Shift + Tab으로 계획 모드에 진입, Claude와 계획을 먼저 정렬한 후 자동 수락 모드로 구현 진행
12. **바이브 코딩의 제한적 활용**: 코드를 직접 보지 않고 AI에게 원하는 것만 말하는 "바이브 코딩"은 빠른 프로토타입에만 한정합니다.
13. **반복적·점진적 개발 프로세스**: 요구사항 → 도메인 모델링 → 유스케이스 → TDD → 통합.
14. **sparc 방법론**: AI 기반 개발을 위한 구조화된 접근법 - Specification(명세) → Pseudocode(의사코드) → Architecture(아키텍처) → Refinement(개선) →
15. **동적 상호작용 설계**: 코드베이스와 동적으로 상호작용, 좋은 테스트와 모듈식 코드베이스에서 성능 향상.
16. **ai 기술 부채 관리**: 코드를 이해하지 못하면 AI에게 수정을 요청할 수밖에 없는데, 이는 기술 부채가 축적되는 원인이 됩니다.
17. **바이브 코딩 (vibe coding) 접근법**: 자연어로 요구사항을 설명하면 AI가 구현 세부사항을 처리하는 개발 방식입니다. 개발자는 "무엇을 원하는지"를 설명하고, AI가 "어떻게 구현할지"를 담당합니다.
18. **tdd red-green-refactor + ai 워크플로우**: (1) 실패하는 테스트 작성(Red), (2) 테스트 통과하는 최소 코드(Green), (3) 코드 정리(Refactor)를 AI와 함께 수행
19. **점진적 복잡성 증가 프롬프팅**: "Explain with gradually increasing complexity" 패턴으로 단계별 이해.
20. **3: claude taskmaster를 통한 작업 분해**: 복잡한 기능 명세를 PRD와 단계별 실행 가능한 태스크로 자동 분해
21. **출력 형식 최적화**: `--output-format json/text/stream-json`
22. **출력 구조 사전 정의**: 8개 섹션(아키텍처, 백엔드, 프론트엔드, DB, 테스트, 문서 등)의 결과물 구조 미리 정의.
23. **반복적 ddd 기반 개발**: 유비쿼터스 언어, 엔티티 등 DDD 개념을 명확히 AI에 전달.
24. **구체적 예시 요청**: 실제 코드 예시나 의사코드 포함 지시로 실무 적용 가능성 향상.
25. **단계적 작업 분해 요청**: 복잡한 기능 요청 시 Claude가 스스로 작업을 분해하여 "Thinking.." 과정에서 단계별로 계획을 수립하도록 유도
26. **스크린샷 직접 입력**: `Ctrl+V`로 스크린샷을 직접 붙여넣어 시각적 맥락을 제공하는 멀티모달 입력 방식
27. **다중 파일 동시 수정**: 관련된 여러 파일을 한 번의 요청으로 일관되게 수정하여 코드 일관성 유지
28. **비용 최적화 전략**: 종량제에서 정액제(Max)로 전환하여 비용 걱정 없이 다양한 시도가 가능
29. **xml 구조화 프롬프팅**: Claude가 XML 형식의 구조화된 데이터로 훈련되었으므로, XML 태그를 사용하면 Claude의 "네이티브 언어"로 소통
30. **점진적 설정 검증 워크플로우**: 설치 → 다운로드 → 서버 활성화 → 플러그인 연결 → 테스트 순차 검증.
31. **ai 기반 브레인스토밍**: 기존 노트와 아이디어를 AI에게 제공하고 새로운 콘텐츠 제안, 관련 주제 탐색, 문서 구조화 제안을 받습니다.
32. **ai 거버넌스**: 역할 기반 AI 액세스 제어, 출처 추적, 정기 감사 등 조직 차원의 AI 관리
33. **faafo 프레임워크**: Fast, Ambitious, Autonomous, Fun, Optionality의 5가지 가치 체계.
34. **로컬 llm 배포**: Ollama, Open Web UI를 통한 오프라인 AI 환경 구축
35. **ai 생성 코드 주의 깊은 검토**: AI가 생성한 코드를 커밋 전에 항상 꼼꼼히 검토해야 합니다. 무비판적 수용은 금물입니다.
36. **ai 행동 지침 프롬프트 커스터마이징**: 글로벌 규칙 파일에 SOLID 원칙, 클린 아키텍처, TDD 등의 개발 원칙을 명시하여 AI가 일관된 품질의 코드를 생성하도록 지시.
37. **씽킹 모드 활용**: `"think"`, `"think harder"`, `"ultra think"` 명령어
38. **대량 피드백 처리**: - AI로 대량의 피드백과 분석을 처리하여 숨겨진 상관관계 발견
39. **ai 린터로 활용**: `claude -p 'you are a linter...'` 형태로 빌드 스크립트에 AI 린팅 추가
40. **사용자 정의 슬래시 명령어**: `.claude/commands/` 디렉토리에 Markdown 파일로 재사용 가능한 명령어 생성, `$ARGUMENTS` 플레이스홀더로 인수 전달 가능
41. **식사 계획 전문가**: 선호도와 영양 목표 기반 식단 계획 수립
42. **아티팩트 형식 지정**: 최종 결과물을 마크다운 형식으로 출력하도록 명시적 지시.
43. **네이밍 규칙 상세화**: 변수명, 메서드명이 "문장처럼 읽혀야 한다"는 원칙과 구체적 예시 제시.
44. **dsl 기반 테스트 작성**: Fluent Interface로 테스트 코드를 비즈니스 언어 수준으로 작성.
45. **vibe coding 스펙트럼 활용**: Vibe coding은 코드 이해도에 따른 스펙트럼입니다. 자신의 기술 수준에 맞게 AI 의존도를 조절해야 합니다.
46. **패턴 기반 아키텍처 리팩토링**: PoEAA 같은 검증된 설계 패턴 활용하여 극적 성능 향상.
47. **이중 리팩토링 주기**: "r"-efactor(로컬 경량 리팩토링)와 "R"-efactor(시스템 전체 광범위 리팩토링) 구분.
48. **벡터 임베딩 기반 의미 검색**: 단어나 문장을 벡터로 변환하여 의미적 관계를 수학적으로 계산하는 기법. 코사인 유사도, 유클리디안 거리, 내적 사용
49. **tokentextsplitter를 활용한 문서 분할**: 대용량 텍스트를 토큰 기반으로 적절한 크기로 분할하여 임베딩 생성 및 검색 효율성 향상
50. **자연어 기반 테스트 케이스 생성**: 자연어 시나리오를 설명하면 AI가 자동으로 Playwright 스크립트를 생성합니다. 비개발자도 테스트 자동화에 참여 가능합니다.
51. **자가 치유 테스트 (self-healing tests)**: MCP로 구동되는 GenAI가 DOM을 실시간으로 분석하여 UI 변경사항에 자동으로 적응합니다.
52. **iterative spec refinement**: Agile 방식으로 각 이터레이션마다 명확한 사양을 정의하고 검증하는 접근법
53. **ai as pair programmer**: AI를 검색 엔진처럼 대하지 않고 페어 프로그래머로 활용. 개발자는 방향 설정, AI는 코드 작성 담당.
54. **tdd 기반 ai 코드 생성**: AI 에이전트에게 "using TDD in Python"이라고 지시하여 테스트 주도 개발 방식으로 코드를 생성합니다.
55. **ai 논리 설명 요청**: 변경사항 이해 못할 때 AI에게 논리 설명 요청
56. **체크포인트 (checkpoints)**: 작업 진행 상황을 자동 저장하고 이전 상태로 즉시 롤백할 수 있는 기능
57. **generator 패턴 (생성기 스킬)**: 사용자 설명으로부터 콘텐츠를 생성하는 스킬 패턴
58. **스크립트 자동 생성 (script auto-generation)**: AI에게 원하는 기능을 설명하면 컬러 출력, 체크마크 등을 포함한 정교한 쉘 스크립트를 자동 생성합니다.
59. **결정론적 스크립트**: LLM 대신 확정적 결과가 필요한 단계에서 셸 스크립트 활용
60. **의도 내장 커밋 메시지**: - "무엇이 변경되었나?" 대신 "왜 변경되었나?"에 답하는 커밋 메시지
61. **specification의 코드화 (specification as code)**: - Markdown 기반 살아있는 문서(living document)로 관리
62. **deliberative alignment 기법**: - Specification과 도전적 입력 프롬프트 세트를 준비
63. **피드백 루프 순환**: 계획 → 비판 → 테스트 → 구현 → 검토의 순환적 과정.
64. **단계별 가이드 요청**: "프로젝트 생성부터 단계별로" 복잡한 작업 체계적 분해.
65. **openapi schema 자동 생성 기법**: GPT에게 API curl 명령어를 제공하고 OpenAPI 스키마를 자동 생성하도록 요청
66. **체인 오브 쏘트(chain of thought) - 단계별 사고**: "단계별로 생각해서 문제를 풀어줘" 지시로 복잡한 문제 해결
67. **역할 기반 전문가**: 영양사, 피트니스 코치, 번역가 등 20가지 활용 사례
68. **markdown-first 양방향 문서 생성**: Markdown을 진실의 원천으로 두고, AI/스크립트가 Java 코드와 Excel 보고서 모두 자동 생성
69. **test-driven generation (tdg)**: 개발자가 먼저 테스트를 작성하고, AI가 해당 테스트를 통과하는 구현 코드 생성. Red-Green-Refactor에서 Green 단계를 AI가 담당
70. **마크다운 네이티브 작업 관리**: 모든 작업을 순수 마크다운 파일로 관리하여 AI가 쉽게 읽고 수정할 수 있는 구조 제공 (AI 친화적 데이터 포맷)
71. **prd 기반 자동 작업 분해 (prd-to-task decomposition)**: 자연어로 작성된 제품 요구사항 문서(PRD)를 AI가 파싱하여 실행 가능한 작업 목록으로 자동 변환하는 기법입니다. 작업 종속성 매핑과 일관된 작업 생성이 포함됩니다.
72. **업무/생활 패턴 변화 수준의 ai 활용**: 본인의 업무나 생활 패턴이 바뀔 정도로 AI를 활용하는 것
73. **ai 대체 가능성 자가 진단법**: 업무의 AI 대체 가능성을 "조직이 대체하려는 의지를 가질 만큼 단순한가"를 기준으로 판단
74. **업무 가치 네트워크 분석법**: 내 업무의 "카운터파티"를 파악하여 업무의 가치와 지속 가능성을 평가
75. **이식 가능한 스킬 포트폴리오 구축법**: 조직 밖에서도 통용되는 역할과 스킬을 개발
76. **100x employee 영향력 확대 기법**: AI 리터러시가 높은 개발자가 조직 전체를 돕고 가이드하여 전체 생산성 향상
77. **tdd + ai 통합 워크플로우 (kent beck 스타일)**: 테스트를 의사소통 수단으로 활용. 테스트 먼저 작성, AI가 구현, 테스트로 검증
78. **계획 수립 후 실행 패턴**: "이 버그를 고쳐줘" 대신 "주변을 검색해서 원인을 파악하고 어떻게 고칠지 계획을 알려줘"로 요청
79. **스마트한 페어 코딩 (tdd + 정기 커밋)**: 테스트 주도 개발, 작은 변경 후 테스트 실행, TypeScript/린팅 검사, 정기적 커밋으로 문제 시 롤백 가능
80. **여러 claude 인스턴스 동시 실행**: tmux나 다른 탭에서 4개까지 Claude 인스턴스를 동시 실행하며 오케스트레이션
81. **escape 키 활용**: Claude가 잘못된 방향으로 갈 때 Escape로 중단하고 개입, 두 번 누르면 대화에서 뒤로 이동
82. **코드는 부채, 기능성이 자산 (code as liability)**: 코드 자체를 자산으로 보지 않고, 기능성(Functionality)만을 진정한 자산으로 인식. 한 줄도 작성하지 않고 기능을 달성할 수 있다면 더욱 좋음
83. **ai 기반 노트 참조 및 수정**: @ 기호로 다른 노트나 폴더를 참조하여 AI가 여러 문서 맥락을 이해하고 응답 생성
84. **커스텀 ai 모델 추가**: 기본 제공되지 않는 최신 AI 모델(예: Gemini 2.5)을 사용자 정의로 추가하여 활용
85. **implementation detail 구조화**: 아키텍처 결정, 설계 패턴, 구현 제약사항을 상세히 명세하여 LLM의 정확한 코드 생성 유도
86. **constraint(제약 조건) 명시**: DO NOT(금지 사항)과 MUST DO(필수 사항)를 명확히 정의하여 할루시네이션 방지
87. **아규먼티드 코딩 (augmented coding)**: 단순히 작동하는 코드가 아닌 "작동하는 깔끔한 코드(Working Clean Code)"를 목표로 AI와 협업
88. **ai 잘못된 방향 신호 감지**: 코드 반복, 요청하지 않은 기능 구현, 테스트 삭제/비활성화 등이 AI가 잘못 가는 신호
89. **claude 커스텀 커맨드로 tdd 자동화**: /tdd:go 명령어로 Red-Green-Refactor 사이클 자동 실행, plan.md로 진행 상황 추적
90. **self-pr과 피드백 요청**: 매니저에게 승진/보상 욕구를 명확히 표현하고 피드백을 적극적으로 요청
91. **명확한 no + 대안 제시**: "그때까지 힘들지만, 이 기능 중 정말 중요한 것이 무엇인지 알려주시면 그것은 먼저 해볼 수 있습니다"
92. **영향력 = 곱하기와 빼기**: 혼자 일하기(더하기) 대신 함께 일하기(곱하기)와 불필요한 일 안 하기(빼기)로 영향력 확대
93. **올바른 산 확인 후 효율적 노력**: 엉뚱한 산을 열심히 오르지 말고, 먼저 어느 산으로 갈지 확인한 후 효율적으로 노력
94. **리퍼럴 기반 채용 네트워크**: 이력서 AI 필터링 시대에 컨퍼런스, 해커톤, 채용 담당자 만남 등 인간관계 투자가 핵심
95. **테스트 스위트 생성기**: 기능적 정확성, 성능 특성, 통합 지점, 보안 고려 사항 등 카테고리별 포괄적 테스트 생성
96. **코드 마이그레이션 프레임워크**: 비즈니스 로직 유지, 모범 사례 준수, 타입 매핑 등을 명시하여 레거시 코드를 새 언어/프레임워크로 마이그레이션
97. **터미널 cmd k**: 터미널에서 Ctrl/⌘ + K로 원하는 작업을 자연어로 설명하면 명령어 생성
98. **웹 브라우저 자동화 (puppeteer-mcp)**: 웹 스크래핑, 자동화 테스트, 스크린샷 캡처
99. **ddd/tdd에서의 mcp 활용**: 바운디드 컨텍스트 통합 및 테스트 환경 Mock 제공
100. **deliverables 명시 기법**: 생성해야 할 결과물 명확히 정의
101. **refactoring methodology**: 테스트 → 점진적 변경 → 메트릭 추적 프로세스
102. **ci/cd 통합 품질 게이트**: 린팅, 테스트 커버리지 파이프라인 통합
103. **rag (retrieval-augmented generation)**: 외부 데이터를 통해 실시간 정보 활용
104. **지식 증류(knowledge distillation)**: Teacher→Student 모델로 지식 전달
105. **unsloth를 활용한 효율적 fine tuning**: Colab에서 DeepSeek R1 파인튜닝
106. **api 연결 사전 검증**: Apidog 등으로 통합 전 API 테스트
107. **claude-command-suite 활용**: 추가 명령어 기능 확장
108. **pngpaste 스크린샷 활용**: 스크린샷 쉽게 전달
109. **사이드 패널 모드 사용**: CC 아이콘으로 사이드 패널 열기
110. **커뮤니티 지식 활용**: Medium 등에서 실용적 팁 수집
111. **의존성 및 환경 확인하기**: Python 버전, OS 호환성 등 사전 요청
112. **ai를 활용한 mvp 개발 후 전문가 투입**: 로우코드/AI로 MVP 후 전문가 발전
113. **ai 증강(augmentation) 접근법**: AI를 대체가 아닌 증강 관점에서 활용
114. **다중 솔루션 요청 기법**: "세 가지 다른 버전" 요청으로 이중 시야 효과
115. **설계 개선 도전 기법**: "더 나은 테스트가 가능하도록 5가지 아이디어" 요청
116. **"sleepwalking through greens" 경고**: AI 테스트 생성의 안티패턴 인식
117. **작업 유형별 모델 선택 전략**: 작업 특성에 맞게 AI 모델 선택 (알고리즘: O4-Mini-High, 유틸리티: Gemini, 프로토타이핑: Claude)
118. **rag를 통한 도메인 전문 ai 구축**: 오픈소스 LLM + 기업 전문 문서를 벡터 DB에 인덱싱하여 전문가 AI 구축
119. **스케일 업 접근법 (모델 크기 확장)**: 모델 규모, 데이터량, 연산량 확장을 통한 성능 향상
120. **완벽함을 기다리지 않고 먼저 사용하기**: "오늘 쓰는 AI가 가장 후진 AI" 인식으로 경쟁자보다 먼저 경험
121. **자신의 강점 분야에서 ai 활용 극대화**: 자신이 가장 잘하는 분야에 AI를 결합하여 시너지 창출
122. **마이크로서비스 구조화**: 작은 코드베이스가 AI와 더 잘 작동
123. **기능 테스트 우선**: AI 워크플로우에서는 단위 테스트보다 기능 테스트가 효과적
124. **thinking 모델 전용 사용**: 개발에는 고급 모델(Opus, Sonnet 등) 사용
125. **llm 응답의 자동 타입 변환**: Spring AI로 LLM JSON 응답을 Java 객체로 자동 변환
126. **스트리밍 응답 구현**: Flux<String>으로 LLM 응답 실시간 스트리밍
127. **llm 독립적 추상화 계층 활용**: Spring AI 추상화로 LLM 벤더 교체 시 설정만 변경
128. **벡터 데이터베이스를 이용한 시맨틱 검색**: PGVector 등으로 의미 기반 문서 검색
129. **로컬 llm 활용 (ollama)**: 프라이버시/비용 문제 해결을 위한 로컬 모델 활용
130. **재시도 로직 구현**: API 호출 실패 시 자동 재시도
131. **http 클라이언트 재사용**: 클라이언트 싱글톤 관리로 연결 오버헤드 감소
132. **ai + 도메인 데이터 결합 전략**: 범용 LLM + 도메인 특화 RAG 시스템
133. **지적인 정직함**: 모르는 것은 인정, 잘못된 결정은 빠르게 방향 수정
134. **카니발라이제이션 혁신**: 자사 기존 제품을 AI 기반으로 스스로 대체
135. **주관성 제거 보고서 작성**: 형용사/부사 제거, 정량 데이터 중심 문서화
136. **도메인 지식 레이어드 접근**: Domain + Functional + Disciplinary Knowledge 위에 AI 활용
137. **전용 ai 작업 공간 설정**: 코딩 환경과 AI 브레인스토밍 환경 분리
138. **컴포넌트 분석 요청**: 프로젝트를 관리 가능한 컴포넌트로 분해 요청
139. **기술 선택 비교 요청**: 기술 옵션의 장단점 비교 분석 요청
140. **디자인 패턴 탐색 요청**: 기능에 적합한 디자인 패턴 추천 및 구현 방법 요청
141. **ai 코딩 워크플로우 7단계**: 사양 → 생성 → 검토 → 반복 → 테스트 → 최적화 → 문서화
142. **ai 의존 시 4가지 함정**: 큰 그림, 복잡한 솔루션, 기본 개념, 성능 주의
143. **살아있는 문서화 전략**: 문서 버전 관리, 코드 변경 시 업데이트, 주기적 검토
144. **고무오리 디버깅 효과**: AI에게 설명하면서 코드 개선점 발견
145. **ai-dlc (ai-driven development lifecycle)**: AWS 제안 방법론
146. **bolt-based rapid iteration**: Sprint 대신 시간/일 단위 빠른 반복
147. **코드베이스 탐색 → 이해 → 수정 패턴**: 프로젝트 구조 설명 요청으로 시작하여, 최상위 파일부터 점진적으로 깊이 탐색한 후 코드를 수정하는 단계적 접근법
148. **원커맨드 커밋**: `claude commit` 명령으로 변경사항 분석, 커밋 메시지 생성, 커밋 실행을 한 번에 처리
149. **aws bedrock 연동**: 환경 변수 설정을 통해 AWS Bedrock에서 Claude 모델을 사용하는 엔터프라이즈 배포 패턴
150. **자동화된 테스트 생성 요청**: 구현한 기능에 대해 구체적인 검증 포인트를 명시하여 테스트 코드 생성을 요청
151. **프로젝트 기능 활용 (project feature utilization)**: Claude Desktop의 Projects 기능을 사용하여 관련 파일과 채팅을 함께 관리
152. **사용량 모니터링 및 피크 시간 관리**: 피크 시간대에는 제한이 더 엄격할 수 있으므로, 중요한 작업은 비피크 시간에 수행
153. **다중 ai 백업 전략 (multi-ai backup strategy)**: Claude 한도 도달 시를 대비하여 ChatGPT, DeepSeek 등 다른 AI를 백업으로 준비
154. **이중 구독 전략 (dual subscription rotation)**: 2개의 Claude 구독을 유지하여 한 계정의 한도에 도달하면 다른 계정으로 전환
155. **plan mode (opus mode) 활용**: 구체적인 방법(How)을 지시하는 대신, 원하는 결과(What)만 기술하고 Claude가 계획을 제시하면 대화를 통해 방향을 조정
156. **사전 결과 상(像) 기반 접근법**: 결과에 대한 명확한 이미지가 있는지 여부에 따라 AI 활용 전략을 다르게 적용
157. **인덱싱 및 문맥 최적화**: 대량의 문서에서 효율적인 토큰 사용을 위해 hierarchical tag를 생성하고 분석
158. **hot key 활용**: `Ctrl-C`로 작업 중단/취소 등 빠른 제어를 위한 단축키 활용
159. **imagine with claude 실시간 소프트웨어 생성**: Claude가 실시간으로 소프트웨어를 생성하고 사용자 요청에 응답하며 적응하는 실험적 기법
160. **훅 (hooks) 자동 실행**: 테스트/린트 등을 자동으로 실행하여 코드 품질을 유지하면서 장기 작업을 수행
161. **다단계 추론 및 코드 이해력**: 복잡한 코드베이스 전반의 작업을 더 잘 처리할 수 있는 다단계 추론 능력
162. **네스티드 제약조건**: `<constraints>` 태그 내에 여러 하위 태그를 중첩하여 복잡한 제약조건을 계층적으로 정의
163. **빠른 테스트 주도 개발 사이클**: 렌더링 성능 개선으로 고빈도 상호작용 세션에서 TDD 사이클을 가속화
164. **todo 시스템을 통한 작업 추적**: ToDo.md 파일을 자동 생성하여 개발 진행 상황 추적 방식을 지식관리에 적용
165. **moc(map of contents) 기반 지식 구조화**: MOC 시스템을 구축하여 지식 간의 연결과 전체적인 구조를 시각화
166. **연결 아이디어 자동 제안**: AI가 문서 내용을 분석하여 관련된 아이디어들을 자동으로 제안
167. **progressive disclosure architecture (pda)**: 전체 문서를 한 번에 로드하는 대신, 필요한 참조 문서만 온디맨드로 로드하여 80-95% 토큰 절약
168. **5kb/10kb 규칙**: 스킬 크기에 따른 설계 가이드라인. 10KB 초과 시 PDA 적용 고려
169. **세 가지 스킬 활성화 방법**: 명시적 커맨드, 자연어 인식, CLAUDE.md 사전 가이드의 세 가지 방법
170. **잘 설계된 스킬 파일 구조**: 스킬 파일의 표준 구조: YAML frontmatter → 제목 → 설명 → 활성화 조건 → 단계별 프로세스
171. **단일 책임 원칙**: 스킬은 하나의 잘 정의된 작업에 집중해야 함
172. **스크립트 분리 및 테스트 가능성**: API 호출, 데이터 처리 등 기계적 작업은 외부 스크립트로 분리
173. **탐색적 프로젝트 분석 (exploratory project analysis)**: Goose는 탐색적 방식으로 작동하여 프로젝트 구조와 기능을 스스로 파악합니다. REST API 분석, 엔티티 구조 파악, 환경 설정 방법 탐지 등을 자동으로 수행하여 새로운 코드
174. **점진적 대화형 개발 (iterative conversational development)**: 테스트 생성 후 결과를 확인하고, 원하는 동작과 다른 부분을 발견하면 추가 요청을 통해 코드를 수정합니다.
175. **엣지 케이스 자동 식별 (automatic edge case identification)**: AI 에이전트는 테스트 케이스 생성 시 다양한 긍정적, 부정적 사례와 엣지 케이스를 자동으로 식별합니다.
176. **자동 다이어그램 생성 (automatic diagram generation)**: AI가 `@Entity` 어노테이션 등 코드 패턴을 검색하여 엔티티와 관계를 파악하고, ER 다이어그램이나 아키텍처 다이어그램을 자동 생성합니다.
177. **llm 백엔드 최적 선택 (llm backend selection)**: 다양한 LLM 제공업체를 시도해 보고, 현재 작업에 가장 적합한 모델을 선택합니다.
178. **추상화 발견 시 llm 브레인스토밍 파트너 활용**: 추상화 발견과 안정화 과정은 창의적 활동으로, LLM에 통제권을 넘기지 않고 개발자가 주도권을 유지하면서 브레인스토밍 파트너로 활용합니다.
179. **안정된 추상화의 기계적 작업 위임**: 추상화가 안정된 후에는 새로운 사용 사례나 변형 구현과 같은 반복적이고 기계적인 코딩 작업을 LLM에 위임합니다.
180. **피드백 루프 기반 점진적 개발**: 컴파일러와의 상호작용처럼 LLM도 피드백 메커니즘으로 활용합니다. 첫 번째 명세는 가설로 취급하고 반복적 개선을 통해 발전시킵니다.
181. **검색 모드 전환 (r @, rr @)**: `R @`(짧은 글)와 `RR @`(긴 글) 접두어를 사용하여 검색 결과의 상세 수준을 조절합니다.
182. **maps of content (moc) 관리**: Obsidian의 폴더 구조(Inbox → Notes → Assets → MOC)와 AI를 결합하여 지식을 체계적으로 조직화합니다.
183. **코드 구조화 요청 패턴**: 코드 구조화 시 사용하는 프레임워크(Next.js 14), 라우터 방식(App Router), 언어(TypeScript) 등을 명시적으로 지정합니다.
184. **프레임워크 특화 요청**: shadcn/ui, Tailwind CSS 등 특정 UI 라이브러리 스타일을 명시하여 일관된 디자인 언어로 컴포넌트를 생성합니다.
185. **모달/인터랙션 동적 추가**: 정적 UI를 먼저 완성한 후, 클릭 이벤트, 모달, 애니메이션 등 동적 기능을 별도 요청으로 추가합니다.
186. **피드백 메커니즘 구축**: LLM에게 적절한 피드백을 제공하는 메커니즘(타입 에러, 임시 스크립트, 유닛 테스트, e2e 테스트 등)을 구축합니다.
187. **ai 강점/약점 영역 구분**: AI가 잘하는 영역과 실패하는 영역을 명확히 구분하여 적재적소에 활용합니다.
188. **아키텍처 수준 유지**: AI와 작업할 때 너무 세부적인 버그 수정에 빠지지 않고 높은 수준의 아키텍처 관점을 유지합니다.
189. **ooda 루프 기반 동적 재계획**: 각 Action 완료 후 시스템이 조건을 재평가하고 새로운 정보에 적응하여 재계획합니다.
190. **하이브리드 계획 시스템 (non-llm ai)**: 계획 단계에서 LLM이 아닌 전통적인 AI 알고리즘을 사용하여 정교한 계획을 수립합니다.
191. **다중 llm 조합 활용 (llm mixing)**: 서로 다른 LLM의 강점을 활용하여 작업별로 최적의 모델을 혼합 사용합니다.
192. **에이전트 테스트 용이성 설계**: 처음부터 테스트 용이성을 고려하여 설계되었습니다. 단위 테스트와 종단간 테스트 모두 쉽게 수행할 수 있습니다.
193. **비llm ai 알고리즘 기반 자동 계획 (goap)**: LLM에 의존하지 않는 AI 알고리즘을 사용하여 계획을 수립합니다. 결정론적이고 설명 가능한 계획을 제공합니다.
194. **작업별 최적 모델 선택 (model mixing)**: 단일 "신과 같은" 모델에 의존하지 않고, 작업 특성에 따라 로컬, 저렴한, 프라이빗 모델을 혼합하여 사용합니다.
195. **llm을 활용한 자연어 → 구조화 데이터 변환**: 사용자의 자연어 메시지를 LLM 호출을 통해 구조화된 객체로 변환한다.
196. **mcp inspector를 활용한 에이전트 테스트**: MCP Inspector 도구를 사용하여 MCP 서버에 SSE로 연결하고 에이전트를 테스트하고 디버깅한다.
197. **기술 부채 속도 측정**: AI 생성 코드로 인한 기술 부채 증가 속도를 측정합니다. 부채 생성 대 해결 비율, AI 코드 리팩터링 빈도 등을 핵심 지표로 추적합니다.
198. **ai 책임 소재 명확화**: "AI가 그렇게 했어요"라는 면책은 인정하지 않습니다. AI가 나쁜 코드를 제안하더라도 최종 수용 결정을 내린 개발자에게 책임이 있음을 명확히 합니다.
199. **레거시 시스템용 ai 가드레일**: AI는 최신 패턴에 편향되어 있으므로 레거시 시스템에는 별도의 규칙을 적용합니다.
200. **출처 추적 시스템**: AI가 생성하거나 추천한 코드의 출처, 검토자, 마지막 업데이트 시점을 추적합니다.
201. **무차별 수정 대신 근본 원인 진단 유도**: AI가 문제를 해결할 때 "왜 이 문제가 발생했는지"를 먼저 분석하도록 유도합니다.
202. **ai 테스트 생성 시 중복 검토**: AI는 기존 테스트에 어설션을 추가하는 대신 새 테스트 함수를 만드는 경향이 있습니다. 사용자 지정 지침으로 이를 완화합니다.
203. **"빠른 해결책"의 유지보수 비용 평가**: 현재 잘 작동하지만 미래에 변경하기 어려운 코드인지 판단하는 경험적 안목이 필요합니다.
204. **youtube 트랜스크립트 자동 분석**: `fabric -y [YouTube URL]` 명령으로 영상의 트랜스크립트를 자동 추출하고 AI 패턴과 결합하여 인사이트를 추출합니다.
205. **전문가 역할 기반 코드 리뷰 (ask_uncle_duke)**: Java/Spring 전문가 페르소나를 가진 패턴이 SOLID, DRY, TDD, 클린 코딩 원칙에 따라 코드를 분석합니다.
206. **agility_story / create_user_story 패턴**: 기능 요구사항을 입력하면 사용자 스토리 형식과 인수 조건을 자동 생성합니다.
207. **학술 콘텐츠 심층 분석 (analyze_paper)**: URL이나 텍스트를 입력하면 논문/기사의 핵심 주장, 방법론, 결론을 체계적으로 분석합니다.
208. **재귀적 아웃라인 생성 (create_recursive_outline)**: 주제를 입력하면 UI, 백엔드, 데이터베이스, 보안, 테스트, 배포까지 포괄하는 계층적 프로젝트 아웃라인을 자동 생성합니다.
209. **jina ai 기반 웹 스크래핑**: `-u` 옵션으로 웹페이지 URL을 마크다운으로 변환하여 AI 분석의 입력으로 활용합니다.
210. **crawl4ai 웹 스크래핑**: Crawl4AI를 사용하여 웹페이지의 HTML을 LLM이 이해하기 쉬운 깔끔한 마크다운으로 자동 변환합니다.
211. **브라우저 세션 재사용 크롤링**: 동일한 브라우저 세션을 재사용하여 여러 URL을 효율적으로 크롤링합니다.
212. **supabase/pgvector rag 파이프라인**: 크롤링한 마크다운 콘텐츠를 임베딩으로 변환하여 벡터 데이터베이스에 저장하고 유사도 검색을 수행합니다.
213. **실시간 웹 지식베이스 생성**: Crawl4AI와 RAG를 결합하여 어떤 웹사이트든 LLM을 위한 동적인 지식베이스로 변환합니다.
214. **벡터 임베딩 기반 코드베이스 인덱싱**: 벡터 임베딩을 사용해 코드베이스 전체를 인덱싱하여 의미론적 코드 탐색이 가능해집니다.
215. **계획 우선 접근법(plan-first approach)**: AI에게 코드 작성을 요청하기 전에 먼저 계획 수립을 요청합니다.
216. **ai 실수 패턴 인식**: AI가 자주 저지르는 실수 패턴을 인식합니다: 무차별 대입 수정, 과도한 모킹 등.
217. **통제력 상실 시점 인식**: AI와의 작업 세션에서 통제력을 잃었다고 느끼는 순간을 인식하고, 그 시점에서 작업을 중단합니다.
218. **문제 분해 후 계획 수립 (problem decomposition)**: 요구사항을 바로 코드로 변환하지 않고, 먼저 하위 작업을 목록으로 정리한 후 단계별로 진행합니다.
219. **ai 기반 테스트 자동화 사이클**: AI가 테스트 작성, 실행, 실패 원인 분석, 반복 개선까지 전 과정을 지원합니다.
220. **사이드바 기반 ai 대화 인터페이스**: Leader 키 조합으로 AI 사이드바를 열고, 코드 작성 흐름을 유지하면서 AI와 상호작용이 가능합니다.
221. **코드 블록 네비게이션을 통한 ai 결과 탐색**: `[[`와 `]]` 단축키로 AI가 생성한 코드 블록들 사이를 빠르게 이동할 수 있습니다.
222. **ollama를 통한 로컬 ai 모델 실행**: Ollama 프레임워크를 사용하여 오픈소스 LLM을 로컬 컴퓨터에서 실행합니다. 인터넷 연결 없이 완전한 오프라인 환경에서 AI 모델을 활용할 수 있습니다.
223. **docker 기반 로컬 ai 웹 인터페이스 구축**: Docker와 Open Web UI를 결합하여 로컬 AI 모델에 ChatGPT와 유사한 웹 인터페이스를 제공합니다.
224. **하드웨어 사양에 맞는 llm 모델 크기 선택**: 7B, 32B, 70B 등 다양한 크기의 모델 중 현재 하드웨어 사양에 맞는 모델을 선택합니다.
225. **완전 오프라인 ai 개발 환경 구성**: Ollama + Docker + Open Web UI 조합으로 인터넷 연결 없이 동작하는 AI 환경을 구축합니다.
226. **"코드는 저렴하지만, 사고는 그렇지 않다"**: AI가 코드 작성 비용을 낮췄기 때문에 설계와 아키텍처에 대한 사고력이 더 중요
227. **planning spectrum**: 작업 복잡도에 따라 계획 수준 조절 (바이브 코딩 ↔ 철저한 계획)
228. **해당 없음 문서**: 0개 (모든 문서에서 기법 추출 성공)
229. **아키텍처 브레인스토밍에 활용**: 구현 전에 AI와 아키텍처 접근 방식을 브레인스토밍하여 더 나은 설계 결정.
230. **테스트 케이스 자동 생성**: 복사-붙여넣기 테스팅에서 벗어나 AI를 통해 다양한 시나리오와 엣지 케이스를 포함한 테스트 생성.
231. **@achievesgoal로 최종 목표 지정**: 최종 목표 액션에 어노테이션을 붙여 GOAP이 자동으로 액션 시퀀스 계획
232. **record 클래스를 활용한 도메인 모델**: Java record로 간결하게 LLM 응답 구조 정의
233. **rest api 생성 프롬프트 패턴**: `Implement REST API for CRUD operations with [entity]. For testing purpose, create and run seed...` 
234. **ai 에이전트의 반복적 작업 패턴 이해**: 계획 수립 → 코드 생성 → 구성 파일 변경 → 테스트 실행 → 결과 검증 → 코드 수정
235. **승인 기반 작업 제어**: 파일 편집이나 명령 실행 전 diff 미리보기로 확인 후 수락/거부
236. **decline(거부) 기능 활용**: 제안이 마음에 들지 않으면 decline하여 다른 접근 방식 요청
237. **openai 호환 api로 bedrock 사용하기**: 환경변수 `OPENAI_API_KEY=bedrock`과 `OPENAI_BASE_URL` 설정으로 OpenAI SDK로 AWS Bedrock 모델 호출
238. **aws bedrock rag 구축 워크플로우**: S3 생성 → RAG 파일 업로드 → Knowledge Base 구성 → S3 chunking → Embedding 모델 설정 → Vector DB 구성 → Knowledge Ba
239. **사고적 글쓰기 vs 귀찮은 글쓰기 구분**: AI는 정형화된 '귀찮은 글쓰기'에 적합, 사고력 필요한 작업은 직접 수행
240. **보일러플레이트 작업에 ai 활용**: 반복적이고 기계적인 작업에만 AI 사용, 창의적 판단 필요한 영역은 직접 수행
241. **전사적 마스터플랜 우선 접근법**: 개별 부서 PoC가 아닌 전체 조직의 데이터 지도, 모델 책임 경계선, 변경 관리 로드맵 먼저 설계
242. **외부 파트너십 활용 전략**: 내부 빌드(성공률 33%)보다 외부 파트너십(성공률 67%) 적극 활용
243. **poc 함정 회피 체크리스트**: 트렌드 추종 경계, 미스얼라인먼트 점검, 내부 빌드의 오만 경계
244. **종단 간(end-to-end) 지표 관리**: 부서별 KPI가 아닌 회사 전체 성과를 측정하는 종단 간 지표 관리
245. **메타인지 기반 역할 정의**: "나는 도시 아키텍트인가, 건물 설계사인가, 배관공인가?" 파악
246. **변화 관리와 온보딩 중심 접근**: 기술적으로 완벽한 시스템도 사용자가 채택하지 않으면 무의미
247. **plan 모드와 @symbol 참조**: 복잡한 작업 전 계획 검토, 코드 심볼 직접 참조로 정확성 향상
248. **작은 단계(small steps) 원칙 적용**: - AI에게 한 번에 하나씩 사용자 스토리와 테스트 케이스 작성 요청
249. **첫 테스트로 패턴 확립**: - 첫 번째 테스트를 수동으로 작성하여 스타일과 컨벤션 확립
250. **시스템 지시문과 특수 주석 활용**: - AI의 행동을 제어하기 위한 시스템 지시문 설정
251. **우발적 복잡성 ai 위임**: - 도메인/유스케이스 레이어는 TDD로 직접 작성
252. **tdd 통합 방안**: - AI에게 명시적으로 테스트 작성을 먼저 요청하여 Red-Green-Refactor 유도
253. **아키텍처 설계 역할 강화**: - AI가 단순 구현 담당, 인간은 시스템 설계와 아키텍처 결정에 집중
254. **ai를 "영혼 없는 필사자(scriber)"로 활용하기**: - AI에게 루틴한 코드 생성을 위임, 인간은 의미와 맥락의 "왜(Why)"를 보유
255. **why.md 파일 작성**: - 모든 모듈의 루트에 존재 이유를 설명하는 문서 추가
256. **adr(architecture decision records) 유지**: - "무엇"뿐만 아니라 "왜"를 설명하는 의사결정 기록 유지
257. **ai를 조종사 보조 모델로 활용**: - AI가 분석을 담당하고, 인간이 최종 판단과 의사결정을 책임
258. **패턴 분석 작업에 ai 활용**: - 사용자 피드백 분석으로 반복되는 테마 발견
259. **회고(retrospective) 노트 분석**: - AI를 사용해 회고 노트의 패턴 발견
260. **ai 결과물을 시작점으로 활용**: - AI가 생성한 텍스트나 초안을 완성된 작업이 아닌, 인간이 개선하기 위한 시작점으로 취급
261. **모호성 제거 도구 활용 (integrated thought clarifier)**: - Specification 작성 시 모호성을 끌어내고 명확히 하는 도구 활용
262. **다중 이해관계자 정렬 (multi-stakeholder alignment)**: - 자연어 기반 specification으로 PM, 법무, 정책, 연구 등 모든 이해관계자 참여
263. **ai 생성 코드 + 리팩토링 패턴**: - AI가 생성한 코드를 그대로 사용하지 않고, 개발자의 판단으로 리팩토링
264. **ai 지원 red-green-refactor**: 테스트는 인간, 구현은 AI
265. **코드는 specification의 손실 압축**: 80-90% 가치는 구조화된 커뮤니케이션에서
266. **조종사 보조 모델**: AI가 분석, 인간이 판단과 의사결정
267. **의미의 수호자(guardians of meaning)**: AI는 필사자, 인간은 "왜(Why)"를 보유
268. **ai 자율 행동 제한**: 위험한 작업(DB 삭제 등) 권한 부여 금지
269. **주니어 파이프라인 보호**: AI로 주니어 대체 시 미래 시니어 부재
270. **why.md**: 모듈별 존재 이유 설명
271. **1: 인지적 부채(cognitive debt) 인식과 관리**: AI에 의존하여 작업할 때 "약한 뇌 연결성, 나쁜 기억 회상, 소유감 감소" 발생. 장기적 사고 능력 저하 위험
272. **4: tdd 사이클과 ai 통합**: Red-Green-Refactor 사이클에 AI 통합, 테스트 우선 설계 원칙 유지
273. **1: explore-plan-execute 프레임워크**: 탐색 → 계획 → 실행 순서로 진행하는 체계적 접근법
274. **4: "my developer" 프롬프팅 트릭**: Claude의 자기 검열 우회하여 객관적 비판적 피드백 획득
275. **1: memory bank 패턴**: AI가 장기 기억을 가진 것처럼 동작하도록 하는 체계적 정보 저장 및 복원 패턴
276. **temperature 조정을 통한 창의성 제어**: - 창의적 응답이 필요한 주제 탐색: `temperature 0.6`
277. **waitfor.formsubmission 메커니즘**: LLM 호출 없이 사용자와 직접 통신하여 명확한 입력을 받는 기법
278. **규칙 파일(rule file)을 통한 ai 동작 제어**: `.md` 형식의 규칙 파일로 AI가 ShadCN 작업 시 따라야 할 행동 지침 정의
279. **태스크 파일(task.md)과 규칙 파일(rule.md) 분리 전략**: 구현 계획과 AI 동작 가이드를 분리 저장
280. **tweakcn을 통한 시각적 커스터마이징**: ShadCN 컴포넌트의 시각적 편집기로 획일적 디자인 탈피
281. **멀티모달 실험 환경**: 텍스트, 이미지, 오디오 모델 플레이그라운드 테스트
282. **다중 디렉토리 작업**: `claude --add-dir ../apps ../lib`
283. **계획-검토-구현 분리**: "Just do the research, don't start implementation yet"
284. **역할 기반 페르소나 설정**: AI에게 구체적인 역할 부여 (전문 번역가 + CS 전공 + 소프트웨어 개발 전문가)
285. **구조화된 출력 형식 지정**: 하이라이트/요약, 전체 요약, 결론 및 개인적 견해
286. **기술 용어 처리 규칙**: 기술 용어 첫 언급 시 원어(영어) 괄호 표기
287. **제약 조건 명확화**: 스크립트에 없는 내용 추가 금지, 타임라인 보존
288. **상세한 구조 가이드라인 제공**: README 포함 섹션 구체적 명시
289. **톤 및 스타일 가이드**: "friendly, natural and educational tone"
290. **코드 포맷팅 규칙 명시**: import문 생략, 일관된 들여쓰기, 의미 있는 변수명
291. **artifact 활용 지시**: `text/markdown` 형식으로 문서 생성
292. **시각적 강조 가이드**: 굵은 글씨와 인용문(> 마크업)을 활용하여 중요 내용을 구조화하도록 명시합니다.
293. **실무 적용 내용 강제 포함**: 체크리스트, 실천적 지침 등 실무에 직접 영향을 주는 내용 누락 금지.
294. **점진적 사고 유도 (cot)**: "Take a deep breath and let's work this out in a step-by-step way" 문구로 체계적 사고 유도.
295. **계층화된 추상화 명시**: "Step Down Rule"을 구체적으로 설명하여 코드 조직 방식 지시.
296. **도메인 주도 설계 통합**: DDD의 Value Object 개념으로 Primitive Obsession 제거 기준 제시.
297. **protocol driver layer 분리**: 테스트 DSL과 SUT 호출을 분리하여 가독성과 유지보수성 향상.
298. **부정/긍정 예시 비교**: Before/After 예시를 나란히 제시하여 변환 방향 명확화.
299. **builder 패턴 활용 지시**: 구체적 클래스명과 구현 제시로 정확한 구현 유도.
300. **approval test 대체 방안**: DSL이 복잡해지는 경우 ApprovalTest 사용 제안.
301. **다이어그램 생성 요청**: class, sequence, activity, object diagram 포함 요청.
302. **대상 독자 정의 (audience profiling)**: 사용자의 배경, 경험, 관심 분야를 구체적으로 명시하여 응답 수준 맞춤.
303. **전문 용어 사용 강조**: 소프트웨어 개발 관점에서 전문적 용어 사용 반복 강조.
304. **코드 완성 기능 ("탭/탭/탭") 활용**: 주석 작성으로 LLM이 다음 단계 코드를 예측하도록 유도.
305. **점진적 청크 단위 개발**: 대규모 사양을 작은 단위로 분할하여 접근.
306. **youtube 콘텐츠 경쟁 분석**: 여러 유튜브 링크로 공통 주제, 훅, 아웃트로 패턴 추출 및 차별화 관점 분석.
307. **경쟁사 웹사이트 메시징 분석**: 경쟁사 URL들로 공통 메시지, 타겟 오디언스, 톤 분석 및 포지셔닝 갭 도출.
308. **seo 기반 콘텐츠 주제 추출**: 검색 결과 페이지의 여러 링크를 수집하여 핵심 주제와 시맨틱 키워드 추출.
309. **포드캐스트 스크립트 톤 변환**: 다중 진행자 대화를 1인칭 관점으로 변환하는 프롬프팅 기법.
310. **vault qa 참조 기반 질의**: `[[노트명]]` 링크 문법으로 특정 노트 기반 답변 수집.
311. **프라이버시-성능 트레이드오프 최적화**: 로컬(데이터 보호) vs 클라우드(성능) 상황별 선택.
312. **임베딩 모델 설정 조정**: similarity 임계값과 검색 청크 수 조정으로 정확도 균형.
313. **비용-기능 균형 분석**: 클라우드 월 비용 vs 로컬 하드웨어 투자 체계적 비교.
314. **검증 가능성과 투명성 원칙**: AI 작업 요약, 테스트 결과, PR 설명을 함께 제시하여 신뢰와 검토 가능.
315. **스타일 기반 코드 최적화**: 코드 댓글, 코드 스타일을 고려한 모델 최적화.
316. **ai + tdd 패턴**: AI에게 실패하는 테스트를 먼저 작성하게 한 후, 테스트를 통과시키는 코드 구현 요청.
317. **아키텍처 결정은 인간 담당**: AI는 구현/스캐폴딩/리팩터링만, 설계와 아키텍처는 인간이 담당.
318. **ai 페어의 장점 활용**: 자존심 없음, 무한 인내심, 완벽한 기억력을 전략적으로 활용.
319. **ai를 통한 복잡한 코드 이해 및 문서화**: 복잡한 함수를 AI에게 설명하도록 요청하여 비즈니스 규칙 파악.
320. **ai를 활용한 벤치마크 자동 생성**: 성능 테스트 코드 생성 요청으로 측정 기준선 설정.
321. **테스트 데이터 가독성 개선**: TDD 기반 Builder 패턴으로 테스트 데이터를 읽기 쉬운 형식으로 변환.
322. **점진적 이해 구축을 통한 반복적 리팩토링**: 테스트 케이스를 하나씩 추가하며 AI에게 구현 요청.
323. **아이디어 제시 및 ai 협력 패턴**: 개발자가 먼저 개선 아이디어 제안 후 AI에게 타당성 검토 및 구현 의뢰.
324. **필요시 ai 생성물 폐기 및 수동 재작성**: AI가 엣지 케이스에서 실패할 때 개발자가 직접 재작성.
325. **ai와의 효과적인 협력의 원칙**: 도메인 이해와 최종 의사결정은 개발자 책임, 번거로운 작업은 AI에 위임.
326. **역할 정의(role definition) 프롬프팅**: "시니어 풀스택 개발자이자 소프트웨어 아키텍트"로 명확히 정의하여 응답 수준 통제.
327. **기술 스택 명시를 통한 일관성 보장**: 프론트엔드부터 배포까지 모든 계층 기술 구체적 정의.
328. **아키텍처 우선 개발 패턴**: 구현 전 다이어그램, API 계약, 스키마 먼저 작성 후 검토.
329. **er 및 시퀀스 다이어그램 자동 생성**: 데이터 계층, 메시지 플로우 시각화 요청.
330. **전문 영역 명시 (domain expertise declaration)**: CSS, JavaScript, React 등 전문 분야를 시작에서 선언.
331. **단계적 변경 분해 (discrete changes breakdown)**: 큰 작업을 작은 단위로 분해, 각 단계마다 테스트.
332. **코드 불필요성 우선 (code minimization principle)**: 코드 없이 답변 가능하면 코드 작성 피하기.
333. **변수명/문자열 보존 원칙**: 코드 재현 시 변수명과 문자열 리터럴 유지.
334. **일반성과 유연성 균형**: 즉각적 문제 해결과 재사용 가능한 일반적 솔루션 사이 균형 유지.
335. **명확성 추구와 토론 촉진**: 불명확한 부분에서 명확화 요청, 트레이드오프 논의 유도.
336. **구조화된 요구사항 분석**: 요구사항 명세서, 용어 사전, 이해관계자 목록 정리로 모호함 제거.
337. **유비쿼터스 언어 기반 모델링**: 도메인 전문가/개발자 공유 언어로 개념적 도메인 모델 구축.
338. **이벤트 스토밍 워크샵**: 핵심 도메인 이벤트 식별, Aggregate/Command/Event 패턴 도출.
339. **테스트 시나리오 기반 개발 준비**: TDD 이전 유스케이스별 테스트 시나리오 리스트 작성.
340. **역할 부여(act as pattern)**: AI에 특정 역할(PM, 마케터, 면접관 등) 부여하여 맥락 명확화.
341. **인터랙티브 반복 개선**: 초기 답변 후 "더해줘", "간단하게" 등으로 지속 개선.
342. **하이퍼파라미터 튜닝**: Temperature, Top-P, Max Length 등 조정으로 출력 특성 제어.
343. **타겟 채널/대상 명시**: "블로그용", "페이스북용" 등 최종 사용처 명시.
344. **따옴표로 강조**: 중요한 키워드를 따옴표로 감싸서 강조.
345. **코드 리뷰 및 설명 요청**: "설명해줘", "버그 찾아줘", "리팩토링해줘" 패턴.
346. **에러 메시지 활용**: 에러 메시지 전체 복사하여 정확한 해결책 획득.
347. **언어 간 코드 변환**: Python → JavaScript, SQL → VBA 등 다른 언어로 변환.
348. **주제별 문서 수집 활용**: 특정 주제의 배경, 장단점, 글로벌 사례 다차원 조사.
349. **작성 스타일 파라미터**: Academic, Analytical, Creative, Technical 등 스타일 지정.
350. **문서 요약 및 추출**: URL로 웹 문서 요약, 긴 텍스트에서 핵심 정보 추출.
351. **아티팩트를 통한 대화형 개발**: Artifact 기능으로 코드 작성 실시간 확인 및 미리보기.
352. **claude vs gpt 선택 기준**: 장문 작성(3000자)은 Claude가 우수, 용도별 모델 선택 중요.
353. **프로젝트 기능을 활용한 맞춤형 봇 개발**: Claude Pro의 프로젝트 기능으로 특화된 봇 구축.
354. **비기술자 친화적 설명 요청**: "non-technical users" 표현으로 코드 가독성 확보.
355. **접근성 및 성능 기준 명시**: WCAG AA 표준, 색맹 고려, 모바일 반응형 명시.
356. **제약 조건 예상 및 명시**: Artifacts 환경 제약 인식하고 placeholder 제시 유도.
357. **직접 답변 우선 전략 (zero preamble)**: 설명/인사 없이 즉시 해결책부터 제시.
358. **부동태 모드 진입 기준 정의**: 매우 엄격한 기준으로 불필요한 비활성 응답 방지.
359. **응답 포맷 표준화**: 헤드라인(≤6단어) + 메인 불릿(1-2개) + 서브 불릿 계층 구조.
360. **정의 우선순위(term definition)**: 마지막 10-15 단어의 회사명, 기술 용어 자동 감지 정의.
361. **마크다운 포맷 제약 (no headers)**: #, ##, ### 없이 굵은 텍스트와 불릿만 사용.
362. **latex 수학 렌더링 표준화**: 모든 수학 표현을 LaTeX 형식으로 통일.
363. **역할 명확화 (speaker label)**: me(사용자), them(상대방), assistant(AI) 명확히 구분.
364. **role/label 기반 요소 선택**: XPath/CSS 대신 `getByRole()`, `getByLabel()` 접근성 기반 선택 우선.
365. **문제 인식 및 개선 체크리스트**: 생성 코드 한계점 명시적 인정, 검토/보완 단계 필수.
366. **knowledge 파일 업로드 기법**: GPT에 참고 문서를 업로드하여 도메인 특화 지식 제공
367. **code interpreter 활성화**: GPT가 코드를 생성하고 실행하며, 결과 파일을 다운로드 가능하게 하는 기능
368. **유튜브 검색 gpt 생성 패턴**: SerpAPI를 활용하여 YouTube 검색 기능을 가진 GPT 생성
369. **입출력 예시 기반 생성 (example-driven generation)**: GraphQL 쿼리와 예상 응답 데이터를 함께 제공하여 AI가 정확한 스키마와 구현을 생성하도록 유도
370. **테스트 우선 요구사항 (test-first requirement)**: AI에게 코드와 함께 테스트 코드를 동시에 생성하도록 요청하여 검증 가능한 코드를 얻는 기법
371. **기술 스택 명시 기법 (tech stack specification)**: 사용할 프레임워크, 라이브러리, 언어 버전, 데이터 타입 등을 구체적으로 명시
372. **최소 출력 제약 (minimal output constraint)**: "부연 설명 없이 코드만 작성"처럼 AI의 장황한 설명을 제거하고 실행 가능한 코드만 받도록 요청
373. **어노테이션 화이트리스트 기법 (annotation whitelisting)**: 사용 가능한 어노테이션을 명시적으로 제한하여 불필요한 의존성이나 설정이 추가되는 것을 방지
374. **스토리 개발을 위한 단계적 프롬프팅**: 소설이나 스토리 작성 시 배경 지식을 먼저 제공하고, 단계적으로 세부 사항을 요청하는 방식으로 플롯을 발전
375. **다중 제목 생성 및 선택 기법**: 원본 제목의 의미를 유지하면서 클릭률을 높일 수 있는 여러 대안 제목을 생성
376. **local history를 이용한 ai 변경사항 확인**: AI가 수정한 코드를 Local History 기능을 활용하여 검토하고 추적
377. **에러 로그 우클릭 설명 기능**: 에러가 발생했을 때 에러 로그를 선택하고 우클릭하여 "Explain..." 기능을 사용
378. **브랜치 생성 전제 조건 명시**: 중요한 작업 전 새 브랜치를 생성하도록 명시적으로 요청
379. **기술 선택에 대한 ai와의 대화**: 특정 기술 선택(예: UUID vs Long ID)에 대해 AI와 토론하고 의견을 구한 후 결정
380. **testcontainers 자동 추가 요청**: 특정 기술 스택(PostgreSQL, Spring Boot)에 대한 테스트 환경을 AI에게 자동으로 설정하도록 요청
381. **단순하고 명확하게 지시하기**: 주관적 표현 대신 구체적이고 측정 가능한 지시 사용
382. **해야 할 것에 집중하기 (부정 지시 회피)**: "하지 말아야 할 것"보다 "해야 할 것"으로 지시
383. **셀프 크리틱(self-critique) 요청**: AI가 자신의 답변을 검토하도록 요청
384. **역할 부여(role assignment)**: GPT에게 특정 역할 부여 (비서, 전문가 등)
385. **조건부 검색 및 필터링**: 특정 조건(날짜, 위치 등)을 만족하는 정보만 검색
386. **최적화 알고리즘 적용**: 여러 옵션 중 최적의 경로나 선택을 계산
387. **이력서 기술 분석 및 정렬**: AI에게 이력서를 분석시켜 원격 근무 역할에 부합하는 핵심 이전 가능 기술, 강점, 경험을 강조
388. **맞춤형 커리어 패스 제안**: 자신의 기술, 경험, 관심사를 제공하면 AI가 원격 친화적 커리어 패스와 구체적 역할을 제안
389. **원격 근무 최적화 이력서 작성**: 특정 역할/산업에 맞춘 전문적인 원격 근무 최적화 이력서 작성
390. **linkedin 프로필 최적화**: 원격 직무 기회를 끌어들이기 위한 LinkedIn 프로필 최적화
391. **직무 플랫폼 탐색 전략**: 특정 산업/역할의 원격 직무를 찾을 수 있는 상위 웹사이트 및 플랫폼 목록 제공
392. **맞춤형 지원서 작성**: 특정 직무 공고를 분석하여 요구사항에 가장 잘 맞는 이력서 및 커버레터 맞춤화
393. **면접 후 후속 조치**: 원격 직무 면접 후 전문적인 후속 이메일 작성
394. **급여 및 혜택 협상**: 원격 직무 제안에 대한 급여 및 혜택 협상을 위한 정중하고 전문적인 협상 이메일 작성
395. **구조화된 규칙 제공 (structured rule definition)**: AI가 따라야 할 구체적인 규칙들을 계층적으로 명확히 정의
396. **dsl 기반 테스트 작성 프롬프트 (dsl-driven test design)**: 테스트 코드를 DSL(Domain Specific Language)과 Protocol Driver Layer로 분리하여 가독성과 유지보수성 향상
397. **패턴 기반 리팩터링 가이드 (pattern-based refactoring)**: 구체적인 리팩터링 패턴과 원칙을 명시하여 일관된 코드 개선 유도
398. **soc 기반 설계 원칙 적용 (separation of concerns)**: 관심사의 분리 원칙을 명시하여 모듈화된 코드 구조 유도
399. **문서화 요구사항 명시 (documentation requirements)**: AI에게 다이어그램이나 설명 문서 작성을 요구하여 이해도 향상
400. **cqs(command-query separation) 원칙 적용**: Command 메서드와 Query 메서드를 명확히 분리하도록 AI에게 지시
401. **신중함 및 정확성 강조 기법**: AI가 서두르지 않고 신중하게 정보를 처리하고 답변하도록 유도
402. **전문가 관점 및 역할 부여**: 특정 분야 최고 전문가의 심층적이고 체계적인 사고방식과 지식 체계를 적용하도록 유도
403. **심층 분석 및 다각적 고려**: 단일 관점에서 벗어나 여러 각도에서 문제를 종합적으로 분석
404. **자기 비판 및 개선**: AI가 스스로 생성한 답변을 비판적으로 검토하고 개선
405. **문제 분해 및 구조화**: 큰 문제를 작고 다루기 쉬운 부분으로 나누어 체계적으로 접근
406. **손글씨 메모 디지털화**: GPT-4o의 비전 기능을 활용하여 손으로 쓴 메모를 디지털 텍스트로 변환
407. **색상 매칭 컨설팅**: 이미지 분석을 통한 색상 조합 추천 및 디자인 가이드
408. **복잡한 개념 설명 전문가**: 어려운 주제를 쉬운 언어로 설명하고 시각적 자료 분석
409. **피트니스 코치**: 운동 자세 분석 및 맞춤형 운동 프로그램 제공
410. **내비게이션 및 경로 계획 전문가**: 지도나 경로 이미지 분석 및 최적 경로 제안
411. **스킨케어 및 헤어케어 전문가**: 피부/모발 상태 분석 및 맞춤형 케어 조언
412. **로컬 llm을 활용한 무료 ai 코딩 지원**: Ollama 플랫폼을 통해 오픈소스 LLM을 로컬에서 실행하여 API 비용 없이 코딩 작업 지원
413. **하드웨어 리소스 최적화를 위한 모델 양자화(quantization)**: 모델 크기를 줄이면서 성능 저하를 최소화하는 양자화 기법 활용
414. **로컬 llm과 상용 모델 성능 비교 방법론**: 동일한 작업을 여러 모델로 테스트하여 비용 대비 성능 평가
415. **slow think 기법**: CoT 대비 4-10% 정확도 향상
416. **gpt actions**: Zapier, SerpAPI 등 외부 서비스 연동
417. **ollama + qwen 2.5 coder**: API 비용 없는 코딩 지원
418. **rag 기반 시스템 설계**: 벡터 검색, 문서 청킹, 하이브리드 검색, 캐싱 전략
419. **xp + ai 하이브리드**: Vibe Coding 한계 인식, 피드백 루프 강화, 검증 속도 맞추기
420. **하이브리드 검색**: 벡터 검색(의미 기반)과 키워드 검색(정확한 매칭)을 결합하여 검색 정확도를 높이는 기법
421. **도메인 특화 지식베이스 구축**: DDD, TDD 같은 개발 방법론이나 기업 내부 지식을 RAG 시스템에 통합하여 도메인 특화 응답 생성
422. **벡터 유사성 검색**: 텍스트를 벡터(임베딩)로 변환하여 저장하고, 쿼리와 유사도가 높은 문서를 검색
423. **임베딩 캐싱 및 재사용**: 한 번 생성된 벡터 스토어를 파일로 저장하고, 애플리케이션 재시작 시 로드하여 재사용
424. **planning-only mode (계획 전용 모드)**: AI가 라이브 코드베이스에 실제 변경을 가하지 않고, 샌드박스 환경에서 계획만 수립하도록 설정. 사용자가 계획을 검토하고 명시적으로 승인한 후에만 실제 변경 적용
425. **ai action logging & monitoring**: AI가 실행하는 모든 명령을 로깅하고, 이상 행동 패턴을 탐지하는 모니터링 시스템 구축
426. **pre-defined rollback plan**: AI 도구 사용 전에 자동 백업 및 복구 시스템을 구축하고, 롤백 절차를 문서화하여 정기적으로 테스트
427. **symbol-based code navigation**: `find_symbol`을 사용하여 클래스 전체 구조를 파악하고, `name_path`로 특정 클래스/메서드에 직접 접근. 필요한 심볼만 선택적으로 탐색
428. **hierarchical symbol overview**: `get_symbols_overview`로 파일의 최상위 심볼들(클래스, 메서드, 패키지 등)을 확인. 파일 전체를 읽지 않고도 코드의 구조적 개요 파악
429. **selective body inclusion**: `include_body=true` 옵션으로 필요한 메서드 본문만 선택적으로 가져옴. 전체 파일을 읽지 않아 토큰 절약
430. **ast-based relationship mapping**: AST 기반으로 코드의 의미론적 구조를 이해하여 클래스 간 연결 관계 파악
431. **예측 분석 (predictive analytics)**: AI가 버그 리포트와 코드 수정의 과거 데이터를 분석하여 발생할 수 있는 결함을 예측
432. **테스트 갭 분석 (test gap analysis)**: AI를 활용하여 테스트 스위트 내에서 보이지 않는 커버리지 구멍 발견
433. **이상 탐지 기반 결함 식별 (anomaly detection)**: 머신러닝 알고리즘이 시스템 기능의 이상 패턴을 탐지하여 숨겨진 결함의 지표로 활용
434. **ai 기반 리스크 기반 테스팅 (risk-based testing)**: AI가 결함이 발생하기 쉽고 가장 큰 영향을 미치는 고우선순위 영역을 식별하여 테스팅 리소스 집중
435. **nlp 기반 요구사항 분석 (requirements analysis with nlp)**: NLP가 사용자 스토리와 수락 기준을 검토하여 모호성을 식별하고, 초기 단계에서 예비 테스팅 프레임워크 제안
436. **ci/cd 파이프라인 ai 통합 (ai-enhanced ci/cd)**: AI가 운영하는 테스트를 CI/CD 파이프라인에 통합하여 코드 제출 후 자동 실행
437. **ai 테스트 우선순위 최적화 (test prioritization)**: AI 테스트 관리 시스템이 리스크 평가에 따라 자동으로 테스트 케이스 우선순위 선택
438. **ai 기반 코드 분석 (ai-powered code analysis)**: 정적 코드 분석 기법을 AI와 결합하여 워크플로우 내에서 직접 코드 테스트
439. **ai 기반 도메인 용어집 자동 생성**: DDD 전문가 역할을 부여하고 문서 분석을 통해 도메인 특화 용어 100개의 용어집을 CSV 형식으로 생성
440. **계산 위임 분리 원칙 (calculation delegation principle)**: 결정론적으로 계산할 수 있는 답변을 LLM에게 직접 계산하도록 요청하지 말고, 계산하는 코드를 생성하도록 요청
441. **llm 출력 필수 검증 규칙 (mandatory output verification)**: LLM이 "모든 테스트가 통과했다"고 보고해도 반드시 직접 실행하여 검증
442. **비결정론 허용 오차 설계 (non-deterministic tolerance design)**: LLM 기반 시스템에서도 비결정론적 출력에 대한 허용 오차를 설계에 반영. LLM의 출력 변동성을 예상하고 관리하는 메커니즘 구축
443. **kent beck의 ai 협업 원칙**: 지니 메타포, 빠른 테스트 피드백, 고수준 비전에 집중
444. **tests as executable specs**: TDD에서 테스트가 실행 가능한 사양이라는 개념을 AI 개발에 적용. 테스트를 사양으로 제공하여 검증 가능한 결과물 획득
445. **expressive pattern specification**: Commands, Queries, Events 같은 명시적이고 표현력 있는 패턴을 사용하여 시스템의 의도를 코드로 표현
446. **cynefin-based ai approach**: 문제의 복잡성 유형에 따라 AI 활용 전략을 달리하는 접근법. 명확한 사양이 가능한 영역과 탐색이 필요한 영역 구분
447. **문서 메타데이터 활용**: Document 객체에 메타데이터(소스, 날짜, 카테고리 등)를 포함시켜 검색 시 필터링/정렬 가능
448. **chat model과 embedding model 분리 선택**: RAG 구현 시 대화형 Chat Model과 별도로 임베딩 생성을 위한 Embedding Model을 별도 선택
449. **cot(chain of thought) 추론 모듈**: `dspy.ChainOfThought` 모듈을 사용하여 LLM이 답변 전에 추론 과정을 포함하도록 함
450. **bootstrapfinetune 자동 미세조정**: `dspy.BootstrapFinetune`으로 훈련 데이터셋 자동 구축 및 LLM 가중치 미세조정
451. **모듈 조합을 통한 파이프라인 구축**: Predict, ChainOfThought, ReAct, ProgramOfThought 등 모듈들을 조합하여 복잡한 다단계 AI 파이프라인 구성
452. **타입 힌트 기반 시그니처 정의**: `"text -> sentiment: Literal['positive', 'negative', 'neutral']"`와 같이 입출력 타입 명시로 LLM 응답 구조 강제
453. **구조화 텍스트에서 다이어그램 자동 생성**: 표준화된 Markdown 헤더를 스캔하여 Mermaid.js 클래스 다이어그램 자동 생성
454. **spec-first development (명세 우선 개발)**: TDD처럼 구현 전에 Markdown 명세를 먼저 작성. 명세 변경 시 Markdown 업데이트 후 코드 재생성
455. **immutable annotation testing**: AI가 코드를 생성할 때 테스트를 "불변의 주석"으로 활용. AI가 테스트를 변경/삭제하려는 시도 차단
456. **fast test suite monitoring**: 300밀리초 만에 실행되는 대규모 테스트 스위트를 유지하여 AI가 코드 변경할 때마다 즉각 검증
457. **language-agnostic experimentation**: 특정 언어에 대한 감정적 애착을 버리고 다양한 언어로 프로젝트 시작. AI가 대부분의 언어를 정확하게 작성 가능
458. **test deletion prevention**: AI가 "이 테스트만 제거하면 모든 게 작동해요"라고 제안할 때 단호히 거절. 테스트 불변성 강제
459. **anti-vibe coding discipline**: AI 도구 사용 시 "vibe coding"(코드 품질을 신경 쓰지 않는 작업) 경계. 진지한 작업 태도 유지
460. **human design oversight**: AI는 결합도 감소와 응집도 증가에 능숙하지 않음. 인간이 설계 결정을 주도하고, AI는 구현 세부사항 담당
461. **dual-purpose testing**: 테스트 코드를 AI 입력(프롬프트)으로 사용하면서 동시에 AI 생성 구현의 정확성 검증 도구로 활용
462. **model escalation strategy**: 로컬/저성능 모델로 시작하여 실패할 경우 점진적으로 상위 모델로 전환. 비용 효율성과 성능 균형
463. **태스크 파일 기반 작업 관리**: tasks/todo.md에 체크박스 형태의 할 일 목록을 작성하고, AI가 완료할 때마다 체크 표시하도록 하여 진행 상황을 투명하게 추적
464. **ui 스크린샷 활용**: 원하는 UI 디자인의 스크린샷을 Claude에 전송하여 해당 UI를 구현하도록 요청하는 방식으로 비주얼 레퍼런스 활용
465. **버그 수정을 위한 이미지 활용**: 에러 화면이나 버그 상황을 스크린샷으로 캡처하여 AI에게 전달, 시각적 맥락과 함께 문제 해결
466. **/clear 명령어 활용**: 하나의 세션을 몇 시간씩 지속하지 않고, 적당한 크기의 작업(태스크 파일 하나)을 완료할 때마다 /clear로 세션을 초기화하여 할루시네이션 감소 및 비용 절약
467. **ai 대기 시간 활용법 (둠스크롤 해킹)**: Claude가 코드를 생성하는 동안 소셜 미디어를 보는 대신, 별도의 AI 챗에서 아이디어 브레인스토밍, 프로젝트 성찰, 다음 단계 계획을 수행
468. **파일럿-승객 마인드셋**: AI 코딩 도구 사용 시 개발자는 '승객'이 아닌 '파일럿'이어야 함. AI가 생성한 코드는 시작점으로 삼고, 검토/수정/테스트 책임은 개발자에게 있음
469. **ai 에이전트의 자율적 계획 수립 활용**: 복잡한 작업 요청 시 AI가 자율적으로 계획(프로젝트 탐색 → 모델 생성 → 서비스 생성 → 컨트롤러 생성 → 설정 → 테스트)을 수립하도록 하고, 개발자가 단계별로 승인/거부 결
470. **스택 트레이스 모드 조절**: `stackMode: 'condensed'` 옵션으로 AI에게 제공할 디버깅 정보의 상세도를 조절. AI가 노이즈 없이 핵심 정보에 집중할 수 있도록 지원
471. **소스 위치 힌트 제공**: 로그에 `file:line:col` 정보를 포함시켜 AI가 문제 발생 위치를 정확히 파악하고 관련 코드를 찾아갈 수 있게 함
472. **파일 로깅을 통한 ai 분석 지원**: 로그를 파일로 저장하여 나중에 AI가 세션 전체를 분석할 수 있게 함. 실시간 디버깅뿐 아니라 사후 분석도 가능
473. **확장된 사고 유도 (extended thinking)**: 복잡한 문제에서 "think", "think harder", "think deeply" 등의 강화 구문을 사용하여 Claude의 추론 깊이를 조절할 수 있음
474. **실행 흐름 추적 (trace)**: "trace the login process from front-end to database"처럼 실행 흐름을 추적하여 시스템 이해
475. **# 단축키로 빠른 메모리 추가**: 입력을 `#`로 시작하면 메모리에 빠르게 규칙/정보 추가 가능
476. **테스트 주도 버그 수정**: 오류 재현 명령어, 스택 트레이스, 재현 단계를 Claude에게 제공하여 효율적 디버깅
477. **리팩토링 검증**: 리팩토링 후 테스트 실행을 함께 요청하여 동작 유지 검증
478. **test-aware refactoring**: TDD 러너 모드와 통합하여 코드 변경 시 실시간으로 테스트를 실행하여 변경사항을 즉각 검증하는 방식
479. **17가지 전문 모드 활용**: 개발 시나리오에 맞는 전문화된 모드 선택 - Architect(아키텍처 설계), Coder(구현), TDD(테스트 주도), Security(보안), DevOps(배포) 등으로 역할
480. **개발자 주도 페어 프로그래밍**: 어려운 작업에서는 개발자가 운전대를 잡고, Claude는 코드 기반 연구, 프로토타입 작성, 아이디어 검토, 단위 테스트 작성 용도로 활용
481. **"바이브 코딩" 방식**: 시스템의 경계와 잘 작동하는 것을 이해하기 위해 Claude를 활용한 탐색적 프로토타이핑 진행
482. **코드보다 아이디어 중심 사고**: 코드 자체는 더 이상 "소중한" 자산이 아니며, 아이디어와 최종 결과물에 집중. 코드는 언제든 다시 작성 가능한 것으로 인식
483. **빠른 피드백 사이클 구축**: 단일 피드백 채널을 만들고, 피드백을 받으면 가능한 한 빨리 문제를 해결한 후 즉시 알려주는 루프 형성으로 지속적 피드백 유도
484. **실제 사용 기반 평가("바이브" 테스트)**: 공식 벤치마크보다는 실제 업무에서 하루 종일 사용해보는 "바이브" 검사가 가장 중요한 모델/기능 평가 지표
485. **테스트 작성 위임**: 어려운 작업에서 핵심 구현은 직접 하되, 단위 테스트는 Claude에게 작성하게 하여 시간 절약
486. **마이크로서비스 패턴의 ai 적용**: 단일 모놀리식 에이전트 대신 각 에이전트가 특정 책임을 가진 서비스처럼 작동. MSA(Microservice Architecture)의 AI 버전으로 DDD 원칙 적용 가능
487. **역할 기반 에이전트 분리**: 전용 플래너(planner), 테스터(tester), 옵티마이저(optimizer) 등 역할에 따른 에이전트 분리로 단일 책임 원칙(SRP) 구현
488. **시크릿 모드 활용 (incognito mode for sensitive work)**: 메모리에 지속되지 않는 임시 대화 세션을 사용하여 실험적 쿼리, 기밀 브레인스토밍, 민감한 정보 처리.
489. **인라인 메모리 편집 (inline memory editing)**: 대화 중에 메모리를 직접 추가/업데이트/삭제. "TypeScript를 선호한다는 것을 기억해줘"
490. **메모리 내보내기/백업 (memory export/backup)**: 주기적으로 AI 메모리를 내보내어 백업하고 감사. 월별 내보내기, 분기별 백업 권장.
491. **하이브리드 메모리 관리 (hybrid memory management)**: 24시간 자동 합성과 즉시 수동 업데이트를 결합. 중요한 기술 결정은 즉시 메모리에 추가.
492. **tdd 페어 프로그래밍 메모리 (tdd pair programming memory)**: 테스트 패턴, 코딩 표준, 아키텍처 결정을 세션 간에 지속시켜 AI 페어 프로그래밍을 지속적인 멘토십으로 전환.
493. **계층적 콘텐츠 분류 시스템**: CSV 기반으로 콘텐츠를 Kind/SubKind로 이중 분류하고 메타데이터를 체계화.
494. **자동 콘텐츠 발견 및 인덱싱**: YouTube 플레이리스트, 블로그 RSS 등에서 콘텐츠를 자동으로 발견하고 인덱싱.
495. **todo 리스트 기반 태스크 실행 및 추적**: AI가 복잡한 작업을 여러 단계로 분해하여 Todo 리스트로 관리하고 실시간 상태 업데이트.
496. **배치 콘텐츠 요약 파이프라인**: 대량의 콘텐츠를 자동으로 처리하고 요약하여 구조화된 형태로 저장.
497. **모듈형 프로세서 아키텍처**: 콘텐츠 타입별로 전용 프로세서를 개발하고, 메인 빌드 스크립트가 적절한 프로세서를 자동 선택.
498. **문서 내용 분석 기반 hierarchical tagging**: AI가 문서의 내용을 분석하여 계층적 구조의 태그를 자동으로 설계하고 적용.
499. **ai 기반 디렉토리 구조 분석 및 최적 배치**: AI가 전체 vault의 디렉토리 구조를 분석하고 문서의 내용에 따라 가장 적절한 디렉토리를 자동 선택.
500. **`/undo`, `/redo`를 활용한 ai 출력 반복 개선**: AI가 수행한 변경사항을 `/undo` (Ctrl+X+U)로 즉시 되돌리고 `/redo` (Ctrl+X+R)로 다시 실행.
501. **다중 ai 모델 선택 및 전환**: Claude, OpenAI 등 다양한 AI 모델을 자유롭게 선택하고 전환. `opencode.json`에서 설정.
502. **`:bufdo e!`를 통한 ai 변경사항 즉시 반영**: AI가 파일을 수정한 경우 Neovim에서 모든 열린 버퍼를 새로고침하여 변경사항 확인.
503. **specification-based task decomposition**: AI가 명세와 계획을 받아 작은, 검토 가능한 덩어리로 분해. 각 작업은 독립적으로 구현/테스트 가능.
504. **living specification document**: 명세서를 프로젝트와 함께 진화하는 실행 가능한 아티팩트로 재정의. 진실의 원천(Source of Truth) 역할.
505. **iterative specification update**: 명세 업데이트만으로 계획 재생성과 구현이 가능하여 요구사항 변경에 유연하게 대응.
506. **legacy system intent restoration**: 레거시 시스템을 재구축할 때 "왜 이렇게 만들어졌는지"를 명세서로 복원.
507. **paradigm shift - from code to intent as source of truth**: "코드가 진실의 원천"에서 "의도가 진실의 원천"으로의 패러다임 전환.
508. **spec-kit 3단계 명령어 체계**: `/specify`로 아이디어를 구조화된 명세로, `/plan`으로 기술 구현 계획, `/tasks`로 실행 가능한 작업 목록 생성.
509. **constitution.md를 통한 불변 원칙 강제**: 헌법(constitution.md) 파일에 9개 조항의 개발 원칙 정의. 라이브러리 우선, CLI 인터페이스 의무, 테스트 우선 등 강제.
510. **ops-to-spec 양방향 피드백**: 운영 메트릭, 인시던트, 성능 데이터가 명세 업데이트에 반영되는 양방향 피드백 체계.
511. **ai 기반 독립 작업 분석 및 `[p]` 마커**: `/tasks` 명령어가 생성한 작업 목록에서 독립적 작업을 자동 식별하고 `[P]` 마커로 표시.
512. **구현 전 테스트 시나리오 및 계약 정의**: 명세 단계에서 API 계약, 데이터 모델, 테스트 시나리오를 먼저 정의. "테스트 없이는 코드 없음" 원칙.
513. **레거시 코드베이스의 명세 추출**: 기존 레거시 시스템의 동작을 분석하여 명세로 역공학한 후 현대적인 코드를 재생성.
514. **article i - 모든 기능을 독립형 라이브러리로 시작**: 모든 기능을 처음부터 독립형 라이브러리로 설계하여 재사용성과 테스트 용이성 확보.
515. **심각도 기반 ai 행동 제어**: 1-10 척도의 심각도 등급으로 AI 행동을 계층적으로 구조화. CRITICAL[10] 등급은 절대 차단.
516. **18가지 명령어 시스템**: /user:build, /user:design, /user:analyze 등 18가지 전문 명령어. --tdd, --ddd 플래그로 방법론 지정.
517. **작업별 최적 ai 모델 선택**: 간단한 작업에는 Sonnet, 중요한 재설계에는 Opus 사용. 작업 복잡도에 따라 자동 선택.
518. **상용구 없는 간결한 코드 생성**: AI가 기본적으로 간결하고 상용구 없는, 주석 없는 코드를 생성.
519. **graduated thinking depth flags**: `--think` (~4K), `--think-hard` (~10K), `--ultrathink` (~32K) 3단계 사고 깊이 제어.
520. **ultra-compressed output mode**: `--uc` 플래그로 출력을 60-80% 압축. 핵심 정보 유지, 장황함 제거.
521. **build system auto-detection**: `/build` 명령이 프로젝트의 빌드 시스템(npm, gradle 등)을 자동 감지하고 최적 전략 적용.
522. **safe mode execution**: `--safe-mode` 플래그로 프로덕션 환경에서 안전한 실행 보장. 파괴적 변경 방지.
523. **automated technical debt cleanup**: `/cleanup --safe` 명령이 기술 부채를 안전하게 식별하고 정리. 사용하지 않는 코드, 중복 제거.
524. **cognitive personas for domain-specific ai assistance**: 9가지 전문가 페르소나(Architect, Frontend, Backend, Security 등)를 부여하여 도메인별 전문성 활용. 플래그 시스템으로 일관되게 사용.
525. **specialized command framework for development lifecycle**: 개발 생명주기를 19개 전문 명령어로 구조화. 일관된 AI 협업 패턴 제공.
526. **introspection mode for framework improvement**: `--introspect` 플래그로 AI가 자신의 동작을 분석하고 개선점 찾기.
527. **multi-stage architecture flow with specialized commands**: DDD 설계 → 리소스 추정 → 보안 검토 → TDD 구현을 순차적으로 실행하는 체계적인 워크플로우.
528. **역할 기반 모델 할당 (role-based model assignment)**: AI 모델을 역할별로 분리 배치하는 전략입니다. 메인 모델(주요 작업), 리서치 모델(정보 수집), 백업 모델(대체용)로 구분하여 각 모델의 강점을 최적화하고 비용을 효율화합니다.
529. **모델 믹스 전략 (model mix strategy)**: YAML 설정을 통해 상황별로 다른 AI 모델 조합 전략을 정의하고 전환하는 기법입니다. 기본(default), 성능(performance) 등 다양한 전략을 사전 정의하여 필요에
530. **ai 작업 종속성 시각화 및 분석**: 작업 간 종속성을 자동으로 분석하고 시각화하여 순환 종속성 감지, 작업 우선순위 결정을 지원하는 기법입니다. `--depth` 매개변수로 하위 작업 생성 깊이를 제어할 수 있습니다
531. **4계층 문서화 시스템 (4-layer documentation system)**: AI와 협업하기 위한 계층적 문서 구조로, 헌법(Constitution: 불변 규칙), 명세서(Specification: 무엇을 왜), 계획(Plan: 기술적 제약), 작업(Tas
532. **ai를 위한 헌법(constitution) 문서 작성**: 프로젝트 전체에서 AI가 반드시 따라야 할 불변의 규칙들을 문서화하는 기법입니다. 예: "모든 API 응답에는 에러 코드 포함", "함수는 50줄 초과 불가".
533. **github spec kit을 활용한 자동 작업 생성**: `spec-kit plan` 명령을 실행하면 AI가 헌법, 명세서, 계획을 읽고 완벽한 순서로 작업 목록을 자동 생성합니다. 각 작업은 작고, 테스트 가능하며, 명확한 성공 기준을
534. **재개 가능한 진행 (resumable progress)**: 모든 결정을 마크다운 파일에 문서화하여 세션 종료 후에도 AI가 정확히 중단된 지점에서 재개할 수 있게 하는 기법입니다.
535. **작업별 커밋 전략 (task-based commit strategy)**: AI가 생성한 각 작업(15-30분 단위) 완료 후 즉시 커밋하는 전략입니다. 무언가 잘못되었을 때 롤백이 간단해집니다.
536. **추측 제거 원칙 (elimination of guesswork principle)**: AI는 코드를 작성함으로써 속도를 높이는 것이 아니라 추측을 제거함으로써 속도를 높입니다. 명세서는 항상 올바른 문제를 해결하고 있음을 보장합니다.
537. **v0 기반 ui 시작점 생성**: Vercel의 v0를 사용하여 UI 개발의 시작점을 빠르게 생성하는 기법. 대화형 채팅 인터페이스를 통해 초기 UI 프로토타이핑 시간을 크게 단축할 수 있습니다.
538. **살아있는 문서(living document) 유지 기법**: 계획 문서를 정적인 사양서가 아닌 구현 과정 전반에 걸쳐 지속적으로 업데이트되는 살아있는 문서로 관리합니다.
539. **brain dump 분석 및 마인드맵 생성**: brain dump 파일들을 분석하여 철학, 정체성, 전략 등으로 매핑된 마인드맵 시각화를 생성합니다.
540. **사용자 데이터 기반 개인화 프로파일링**: 공개된 데이터를 수집하여 10분 만에 사용자 프로파일을 완성하는 기법입니다.
541. **ai 기반 성과 측정 객관화**: AI를 활용하여 조직원의 성과를 객관적으로 측정하고 분석하는 방식.
542. **도메인 특화 ai 시스템 개발**: 물류 센터라는 특정 영역에 특화된 AI 시스템 개발 전략.
543. **데이터베이스 스키마를 single source of truth로 활용**: AI 기반 개발에서 데이터베이스 스키마를 명확하게 정의하여 프론트엔드와 백엔드 간의 일관성을 보장하는 기법입니다.
544. **custom commands 정의**: .claude/commands/ 디렉토리에 마크다운 파일로 사용자 정의 슬래시 명령어를 정의합니다.
545. **superclaude 패키지 활용**: 고급 명령어 모음을 제공하는 오픈소스 패키지입니다.
546. **bash mode 활용**: 느낌표(!)로 시작하여 Bash 명령어를 직접 실행하는 모드.
547. **ai 기반 엣지 케이스 테스트 제안**: GenAI가 애플리케이션의 동작을 분석하여 엣지 케이스나 실패 가능성이 높은 영역에 대한 테스트 케이스를 자동으로 제안합니다.
548. **인지 부하 전환 (cognitive load shifting)**: 개발자의 인지 부하를 구문 수준에서 시스템 사고 수준으로 전환하는 접근법.
549. **자율적 개발 루프 (autonomous development loop)**: AI 에이전트가 코드 작성 → 테스트 → 반복의 루프를 자율적으로 실행합니다.
550. **ai 페르소나를 통한 콘텐츠 생성**: "virtual adrianco"라는 작가 페르소나를 만들어 특정 주제에 관한 콘텐츠를 자동으로 생성합니다.
551. **대화형 장치 검색 시스템**: 자연어를 통해 IoT 장치를 검색하고 구성하는 시스템입니다.
552. **ai 코드 생성의 레거시 코드 인식**: Vibe coding으로 생성된 코드는 본질적으로 레거시 코드가 된다는 인식이 필요합니다.
553. **프로토타입/일회성 프로젝트에 vibe coding 집중**: Vibe coding은 프로토타입이나 일회성 프로젝트에 완벽하게 적합합니다.
554. **ai를 "짧은 목줄"로 통제하기**: AI를 "과도하게 열정적인 주니어 인턴 천재"로 대하고 매우 짧은 목줄을 유지해야 합니다.
555. **이론 구축(theory building) 중심 접근**: 프로그래밍의 본질은 코드 라인을 생산하는 것이 아니라 이론 구축입니다.
556. **실행 가능한 명세(executable specification) 기반 ai 프롬프팅**: AI를 프롬프팅할 때 자연어 대신 "실행 가능한 명세"를 사용합니다.
557. **ai 프로그래밍의 세 가지 핵심 문제 프레임워크**: 원하는 것을 정확히 명시하는 방법, 원하는 결과를 얻었는지 확인하는 방법, 점진적 개선을 유지하는 방법.
558. **점진적 개선(incremental development) 유지 전략**: AI가 코드를 처음부터 다시 생성하는 경향을 경계하고, 문제를 구획화합니다.
559. **의도 명세 중심의 ai 활용**: 구현 세부사항을 명시하는 것에서 의도를 더 명확하게 명시하는 방향으로 전환합니다.
560. **작업 분할 및 체크리스트 생성**: AI에게 작업을 체크리스트로 분할하고 커밋 지점을 명시하도록 요청하여 롤백 가능한 단위로 작업을 관리.
561. **svg 와이어프레임 생성**: 설계 문서의 UI 디자인을 SVG를 사용한 와이어프레임으로 변환 요청.
562. **ai tdd 강제 적용**: "비즈니스 로직 구현 작업은 반드시 테스트를 먼저 작성하고 구현하세요"라는 지침을 AI에게 제공.
563. **리팩토링 허락 프로세스**: AI가 리팩토링이 필요할 때 계획을 설명하고 사용자의 허락을 받은 후 진행하도록 지시.
564. **디버깅 설명 및 승인 프로세스**: 디버깅 시 AI가 원인과 해결책을 설명하고 허락을 받은 후 진행하도록 지시.
565. **최신 기술 문서 제공 기법**: AI가 1-2년 전의 라이브러리나 기술을 사용하는 경향이 있으므로, 최신 기술 문서를 직접 제공.
566. **마이크로서비스 기반 바이브 코딩**: 마이크로서비스 아키텍처가 바이브 코딩과 잘 맞는 이유는 작은 단위로 분할하여 개발할 수 있기 때문.
567. **시니어-ai 시너지 활용**: 시니어 개발자들이 축적한 경험과 패턴 인식 능력을 AI와 결합하여 더 높은 생산성을 발휘.
568. **tdd-guard**: TDD 프로세스에 가드레일을 사용한 에이전틱 코딩 접근법.
569. **ai 위임을 통한 개발 속도 향상 (fast)**: 시간이 많이 걸리는 작업을 AI에 위임하여 개발 속도를 극적으로 향상.
570. **ai 기반 범위 확장 전략 (ambitious)**: AI의 생산성 향상을 활용하여 원래 요청된 범위보다 더 넓은 기능을 구현.
571. **ai 코딩 지원의 현실적 효과 평가**: AI 코딩 어시스턴트가 주니어와 시니어 개발자에게 미치는 영향이 다를 수 있다는 점을 인지.
572. **키보드 입력이 병목이 아님**: 실제 개발의 병목은 키보드 입력이 아니라 문제 이해와 설계에 있음.
573. **llm 기반 문헌 요약**: 복합적인 연구 영역에서 다양한 과학 문헌을 LLM을 활용하여 요약.
574. **아이디어 브레인스토밍 및 작가의 블록 극복**: LLM을 초기 아이디어 발전 단계에서 브레인스토밍 파트너로 활용.

</details>
