# Batch 12 AI 활용 기법 추출 결과

**처리 일시**: 2026-01-03
**문서 범위**: 111-120번 (10개 문서)
**추출된 기법 수**: 77개

---

## 문서별 분석 결과

### 111. GOOSE AI로 어려운 쿼리 생성하기.md (6개 기법)

| 기법명 | 카테고리 | 설명 |
|--------|----------|------|
| AI 에이전트 기반 복잡 쿼리 생성 | AI 에이전트 | JDBC 연결이 가능한 AI 에이전트(Goose AI)를 활용하여 여러 개의 분산된 쿼리를 하나의 통합 쿼리로 변환 |
| DB 스키마 자동 탐색 | AI 에이전트 | AI 에이전트가 `database_info`, `list_tables`, `describe_table` 등의 도구를 사용하여 자동으로 데이터베이스 구조를 파악 |
| AI 도구 체이닝 (Multi-AI Workflow) | 워크플로우 | 1차로 Goose AI가 쿼리를 생성하고, 2차로 JetBrains AI Assistant에게 쿼리 성능 개선을 요청하는 다단계 AI 활용 워크플로우 |
| 요구사항 → 쿼리 변환 프롬프팅 | 프롬프트 엔지니어링 | 필요한 데이터 필드와 주석(설명)을 함께 제공하여 AI가 정확한 SQL 쿼리를 생성하도록 하는 프롬프트 기법 |
| Junie를 활용한 API 개발 | AI 에이전트 | JetBrains의 AI 코딩 에이전트인 Junie를 활용하여 생성된 쿼리를 기반으로 API를 개발 |
| 샘플 데이터 기반 정합성 검증 | 코드 품질 | AI가 생성한 쿼리를 샘플 데이터로 실행하여 결과의 정합성을 확인하는 검증 단계 |

---

### 112. GooseAI.md (7개 기법)

| 기법명 | 카테고리 | 설명 |
|--------|----------|------|
| MCP 기반 데이터베이스 통합 | AI 에이전트 | JDBC MCP Server를 통해 AI 에이전트가 직접 데이터베이스에 접근하여 DDL 조회, 테이블 구조 분석, 복잡한 SQL 쿼리 작성을 자동화 |
| Computer Controller를 통한 브라우저 자동화 | 워크플로우 | AppleScript를 활용하여 AI가 브라우저 열기, 웹페이지 탐색, 번역 등 컴퓨터 제어 작업을 자연어 명령으로 수행 |
| 웹 컨텐츠 스크래핑 및 요약 | 생산성 | AI 에이전트가 웹페이지를 스크래핑하여 기술 문서나 아티클을 자동으로 요약하고 핵심 내용을 추출 |
| JetBrains IDE 통합을 통한 코드 현대화 | 코드 품질 | AI 에이전트가 JetBrains IDE 도구를 활용하여 Java LTS 버전 업그레이드 및 최신 Java 기능을 활용한 코드 리팩토링을 자동화 |
| 자연어 기반 데이터베이스 스키마 탐색 | 생산성 | 자연어로 테이블 DDL 요청 시 AI가 데이터베이스 메타데이터를 탐색하고, 테이블 구조를 분석하여 사람이 읽기 쉬운 형태로 설명 |
| 복잡한 SQL 쿼리 자동 생성 | 생산성 | 테이블 간 관계가 명확하지 않은 경우에도 AI가 샘플 데이터를 분석하여 올바른 JOIN 조건을 추론하고 복잡한 다중 테이블 조회 쿼리를 생성 |
| Extension 기반 AI 에이전트 확장 | 도구 활용 | YAML 설정 파일을 통해 builtin 확장과 커스텀 MCP 서버를 조합하여 AI 에이전트의 기능을 확장 |

---

### 113. 챗GPT 이게 마지막입니다.md (7개 기법)

| 기법명 | 카테고리 | 설명 |
|--------|----------|------|
| Chain of Thought (CoT) 프롬프팅 | 프롬프트 엔지니어링 | AI가 복잡한 문제를 해결할 때 인간처럼 단계적으로 사고하도록 유도하는 기법 |
| Test-time Scaling | 프롬프트 엔지니어링 | AI가 "생각 중입니다" 상태에서 실제로 단계적 추론을 수행하도록 설계된 기법 |
| Knowledge Distillation (증류) | AI 에이전트 | 큰 모델이 학습한 지식을 작은 모델로 효율적으로 전달하는 기술 |
| 자가 학습 오답 노트 | AI 에이전트 | AI가 스스로 오답 노트를 작성하며 개선하는 학습 방식 (DeepSeek 등에서 사용) |
| 단계적 문제 분해 프롬프트 | 프롬프트 엔지니어링 | 복잡한 문제를 여러 단계로 나누어 AI에게 제시하는 기법 |
| AI 세대별 활용 전략 | AI 에이전트 | AI 발전 단계(인지 AI → 생성 AI → 에이전트 AI)에 따라 적절한 활용 분야를 선택하는 전략 |
| 감성적 답변 스타일 유도 | 프롬프트 엔지니어링 | AI에게 논리적(T형)보다 감성적(F형) 답변을 요청하여 더 인간적인 응답을 얻는 기법 |

---

### 114. Graphiti MCP Server.md (8개 기법)

| 기법명 | 카테고리 | 설명 |
|--------|----------|------|
| 시간 인식 지식 그래프 | AI 에이전트 | 사용자 인터랙션, 정형/비정형 데이터를 동적으로 통합하여 시간적 맥락을 유지하는 지식 그래프 구축 |
| MCP 기반 AI 도구 통합 | 도구 활용 | MCP 프로토콜을 통해 AI 어시스턴트가 지식 그래프 기능을 직접 호출할 수 있는 표준화된 인터페이스 제공 |
| 에피소드 기반 지식 축적 | AI 에이전트 | 텍스트, 메시지, JSON 데이터를 "에피소드" 단위로 지식 그래프에 추가하여 지속적인 컨텍스트 유지 |
| 하이브리드 검색 | AI 에이전트 | 시맨틱 검색과 하이브리드 검색을 결합하여 지식 그래프 내의 팩트와 노드 요약을 효과적으로 검색 |
| 구조화된 JSON 데이터 자동 엔티티 추출 | 워크플로우 | JSON 형식의 구조화된 데이터에서 엔티티와 관계를 자동으로 추출하여 지식 그래프에 통합 |
| 그룹 ID 기반 네임스페이스 관리 | AI-Ops | `group_id` 파라미터를 통해 지식 그래프 데이터를 네임스페이스로 분리하여 독립적인 컨텍스트 유지 |
| Cursor IDE 통합 및 에이전트 규칙 설정 | 생산성 | Cursor IDE의 User Rules에 Graphiti 규칙을 추가하여 AI 어시스턴트가 영구적인 기억을 유지하며 작업 |
| 커스텀 엔티티 타입 정의 | AI 에이전트 | `--use-custom-entities` 옵션을 통해 미리 정의된 ENTITY_TYPES를 사용하여 도메인 특화된 엔티티 추출 |

---

### 115. Here are 6 must-use MCP servers for all developers.md (6개 기법)

| 기법명 | 카테고리 | 설명 |
|--------|----------|------|
| 동적 웹 스크래핑 | 도구 활용 | Bright Data MCP 서버를 통해 AI가 웹사이트 구조에 따라 자동으로 최적의 스크래핑 도구를 선택 |
| 에이전트 지식 그래프 기억 | AI 에이전트 | Graphiti MCP 서버를 활용하여 AI 에이전트가 시간 인식 기반의 지식 그래프를 구축하고 쿼리하여 장기 기억력 확보 |
| 코드 저장소 대화형 분석 | 워크플로우 | GitIngest MCP 서버로 GitHub 레포지토리의 디렉토리 구조와 파일을 읽어 AI와 자연어로 대화하며 코드베이스를 분석 |
| AI 터미널 자동화 | AI 에이전트 | Terminal MCP 서버를 통해 Claude에게 전체 터미널 제어 권한을 부여하여 파일 조작, 명령 실행 등을 자동화 |
| Conda 환경 코드 실행 | 도구 활용 | Code Executor MCP를 통해 AI 에이전트가 지정된 Conda 환경에서 Python 코드를 실행하고 해당 환경의 라이브러리에 완전히 접근 |
| 다중 데이터 소스 통합 쿼리 | 도구 활용 | MindsDB MCP 서버로 다양한 플랫폼과 데이터베이스의 데이터를 연결·통합하여 MCP 클라이언트에서 통합 쿼리 |

---

### 116. How far can we push AI autonomy in code generation.md (10개 기법)

| 기법명 | 카테고리 | 설명 |
|--------|----------|------|
| 다중 에이전트 워크플로우 | AI 에이전트 | 생성 프로세스를 여러 전문화된 에이전트로 분할하여 각 단계마다 특정 역할과 지침을 가진 별도의 LLM 세션으로 처리 |
| 참조 애플리케이션 앵커 | 프롬프트 엔지니어링 | 참조 애플리케이션을 설정하고 MCP 서버를 통해 에이전트에게 샘플 코드를 제공하여 일관성과 컴파일 가능성을 보장 |
| 결정론적 스크립트 활용 | 워크플로우 | 부트스트래핑과 같이 확정적인 결과가 필요한 단계에서는 LLM 대신 셸 스크립트를 사용 |
| 스택별 특화 프롬프트 | 프롬프트 엔지니어링 | 범용 프롬프트 대신 대상 기술 스택에 특화된 기술과 프롬프트를 사용 |
| 정적 코드 분석 도구 통합 | 코드 품질 | AI가 대규모 변경 세트를 생성할 때 SonarQube 같은 정적 코드 분석 도구를 사용하여 코드 문제를 발견 |
| Human-in-the-Loop 필수화 | 워크플로우 | AI의 비결정론적 특성으로 인해 생성 과정을 감독하는 "인간 개입"이 필수적 |
| 명령어 허용 목록 관리 | 보안 | Kilo Code 같은 도구를 사용하여 터미널 명령어의 신중한 허용 목록을 구성 |
| 재사용 가능한 프롬프트 표준화 | 프롬프트 엔지니어링 | 팀 전반에 코딩 표준을 확산시키기 위해 재사용 가능한 프롬프트를 개발하고 관리 |
| AI 문제 패턴 인지 | AI-Ops | AI가 생성한 코드에서 나타나는 문제 패턴을 인지하고 이에 대한 검증 체계를 수립 |
| 점진적 복잡성 증가 전략 | 워크플로우 | AI 코드 생성을 간단한 도메인에서 시작하여 점진적으로 복잡성을 증가시키며 테스트 |

---

### 117. How I am using AI.md (15개 기법)

| 기법명 | 카테고리 | 설명 |
|--------|----------|------|
| 프로젝트 소스 통합 후 README 생성 | 워크플로우 | `find` 명령어로 프로젝트의 모든 관련 파일을 하나의 텍스트 파일로 통합한 후, 구조화된 프롬프트 템플릿을 사용해 README 문서 생성 |
| 패턴 기반 재사용 가능한 프롬프트 시스템 | 프롬프트 엔지니어링 | Fabric 도구를 활용하여 미리 정의된 패턴(프롬프트)을 CLI에서 파이프라인으로 연결하여 반복적인 AI 작업을 자동화 |
| 프롬프트 체이닝 | 워크플로우 | Fabric에서 여러 패턴을 파이프(`|`)로 연결하여 복잡한 AI 워크플로우 구성 |
| YouTube 콘텐츠 AI 분석 | 도구 활용 | Fabric의 `-y` 옵션으로 YouTube 영상 URL에서 트랜스크립트를 자동 추출한 후, 핵심 인사이트, 챕터 생성, 요약 등을 수행 |
| ask_uncle_duke 패턴을 통한 코드 리뷰 | 코드 품질 | Java/Spring 코드를 AI에게 제출하면 SOLID, DRY, TDD, 클린 코드 원칙에 기반한 분석과 개선 제안 |
| analyze_claims 패턴으로 진실 주장 분석 | 프롬프트 엔지니어링 | 특정 주장에 대해 객관적인 증거, 반론, 논리적 오류를 분석하여 균형 잡힌 평가 제공 |
| agility_story / create_user_story 패턴 | 생산성 | 간단한 주제나 기능 설명을 입력하면 User Story 형식 및 인수 기준을 자동 생성 |
| create_design_document / create_recursive_outline 패턴 | 워크플로우 | 프로젝트 주제만 입력하면 비즈니스 포지셔닝, 아키텍처, 보안, 테스트, 배포 계획이 포함된 설계 문서 자동 생성 |
| NotebookLM 멀티모달 콘텐츠 분석 | 도구 활용 | PDF, 문서, YouTube URL 등 다양한 소스를 업로드하고 AI에게 크로스 분석 요청 |
| 경쟁사 웹사이트 메시징 분석 | 프롬프트 엔지니어링 | 경쟁사 URL들을 입력 소스로 제공하고 "마케팅 연구자" 역할 부여 후 분석 |
| 콘텐츠 형식 변환 (Blog to Podcast) | 워크플로우 | NotebookLM으로 대화형 팟캐스트 초안 생성 후, 1인칭 시점 스크립트로 변환 |
| Avante.nvim을 통한 Cursor 스타일 AI 코딩 | 도구 활용 | Neovim에서 avante.nvim 플러그인을 사용하여 Cursor IDE와 유사한 AI 코딩 지원 환경 구축 |
| Mesh AI 플러그인으로 Obsidian에서 AI 활용 | 도구 활용 | Obsidian에서 Mesh AI 플러그인과 Fabric을 연동하여 노트 필기 중 AI 기능을 활용 |
| Jina AI 기반 웹 콘텐츠 마크다운 변환 | 도구 활용 | Fabric의 `-u` 옵션으로 웹 URL을 마크다운으로 스크래핑한 후 분석 |
| improve_prompt 패턴 | 프롬프트 엔지니어링 | 작성한 프롬프트를 AI에게 전달하여 더 명확하고 효과적인 프롬프트로 개선받는 메타 프롬프트 기법 |

---

### 118. How I am Using Claude Code Hooks To Fully Automate My Workflow.md (5개 기법)

| 기법명 | 카테고리 | 설명 |
|--------|----------|------|
| Lifecycle Hooks 자동화 | 워크플로우 | Claude Code의 생명주기 내 특정 시점에 사용자 정의 셸 명령을 자동으로 실행하여 필수 작업의 일관된 실행을 보장 |
| 도구 실행 전 사전 검증 자동화 (PreToolUse Hook) | AI-Ops | Claude Code가 도구를 실행하기 전에 환경 검증, 권한 확인, 필수 조건 검사 등을 자동으로 수행 |
| 도구 실행 후 자동 후처리 (PostToolUse Hook) | AI-Ops | 도구가 성공적으로 완료된 후 결과 로깅, 상태 업데이트, 다음 단계 트리거 등의 후처리 작업을 자동으로 수행 |
| 결정론적 작업 보장 패턴 | AI 에이전트 | LLM이 특정 명령을 실행할지 선택하는 것에 의존하지 않고, 필수 작업이 항상 실행되도록 보장 |
| AI 작업 알림 자동화 (Notification Hook) | 생산성 | Claude Code에서 알림이 전송될 때 커스텀 알림 시스템과 연동하여 작업 상태를 자동으로 전달 |

---

### 119. How to INSTANTLY Build AI Agents in N8N Using Claude.md (6개 기법)

| 기법명 | 카테고리 | 설명 |
|--------|----------|------|
| 멀티 AI 협업 프롬프트 체이닝 | 프롬프트 엔지니어링 | Claude에서 프롬프트 프레임워크를 먼저 생성한 후, GPT에게 전달하고, 최종적으로 Claude Opus4에서 완성된 프롬프트를 실행하는 다단계 AI 협업 |
| 프롬프트 프레임워크 요청 패턴 | 프롬프트 엔지니어링 | AI에게 직접 결과를 요청하기 전에, 먼저 "프롬프트를 잘 작성하기 위한 프레임워크/가이드라인"을 요청 |
| 구조화된 워크플로우 프롬프트 설계 | AI 에이전트 | N8N 워크플로우 생성을 위한 프롬프트를 5가지 핵심 섹션(Trigger, Input, Processing, Output, Error Handling)으로 구조화 |
| 직접 임포트 가능 출력 형식 요청 | 생산성 | AI에게 "valid n8n JSON that can be directly imported"와 같이 특정 도구에서 바로 사용 가능한 형식으로 출력을 요청 |
| 에러 핸들링 명시적 포함 | AI-Ops | 프롬프트에 에러 시나리오와 대응 방법을 명시적으로 포함하여 견고한 워크플로우 생성 |
| 성공 기준 정의 패턴 | 프롬프트 엔지니어링 | 프롬프트에 "Success Criteria" 섹션을 명시하여 AI가 생성할 결과물의 완료 조건을 명확히 정의 |

---

### 120. How-to-Code-Better-With-AI-Using-One-Weird-But-Powerful-Trick.md (7개 기법)

| 기법명 | 카테고리 | 설명 |
|--------|----------|------|
| Planning Before Coding | 워크플로우 | AI에게 코드 작성을 요청하기 전에 충분한 계획과 구조를 먼저 설계하여, AI를 레버리지로 활용 |
| Planning Spectrum (계획 스펙트럼) | 워크플로우 | 작업 복잡도와 코드 익숙함에 따라 계획의 정도를 조절 |
| 의도 기반 프롬프팅 | 프롬프트 엔지니어링 | "코드를 작성해줘" 대신 "이 아이디어를 올바르게 구현하도록 도와줘"라고 요청 |
| 계획 노트 작성 | 워크플로우 | 목표, 계획, 위험 요소를 미리 텍스트로 스케치한 후 AI에게 구현을 요청 |
| 전통적 관행을 AI 가이드라인으로 활용 | 코드 품질 | 테스트, 린터, 문서화, 명확한 네이밍을 AI를 위한 가이드라인으로 활용 |
| 사고 증폭기로서의 계획 | 생산성 | 계획을 "사고 증폭기(thinking amplifier)"로 활용 |
| AI 강점 활용 | AI 에이전트 | AI는 세부사항 채우기, 아이디어 확장, 의도를 문법으로 번역하는 데 뛰어나지만 "무엇이 중요한지"는 사람이 알려줘야 함을 인식 |

---

## 카테고리별 분류 요약

| 카테고리 | 기법 수 | 주요 내용 |
|----------|---------|----------|
| AI 에이전트 | 22 | GooseAI/Graphiti MCP, 다중 에이전트 워크플로우, 지식 그래프, 에피소드 기반 기억, 결정론적 작업 보장 |
| 프롬프트 엔지니어링 | 18 | CoT, 멀티 AI 협업, 패턴 기반 프롬프트, 의도 기반 프롬프팅, 성공 기준 정의 |
| 워크플로우 | 15 | 프롬프트 체이닝, Planning Before Coding, Human-in-the-Loop, 점진적 복잡성 증가 |
| 도구 활용 | 10 | MCP 서버 통합, YouTube 분석, 웹 스크래핑, Fabric 패턴, avante.nvim |
| 생산성 | 7 | 사용자 스토리 자동 생성, 알림 자동화, 콘텐츠 변환 |
| 코드 품질 | 5 | 정적 코드 분석, 코드 리뷰 자동화, 전통적 관행 활용 |
| AI-Ops | 5 | Claude Code Hooks, 에러 핸들링, AI 문제 패턴 인지 |
| 보안 | 1 | 명령어 허용 목록 관리 |

---

## 핵심 테마

### 1. MCP (Model Context Protocol) 생태계 확장
- **Graphiti**: 시간 인식 지식 그래프로 AI 에이전트에 장기 기억 부여
- **GooseAI**: JDBC MCP로 데이터베이스 직접 접근, 스키마 탐색, 쿼리 생성
- **6대 필수 MCP 서버**: Bright Data, Graphiti, GitIngest, Terminal, Code Executor, MindsDB

### 2. 다중 AI 협업 워크플로우
- **AI 도구 체이닝**: Goose AI → JetBrains AI → Junie 순차 활용
- **멀티 AI 프롬프트 체이닝**: Claude → GPT → Claude Opus4 협업
- **다중 에이전트 분할**: 요구사항 분석가 → 부트스트래퍼 → 백엔드 디자이너 등 역할 분리

### 3. 계획 우선 AI 활용
- **"코드는 저렴하지만, 사고는 그렇지 않다"**: AI가 코드 작성 비용을 낮췄기 때문에 설계와 아키텍처에 대한 사고력이 더 중요
- **Planning Spectrum**: 작업 복잡도에 따라 계획 수준 조절 (바이브 코딩 ↔ 철저한 계획)
- **결정론적 스크립트**: LLM 대신 확정적 결과가 필요한 단계에서 셸 스크립트 활용

### 4. Claude Code Hooks 자동화
- **Lifecycle Hooks**: PreToolUse, PostToolUse, Notification 시점에 커스텀 셸 명령 실행
- **결정론적 작업 보장**: LLM 선택에 의존하지 않고 필수 작업 항상 실행
- **AOP 관점의 설계**: Cross-cutting concerns를 Hooks로 분리

### 5. Fabric 패턴 시스템
- **재사용 가능한 프롬프트**: 패턴 기반 CLI 파이프라인
- **프롬프트 체이닝**: `echo "input" | fabric -p pattern1 | fabric -p pattern2`
- **다양한 분석 패턴**: extract_wisdom, ask_uncle_duke, analyze_claims 등

---

## 배치 통계

- **분석 문서 수**: 10개
- **추출된 기법 수**: 77개
- **문서당 평균 기법 수**: 7.7개
- **해당 없음 문서**: 0개 (모든 문서에서 기법 추출 성공)
