# Batch 14 결과 (131-140)

**처리 일시**: 2026-01-03
**문서 수**: 10개
**추출된 기법 수**: 85개

---

## 문서별 분석 결과

### 131. 인공지능이-우리-삶을-더-힘들게-만드는-진짜-이유.md
- **활용 가능 여부**: 아니오
- **추출된 기법**: 해당 없음
- **비고**: AI의 부작용과 제본스의 역설을 다루는 비판적 분석 문서

---

### 132. 이미-시작된-주니어-소멸-10년-뒤-우리-사회에-벌어질-끔찍한-일.md
- **활용 가능 여부**: 부분적
- **추출된 기법**: 8개

| # | 기법명 | 카테고리 | 설명 | 적용 상황 |
|---|--------|----------|------|-----------|
| 1 | AI를 헬스 트레이너처럼 활용 | 학습 전략 | 맞춤형 조언을 구하되, AI가 직접 사고하지 않고 본인이 직접 실행 | 수동적 의존을 피하고 능동적 사고력 유지 |
| 2 | 현재 조건 설명 후 맞춤형 레시피 요청 | AI 프롬프트 기법 | 자신의 상황을 명확히 전달하고 AI로부터 맞춤형 조언 수집 | 구체적이고 개인화된 AI 응답 획득 필요 시 |
| 3 | AI를 조교/튜터로 활용 | 교육 기법 | 직접적인 답변보다는 가이드와 피드백을 제공하도록 AI를 활용 | 학습 과정에서 자기주도성 유지 필요 시 |
| 4 | 질문 능력 개발 (CQO 역할) | 인지 기법 | 기계적 계산은 AI에게 맡기고, 인간은 "최고 질문 책임자"로서 올바른 질문 능력 개발 | AI와 인간의 역할 분담 시 |
| 5 | 교양 기반 학습 | 교육 전략 | 풍부한 교양과 배경 지식을 바탕으로 좋은 질문을 던지고 AI의 답변을 이해하는 능력 배양 | AI 시대 핵심 경쟁력 구축 |
| 6 | 세 단계 학습 모델 이해 | 교육 기법 | 인지 → 이해 → 응용의 3단계 학습 과정을 명확히 하고, 각 단계에서 AI의 역할 제한 | 교육 목표 설정 시 |
| 7 | 뉴런 연결 기반 학습설계 | 학습 이론 | 풍부하고 다양한 신경망 연결을 만드는 학습 활동 설계 | 개인/조직 학습 프로그램 설계 시 |
| 8 | AI 공동 이익 구조 설계 | 조직/사회 전략 | 공동체가 AI 기술에 투자하여 생성된 가치를 함께 누리는 제도화 | 지역/조직 차원의 AI 도입 시 |

**핵심 인사이트**:
- "대신 해달라"는 위임 활용이 아닌 "함께 하기" 방식의 협력적 활용이 사고력 유지의 핵심
- 정답 제시가 아닌 좋은 질문을 던질 수 있는 능력 개발이 AI 시대의 교육 목표

---

### 133. AI 시대의 엔지니어 성장에 대한 재고.md
- **활용 가능 여부**: 부분적
- **추출된 기법**: 8개

| # | 기법명 | 카테고리 | 설명 | 적용 상황 |
|---|--------|----------|------|-----------|
| 1 | AI를 멘토로 활용한 학습 | 학습 방법론 | AI를 단순 코드 생성이 아닌 문제 해결과 코드 이해를 위한 멘토로 활용. AI의 무한 인내심 활용 | 주니어 개발자의 지속적 학습 |
| 2 | 의도적 연습(Deliberate Practice) 설계 | 업무 설계/멘토링 | 잘 정의된 작업, 반복적 유사 작업, 페어 프로그래밍, 즉각적 피드백을 통해 학습 효과 극대화 | 주니어 엔지니어 온보딩 |
| 3 | 조기 코드 리뷰 능력 개발 | 기술 역량 개발 | 주니어 단계부터 코드 리뷰를 적극 수행하여 비판적 사고력 강화 | 신입/주니어 개발자 교육 |
| 4 | 기초 지식 강화 교육 | 교육 커리큘럼 | 시스템 구성, 데이터베이스, 클라우드 이해 등 기초 개념을 더욱 적극적으로 학습 | AI 도구 의존도 증가 시대의 신입 교육 |
| 5 | 비판적 사고 및 출처 검증 능력 | 교육 커리큘럼 | 정보의 출처 확인, LLM의 본질에 대한 건전한 회의주의 개발 | AI/LLM 활용 환경에서의 개발자 교육 |
| 6 | 시스템 사고(Systems Thinking) 개발 | 기술 역량 개발 | 전체 시스템이 어떻게 연결되는지 이해하는 능력을 주니어 단계부터 강화 | 아키텍처 이해, 독립적 업무 수행 능력 향상 |
| 7 | 무의식적 유능력의 의식적 설명 | 멘토링/교육 | 숙련 엔지니어가 자동으로 수행하는 결정과 판단을 의식적으로 설명하고 가르칠 수 있도록 교육 | 시니어 엔지니어의 멘토링 역량 강화 |
| 8 | "왜"에 대한 구체적 설명 | 멘토링/교육 | "베스트 프랙티스"라는 추상적 표현 대신 구체적 이유와 근거 제시 | 멘토링, 코드 리뷰, 기술 의사결정 설명 |

**핵심 인사이트**:
- AI 멘토링의 이중성: 무한 인내심은 장점이지만 잘못된 개념 습득을 조기 발견하지 못할 수 있음
- 의도적 연습의 붕괴를 인식하고, 의도적으로 더 좋은 학습 경험을 설계해야 함

---

### 134. AI 시대에 프로그래밍을 배워야 하는 이유.md
- **활용 가능 여부**: 부분적
- **추출된 기법**: 3개

| # | 기법명 | 카테고리 | 설명 | 적용 상황 |
|---|--------|----------|------|-----------|
| 1 | 도메인 지식 기반 프롬프팅 | AI 활용 | 미술사 지식과 예술 용어를 이용하여 Midjourney에 더 정확한 프롬프트 입력 | 이미지 생성 AI 등 생성형 AI 도구 사용 시 |
| 2 | 기술 용어를 통한 AI 도구 활용 | AI 활용 | 소프트웨어 개발 언어와 기술 용어를 이해함으로써 LLM에 더 정확하게 요청사항 전달 | 과학자, 분석가 등이 AI 코딩 도구 활용 시 |
| 3 | 10x 전문가 전략 | 생산성 향상 | 기술에 능숙한 사람이 AI 도구를 효과적으로 조정하여 10배의 생산성과 영향력 달성 | AI 도구를 전문적으로 다루고자 할 때 |

**핵심 인사이트**:
- "정확한 언어는 정확한 결과를 낳는다" - 도메인 용어를 정확히 사용할 수 있는 능력이 AI 도구 활용의 핵심
- 기술이 쉬워질수록 더 많은 사람들이 그 기술을 배우고 활용하게 됨

---

### 135. AI를 활용한 개발 가이드.md
- **활용 가능 여부**: 예
- **추출된 기법**: 20개

| # | 기법명 | 카테고리 | 설명 | 적용 상황 |
|---|--------|----------|------|-----------|
| 1 | 명확한 프롬프트 작성 | 프롬프트 전략 | "코드만 제공해주세요" 같은 구체적인 지시어로 필요한 정보만 요청 | LLM의 과도한 답변으로 인한 이해도 저하 시 |
| 2 | 단계별 질문 방식 | 프롬프트 전략 | 복잡한 요구사항을 작은 단위로 나누어 순차적으로 질문 | 복잡한 시스템 설계 및 학습 시 |
| 3 | 학습 중심 접근 | 개발 프로세스 | 코드를 즉시 적용하지 않고 이해를 위한 별도 시간 할당, 직접 재작성해보기 | AI 생성 코드의 깊이 있는 이해 필요 시 |
| 4 | 정보 청크화(Chunking) | 학습 방법 | 복잡한 코드/개념을 작은 단위로 나누어 요청 및 이해 | 대규모 시스템 개발 시 |
| 5 | 시각화 도구 활용 | 커뮤니케이션 | UML 다이어그램이나 플로우차트 생성 요청 | 아키텍처 설계 및 팀 소통 시 |
| 6 | 소크라테스식 대화 | 학습 방법 | "이 패턴을 사용한 이유는 무엇인가요?" 같은 질문으로 더 깊이 있게 이해 | 핵심 설계 개념 습득 시 |
| 7 | 설계 결정 문서화 | 문서화 전략 | 코드 생성 시 설계 결정과 의도를 LLM에 요청하여 문서화 | 코드 유지보수 및 향후 변경 시 |
| 8 | ADR(Architecture Decision Records) 작성 | 문서화 전략 | 주요 아키텍처 결정사항을 ADR 형식으로 기록 | 장기적인 시스템 관리 및 팀 지식 공유 |
| 9 | 상세한 코드 주석 | 코드 품질 | 코드의 의도와 맥락을 명시하는 주석 추가 | 팀원과의 협업 및 미래의 유지보수 |
| 10 | LLM 대화 세션 관리 | 프로세스 관리 | 동일 프로젝트 관련 LLM 대화를 저장하고 참조 | 연속적인 개발 작업에서 일관성 유지 |
| 11 | 대화 내용 요약 및 제공 | 커뮤니케이션 | 후속 변경 작업 시 이전 대화 내용을 요약하여 LLM에 제공 | 코드 수정/확장 시 기존 의도 전달 |
| 12 | 대화 히스토리 관리 시스템 | 도구/인프라 | 프로젝트 관련 대화를 체계적으로 관리하는 도구 활용 | 팀 규모 프로젝트에서 지식 관리 |
| 13 | 코드 리뷰 프로세스 | 팀 협업 | AI 생성 코드를 팀원과 함께 리뷰하여 집단 지식 형성 | AI 생성 코드의 품질 보증 및 팀 학습 |
| 14 | 정기적 지식 공유 세션 | 조직 관리 | 코드베이스에 대한 팀의 정기적인 지식 공유 회의 개최 | 팀 일관성 및 협업 수준 향상 |
| 15 | 모듈화 및 관심사 분리 | 아키텍처 설계 | 코드를 작은 모듈로 분리하여 각 부분의 맥락과 책임을 명확히 함 | 변경의 영향 범위 최소화 및 유지보수성 향상 |
| 16 | DDD 바운디드 컨텍스트 정의 | 아키텍처 설계 | Domain Driven Design 원칙에 따라 바운디드 컨텍스트를 명확히 정의 | 도메인 특화 시스템 개발 시 |
| 17 | 상세한 커밋 메시지 | 버전 관리 | 커밋 메시지에 변경 이유와 맥락을 상세히 기록 | 코드 변경 이력의 추적 가능성 |
| 18 | Git 이슈/PR 연결 기능 활용 | 버전 관리 | Git의 이슈/PR 연결 기능으로 코드와 요구사항 변경의 연결성 유지 | 요구사항 추적성 및 변경 관리 |
| 19 | 지속적인 리팩토링 | 개발 프로세스 | 코드 베이스를 주기적으로 정리하고 개선하여 이해도 유지 | 기술 부채 관리 및 코드 품질 유지 |
| 20 | 보이스카우트 룰 적용 | 개발 문화 | 코드를 발견했을 때보다 더 깨끗하게 남기기 원칙 적용 | 점진적인 코드 품질 개선 |

**핵심 인사이트**:
- AI 도구의 한계를 인식한 실용적 전략 제시
- 맥락과 의도 보존의 중요성: LLM은 과거 대화 컨텍스트를 유지하지 못하므로 문서화(ADR), 커밋 메시지 등으로 의도를 시스템에 저장

---

### 136. AI Interventions to Reduce Cycle Time in Legacy Modernization.md
- **활용 가능 여부**: 예
- **추출된 기법**: 10개

| # | 기법명 | 카테고리 | 설명 | 적용 상황 |
|---|--------|----------|------|-----------|
| 1 | 코드 트레이싱(Code Tracing) | 정적 분석 | AST 체계적 순회를 통해 현대화 작업 관련 코드 컨텍스트를 정의하는 트리 구조 생성 | 레거시 코드베이스에서 영향받는 부분 식별 |
| 2 | 마크다운 형식 컨텍스트 | LLM 최적화 | H3 헤딩으로 메서드/클래스 이름을 라벨링하여 코드 컨텍스트를 마크다운으로 포맷 | LLM에 코드 정보 제공 시 |
| 3 | 데이터베이스 컨텍스트 수집 | 정적 분석 | ANTLR을 사용하여 소스 코드 내 SQL 구문 파싱하여 테이블, 저장 프로시저 식별 | 데이터베이스 종속성 파악 |
| 4 | PlantUML 시각화 | 시각화 | 트레이스된 코드와 데이터베이스 컨텍스트를 PlantUML 형식으로 변환 | 아키텍트/엔지니어의 아키텍처 이해도 향상 |
| 5 | 비즈니스 요구사항 복구(BRD 생성) | LLM 프롬프팅 | 수집된 코드·데이터베이스 컨텍스트를 사용하여 비즈니스 요구사항 문서를 LLM으로 생성 | 레거시 시스템의 개념 복구 |
| 6 | 반복적 프롬프팅 전략 | LLM 최적화 | 대용량 컨텍스트(>150k 토큰)를 50k 토큰 단위로 청킹하여 순차적 요약 후 합성 | 토큰 제한 내에서 대규모 코드 분석 |
| 7 | 연쇄 사고 추론(Chain-of-Thought) | LLM 프롬프팅 | 합성 단계에서 체크리스트, 섹션 완전성 확인을 활용하여 출력 품질 향상 | 청킹된 컨텍스트 재합성 시 일관성 보장 |
| 8 | CodeBERT 임베딩 검색 | 벡터 검색 | 저장소의 모든 코드를 메서드 수준으로 청킹하고 CodeBERT로 임베딩 생성 후 검색 | 초기 트레이스 범위 외 관련 코드 발견 |
| 9 | 프롬프트 엔지니어링 | LLM 최적화 | 기술적·비기술적 사용자 모두에게 유용한 BRD를 생성하는 단일 프롬프트 설계 | 다양한 이해관계자와의 소통 개선 |
| 10 | 토큰 수 추정 및 청킹 | LLM 최적화 | Tiktoken 라이브러리 또는 "1토큰=4문자" 규칙으로 토큰 수 추정하여 분할 | 대규모 컨텍스트 처리 시 비용·성능 최적화 |

**핵심 인사이트**:
- 개념 복구가 핵심: 소프트웨어 현대화의 병목은 코드 생성이 아닌 개념화(conceptualization)
- 마크다운 형식의 중요성: LLM에 원시 AST보다 마크다운 형식으로 구조화된 컨텍스트 제공 시 더 나은 결과

---

### 137. AI Issues.md
- **활용 가능 여부**: 아니오
- **추출된 기법**: 해당 없음
- **비고**: LLM의 TDD 적용 시 한계점 및 속도 문제만 다루는 간략한 메모 문서

---

### 138. AI Limitations.md
- **활용 가능 여부**: 부분적
- **추출된 기법**: 6개

| # | 기법명 | 카테고리 | 설명 | 적용 상황 |
|---|--------|----------|------|-----------|
| 1 | Augmented Coding | 코딩 스타일 | Vibe Coding 대신 가독성과 설계 개선에 중점을 두는 코딩 접근법 | 핵심 도메인 코드를 다룰 때 |
| 2 | 명세 기반 접근법 | 설계/협력 | AI와의 협업 시 테스트를 명확히 정의하고, 복잡한 문제를 작은 feature 단위로 분해 | AI 어시스턴트와 협력할 때 |
| 3 | 작은 단위의 반복적 문제 제시 | 프롬프트 엔지니어링 | 여러 개의 테스트나 기능을 한 번에 요청하지 않고 작은 단위로 반복 제시 | AI의 결과 품질을 높이고자 할 때 |
| 4 | 인간의 직관과 검토 기반 피드백 | AI 협력 워크플로우 | AI 제안이 어려울 때 인간이 먼저 시도한 후 그 결과를 system prompt에 반영 | 더 정확한 프롬프트 설계 필요 시 |
| 5 | 직접적 개입과 프롬프트 개선 | AI 협력 워크플로우 | AI가 잘못된 방향으로 갈 경우, 더 나은 프롬프트 설계나 직접적인 코드 수정 개입 | AI 생성 코드 품질이 부족할 때 |
| 6 | 문제 정의 & 분해 능력 개발 | 개발자 역량 | 빠르게 구현, 검토할 수 있는 단위로 문제를 나누는 능력 | 인간-AI 협력 환경에서의 핵심 역량 |

**핵심 인사이트**:
- AI는 명확한 명세(테스트)를 받을 때, 작은 단위의 문제를 반복적으로 제시받을 때 더 좋은 결과 생산
- Essential Complexity(핵심 도메인 로직)는 AI가 학습하지 못하므로 개발자의 Augmented Coding이 필수

---

### 139. AI-문제점-종합-분석.md
- **활용 가능 여부**: 부분적
- **추출된 기법**: 18개

| # | 기법명 | 카테고리 | 설명 | 적용 상황 |
|---|--------|----------|------|-----------|
| 1 | Acceptance Testing을 Single Source of Truth로 활용 | 개발 방법론 | 프롬프트 대신 Acceptance Test를 코드의 진정한 명세로 사용 | 프롬프트-코드 동기화 문제 해결 시 |
| 2 | Specification-Driven Development | 개발 방법론 | 프롬프트 자체가 아닌 상위의 Specification을 관리하고, 코드 수정 시 Specification 먼저 수정 | AI 코드 생성 후 유지보수 단계 |
| 3 | 계층화된 에이전트 (Tmux Orchestrator) 활용 | 시스템 설계 | 컨텍스트 윈도우 문제를 극복하기 위해 작은 작업으로 분해하여 에이전트 활용 | 대규모 프로젝트에서 컨텍스트 제한 극복 시 |
| 4 | Assert-First 마인드셋 | TDD 방법론 | 먼저 테스트로 "이렇게 되어야 한다"를 정의한 후 AI에게 구현 요청 | AI와 협업하는 모든 코딩 작업 |
| 5 | 보안 중심 프롬프팅 | 프롬프트 엔지니어링 | 프롬프트에 보안 제약을 명시적으로 포함 | 보안이 중요한 코드 작성 시 |
| 6 | 커스텀 지침(Custom Instructions) 설정 | 프롬프트 엔지니어링 | Claude의 agents.md, GitHub Copilot 조직 설정 등으로 보안/코딩 표준 강제 | 조직 차원의 AI 도구 거버넌스 |
| 7 | LLM 도전 기술 | 프롬프트 엔지니어링 | 구체적 예시 제공, 링크/참조 추가, 보안 영향 설명 요청, 금지 영역 명시 | 정확도가 필요한 기술 작업 |
| 8 | Zero Trust를 AI 코드에도 적용 | 거버넌스 | AI 출처와 관계없이 기존 SDLC 프로세스(코드 리뷰, 보안 감사, 테스트) 유지 | 조직의 모든 AI 코드 통합 |
| 9 | Provenance(출처 증명) 체계화 | 거버넌스 | 훈련 데이터, AI 모델, AI 애플리케이션의 출처 추적 | AI 모델과 시스템의 신뢰성 확보 |
| 10 | 작은 단계로 AI 작업 분해 | AI 활용 전략 | "한 번에 하나의 작은 기능만 구현"으로 AI에게 생성 요청 제한 | 검증 가능성 향상 필요 시 |
| 11 | 바이브 코딩 절차 | AI 협업 방법론 | ①요구사항 명세서 질문 → ②설계 문서 → ③와이어프레임 → ④체크리스트 작성 순서 | 새로운 프로젝트나 기능 개발 시 |
| 12 | AI를 멘토로 활용하기 | 학습 방법론 | AI가 작성한 코드에 "왜 이렇게 했어?"를 반복해서 질문하며 학습 | 신입/주니어 개발자의 학습 가속화 |
| 13 | RAG (Retrieval Augmented Generation) | AI 한계 극복 | 질문과 관련된 정보를 지식 데이터베이스에서 검색하여 프롬프트에 추가 | AI의 환각 완화, 최신 정보 활용 필요 시 |
| 14 | 문제 정의와 분해 능력 | 개발자 역량 | 모호한 요구사항을 구체적 작업 단위로 분해하고 AI가 처리할 수 있도록 명세화 | AI 활용 효율성 향상 필요 시 |
| 15 | Augmented Coding 방식 | 개발 패러다임 | 대체가 아닌 보조 도구로 AI 활용, 인간이 주도권 유지 | 핵심 도메인, 프로덕션 코드 개발 |
| 16 | TDD와 AI 협업 | 개발 방법론 | Red-Green-Refactor 사이클에서 각 단계마다 AI 활용, 테스트로 검증 | 모든 AI 협업 개발 작업 |
| 17 | 의도적 연습 설계 | 인력 개발 | 시니어가 업무를 효과적인 의도적 연습이 되도록 구성하여 주니어 성장 촉진 | 팀의 주니어 개발자 육성 |
| 18 | 온보딩 기간 단축 전략 | 신입 교육 | AI를 학습 도구로 활용하여 온보딩 24개월 → 9개월 단축 | 신입 개발자 빠른 역량 증진 필요 시 |

**핵심 인사이트**:
- Specification-Verification의 인간 영역화: AI는 Translation(코드 생성)을 가속화했지만, Specification(명세)과 Verification(검증)은 여전히 인간의 책임
- Acceptance Test가 코드의 유일한 신뢰할 수 있는 명세가 되어야 함
- 조직 차원의 거버넌스 부재 현황: 개발자 34%가 코드 60% 이상을 AI로 생성하지만, 거버넌스 정책은 18%의 조직만 보유

---

### 140. AI-Paradox-Faster-Coding-Slower-Shipping-Addy-Osmani.md
- **활용 가능 여부**: 예
- **추출된 기법**: 12개

| # | 기법명 | 카테고리 | 설명 | 적용 상황 |
|---|--------|----------|------|-----------|
| 1 | Context Engineering | 프롬프트 최적화 | AI 에이전트에게 필요한 모든 것(올바른 파일, 예시, 히스토리, 도구, 제약 조건)을 제공 | 낮은 정확도 문제 해결 시, 복잡한 태스크 처리 시 |
| 2 | Spec-driven Development | 개발 방법론 | AI 프롬프트 전에 상세한 계획/스펙을 먼저 작성 | 대규모 프로젝트, 복잡한 기능 구현 |
| 3 | Learnings.md 패턴 | 문서화 기법 | 에이전트가 태스크 완료 후 핵심 인사이트를 저장하여 자기 개선 사이클 구성 | 반복적인 작업, 장기적 프로젝트 관리 |
| 4 | Trio Programming | 협업 방법론 | 시니어 + 주니어 + AI로 구성하여 전문 지식 유지, 속도 향상, 품질 보장 동시 달성 | 주니어 개발자 멘토링, 높은 품질 요구 프로젝트 |
| 5 | Socratic Code Review | 리뷰 방법론 | AI 생성 코드에 대해 개발자가 설명하도록 강제하여 이해도 검증 | 주니어 개발자의 기술력 검증, AI 생성 코드 검증 |
| 6 | No-AI Challenge | 기술 역량 유지 | 주중 특정 요일 또는 백로그의 특정 태스크에서 의도적으로 AI 미사용 | 팀의 비판적 사고 능력 유지, 기초 기술력 보존 |
| 7 | Vibe Coding (프로토타입) | 개발 속도 향상 | AI를 활용한 빠른 프로토타입 생성으로 인터랙티브 피드백 구성 | 아이디어 검증, 디자이너-엔지니어 협업, MVP 개발 |
| 8 | Chrome DevTools MCP 활용 | 디버깅 도구 | AI 코딩 어시스턴트가 라이브 브라우저와 상호작용 | 프론트엔드 버그 해결, 성능 최적화 |
| 9 | 자동 Context Summarization | 컨텍스트 관리 | Cline 같은 도구로 컨텍스트 윈도우 한계 도달 시 이전 세션 자동 요약 | 장기 프로젝트, 대규모 코드베이스 |
| 10 | Memory Bank | 컨텍스트 관리 | 여러 세션에 걸쳐 컨텍스트를 유지하는 구조화된 문서 시스템 | 다중 세션 프로젝트, 복잡한 도메인 지식 공유 |
| 11 | Voice Dictation 활용 | 생산성 향상 | 음성 받아쓰기로 타이핑보다 3-5배 빠른 속도 달성 | 원격 근무, 빠른 아이디어 표현 필요 시 |
| 12 | 테스트 주도 검증 | 품질 보증 | AI 코딩의 안전망으로 테스트, CI/CD, 명확한 문서화를 선행 | 모든 AI 활용 프로젝트의 기본 조건 |

**핵심 인사이트**:
- AI 역설의 실재성: 개별 개발자 생산성은 21% 향상되지만, PR 리뷰 시간 91% 증가, PR 크기 154% 증가로 배포 속도 저하 가능
- Context Engineering의 우선순위: Prompt Engineering보다 올바른 컨텍스트 제공이 훨씬 중요
- 70% 문제의 이해: AI는 문제의 70%까지 빠르게 도달하지만, 마지막 30%는 시니어에게 오히려 더 느릴 수 있음

---

## Batch 14 요약

### 처리 결과
| 구분 | 문서 수 | 비고 |
|------|---------|------|
| 활용 가능 (예) | 3개 | 135, 136, 140 |
| 부분적 활용 가능 | 5개 | 132, 133, 134, 138, 139 |
| 해당 없음 | 2개 | 131, 137 (AI 한계/경고 문서) |

### 카테고리별 기법 분류
| 카테고리 | 기법 수 | 주요 기법 |
|----------|---------|-----------|
| 프롬프트/LLM 최적화 | 18 | Context Engineering, 청킹, 마크다운 형식화, 반복적 프롬프팅 |
| 개발 방법론 | 12 | Spec-driven Development, TDD, Acceptance Testing |
| 학습/교육 | 15 | 의도적 연습, AI를 멘토로 활용, 소크라테스식 대화 |
| 협업/팀워크 | 10 | Trio Programming, Socratic Code Review, 코드 리뷰 프로세스 |
| 문서화 | 8 | ADR, Learnings.md, 설계 결정 문서화 |
| 도구/인프라 | 7 | Memory Bank, Chrome DevTools MCP, PlantUML |
| 거버넌스/보안 | 6 | Zero Trust, Provenance, 커스텀 지침 |
| 개발자 역량 | 9 | 문제 정의/분해, 비판적 사고, 시스템 사고 |

### 핵심 테마

1. **Specification-First 패러다임**
   - 프롬프트가 아닌 Specification/Acceptance Test가 코드의 진정한 명세
   - Spec-driven Development로 AI 코드 생성의 한계 극복

2. **컨텍스트 관리의 중요성**
   - Context Engineering > Prompt Engineering
   - Memory Bank, Learnings.md, 자동 요약으로 세션 간 컨텍스트 유지

3. **인간-AI 역할 분담**
   - Specification(명세)과 Verification(검증)은 인간의 책임
   - Essential Complexity(핵심 도메인)는 Augmented Coding으로

4. **팀 역량 보존 전략**
   - Trio Programming (시니어 + 주니어 + AI)
   - No-AI Challenge로 비판적 사고력 유지
   - Socratic Code Review로 이해도 검증

5. **AI 역설 대응**
   - 70% 문제: 마지막 30%가 더 오래 걸릴 수 있음
   - PR 크기 증가로 인한 리뷰 시간 증가 고려
   - 테스트, CI/CD, 문서화가 AI 효과의 전제조건

---

**누적 기법 수**: 1,058 + 85 = **1,143개**
