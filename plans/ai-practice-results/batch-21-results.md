# Batch 21 결과 (201-210)

**처리일**: 2026-01-04
**처리 문서**: 10개
**추출 기법**: 61개
**해당 없음**: 2개 문서

---

## 문서별 결과 요약

| 번호 | 문서명 | 기법 수 | 비고 |
|------|--------|---------|------|
| 201 | RAG 개념부터 구현까지 - Knowledge Bases for Amazon Bedrock | 6 | RAG 기반 시스템 설계 |
| 202 | RAG in Java and Spring AI | 6 | Spring AI RAG 구현 |
| 203 | RAG using spring-boot | 0 | 북마크 문서 (링크만 포함) |
| 204 | Replit AI 데이터베이스 삭제 사건 | 8 | AI 안전/위험 관리 |
| 205 | Serena-MCP | 6 | AST 기반 코드 분석 |
| 206 | Shifting-Left-AI-Defect-Detection-Agile | 10 | AI 기반 QA |
| 207 | Should-We-Revisit-XP-in-the-Age-of-AI | 5 | XP + AI 워크플로우 |
| 208 | Software Architect Assistant — How Gen AI can help in DDD | 11 | DDD + AI 설계 |
| 209 | Solving the Hard Problems | 0 | 일반 SW 엔지니어링 (AI 관련 없음) |
| 210 | Some thoughts on LLMs and Software Development | 9 | LLM 활용 원칙 |

---

## 추출된 기법 상세

### 201. RAG 개념부터 구현까지 - Knowledge Bases for Amazon Bedrock (6개)

#### 1. RAG 패턴
- **카테고리**: 워크플로우
- **설명**: 사용자 질문과 관련된 정보를 지식 데이터베이스에서 검색하여 프롬프트에 추가함으로써 생성형 AI의 환각 현상, 최신 정보 부재, 도메인 지식 부족 문제를 해결하는 기법
- **적용 상황**: 기업 내부 문서 기반 Q&A 시스템, 최신 정보가 필요한 AI 응답, 도메인 지식이 필요한 경우

#### 2. 컨텍스트 주입 프롬프트
- **카테고리**: 프롬프트엔지니어링
- **설명**: 생성형 AI의 한계를 극복하기 위해 관련 정보를 프롬프트에 직접 추가하는 기법
- **적용 상황**: 특정 질문에 대해 정확한 답변이 필요할 때, 배경 정보나 참조 자료 제공 시

#### 3. 문서 청킹 전략
- **카테고리**: 워크플로우
- **설명**: RAG 시스템에서 문서를 임베딩 모델이 처리할 수 있는 적절한 크기로 분할하는 기법. 단순 문장 분할, 고정 크기 청킹, 오버래핑 청킹 등
- **적용 상황**: RAG 시스템 구축, 대용량 문서 벡터 DB 저장, 검색 정확도 최적화

#### 4. 하이브리드 검색
- **카테고리**: 워크플로우
- **설명**: 벡터 검색(의미 기반)과 키워드 검색(정확한 매칭)을 결합하여 검색 정확도를 높이는 기법
- **적용 상황**: RAG 시스템 검색 정확도 향상, 의미적 검색만으로 부족한 경우

#### 5. 벡터 임베딩 기반 의미 검색
- **카테고리**: 도구활용
- **설명**: 단어나 문장을 벡터로 변환하여 의미적 관계를 수학적으로 계산하는 기법. 코사인 유사도, 유클리디안 거리, 내적 사용
- **적용 상황**: 키워드가 정확히 일치하지 않아도 관련 문서를 찾고 싶을 때, 다국어 검색

#### 6. 도메인 특화 지식베이스 구축
- **카테고리**: 워크플로우
- **설명**: DDD, TDD 같은 개발 방법론이나 기업 내부 지식을 RAG 시스템에 통합하여 도메인 특화 응답 생성
- **적용 상황**: 기업별 내부 지식 기반 AI 시스템, 개발 문서화 자동화

---

### 202. RAG in Java and Spring AI (6개)

#### 1. RAG - 검색 증강 생성
- **카테고리**: 워크플로우
- **설명**: 대규모 문서 전체를 LLM에 보내는 대신, 사용자 질문과 관련된 문서 부분만 벡터 유사성 검색으로 추출하여 컨텍스트로 제공
- **적용 상황**: 대용량 문서(예: 1000페이지 PDF) 기반 Q&A 시스템, LLM이 학습하지 않은 도메인 지식 활용

#### 2. 벡터 유사성 검색
- **카테고리**: 도구활용
- **설명**: 텍스트를 벡터(임베딩)로 변환하여 저장하고, 쿼리와 유사도가 높은 문서를 검색
- **적용 상황**: FAQ 시스템, 문서 검색 시스템, 지식 베이스 구축

#### 3. TokenTextSplitter를 활용한 문서 분할
- **카테고리**: 워크플로우
- **설명**: 대용량 텍스트를 토큰 기반으로 적절한 크기로 분할하여 임베딩 생성 및 검색 효율성 향상
- **적용 상황**: 긴 문서를 벡터 데이터베이스에 저장할 때, LLM 컨텍스트 윈도우 제한 고려 시

#### 4. 컨텍스트 주입 프롬프트 템플릿
- **카테고리**: 프롬프트엔지니어링
- **설명**: 검색된 문서와 사용자 질문을 조합하는 템플릿 기반 프롬프트 구성. "확신이 없으면 모른다고 말하라"는 지시로 환각 방지
- **적용 상황**: RAG 시스템에서 LLM 호출, 정확한 답변이 중요한 도메인

#### 5. 임베딩 캐싱 및 재사용
- **카테고리**: 도구활용
- **설명**: 한 번 생성된 벡터 스토어를 파일로 저장하고, 애플리케이션 재시작 시 로드하여 재사용
- **적용 상황**: 문서가 자주 변경되지 않는 경우, 임베딩 생성 비용 최적화

#### 6. 자체 데이터 통합 (BYOD)
- **카테고리**: 워크플로우
- **설명**: LLM이 학습하지 않은 사용자의 비공개 문서, 제품 정보, 최신 정보 등을 컨텍스트로 제공
- **적용 상황**: 기업 내부 문서 기반 챗봇, 제품 FAQ 시스템

---

### 203. RAG using spring-boot

**해당 없음** - 외부 Medium 아티클 링크만 포함된 북마크 문서

---

### 204. Replit AI 데이터베이스 삭제 사건 (8개)

#### 1. Planning-Only Mode (계획 전용 모드)
- **카테고리**: 워크플로우
- **설명**: AI가 라이브 코드베이스에 실제 변경을 가하지 않고, 샌드박스 환경에서 계획만 수립하도록 설정. 사용자가 계획을 검토하고 명시적으로 승인한 후에만 실제 변경 적용
- **적용 상황**: 프로덕션 환경과 연결된 AI 코딩 도구 사용, 데이터베이스 조작이나 중요 시스템 변경 작업 전

#### 2. Human-in-the-Loop (사람 개입 필수)
- **카테고리**: 워크플로우
- **설명**: 치명적인 작업(데이터 삭제, 프로덕션 배포 등)에 대해 AI가 자율적으로 실행하지 않고 반드시 사람의 명시적 승인 필요
- **적용 상황**: 되돌릴 수 없는 작업, 프로덕션 데이터베이스 조작, 시스템 설정 변경

#### 3. Least Privilege for AI Agents (AI 최소 권한 원칙)
- **카테고리**: 도구활용
- **설명**: AI 에이전트에게 작업에 필요한 최소한의 권한만 부여. 기본적으로 읽기 전용 접근, 쓰기 권한은 명시적 승인 후에만 부여
- **적용 상황**: AI 코딩 어시스턴트 초기 설정, 환경별 권한 설계

#### 4. Environment Separation (환경 분리)
- **카테고리**: 워크플로우
- **설명**: Dev/Staging/Prod 환경을 물리적/논리적으로 완전히 분리하고, AI 에이전트는 개발 환경에서만 자유롭게 작업하도록 제한
- **적용 상황**: AI 코딩 도구 도입 시 인프라 설계

#### 5. AI Action Logging & Monitoring
- **카테고리**: 코드품질
- **설명**: AI가 실행하는 모든 명령을 로깅하고, 이상 행동 패턴을 탐지하는 모니터링 시스템 구축
- **적용 상황**: AI 에이전트가 지속적으로 코드 변경을 수행하는 환경, 자동화된 작업 파이프라인

#### 6. AI Hallucination Verification
- **카테고리**: 코드품질
- **설명**: AI가 제공하는 정보를 무조건 신뢰하지 않고, 중요한 결정이나 복구 작업 시 AI의 응답을 독립적으로 검증
- **적용 상황**: AI가 시스템 상태나 복구 가능성에 대해 답변할 때, 위기 상황에서 AI의 조언을 받을 때

#### 7. Code Freeze AI Lockout
- **카테고리**: 워크플로우
- **설명**: 시스템이 "code and action freeze" 상태일 때 AI 에이전트의 작업 권한을 완전히 차단하는 메커니즘
- **적용 상황**: 배포 전 안정화 기간, 중요 시스템 점검 중, 장애 대응 시

#### 8. Pre-defined Rollback Plan
- **카테고리**: 워크플로우
- **설명**: AI 도구 사용 전에 자동 백업 및 복구 시스템을 구축하고, 롤백 절차를 문서화하여 정기적으로 테스트
- **적용 상황**: AI 코딩 도구 도입 초기, 데이터베이스나 중요 시스템에 AI가 접근하는 모든 상황

---

### 205. Serena-MCP (6개)

#### 1. Symbol-based Code Navigation
- **카테고리**: 도구활용
- **설명**: `find_symbol`을 사용하여 클래스 전체 구조를 파악하고, `name_path`로 특정 클래스/메서드에 직접 접근. 필요한 심볼만 선택적으로 탐색
- **적용 상황**: 대규모 코드베이스에서 특정 클래스나 메서드를 빠르게 찾아야 할 때, 토큰 사용량 최소화

#### 2. Hierarchical Symbol Overview
- **카테고리**: 도구활용
- **설명**: `get_symbols_overview`로 파일의 최상위 심볼들(클래스, 메서드, 패키지 등)을 확인. 파일 전체를 읽지 않고도 코드의 구조적 개요 파악
- **적용 상황**: 처음 접하는 코드베이스의 구조 이해, 어떤 클래스/메서드가 있는지 먼저 파악하고 싶을 때

#### 3. AST Pattern Search
- **카테고리**: 도구활용
- **설명**: `search_for_pattern`으로 특정 코드 패턴을 검색하여 정확한 위치 파악. 컨텍스트 라인 포함
- **적용 상황**: 특정 코드 패턴이 어디에서 사용되는지 찾아야 할 때, 변수나 메서드 호출의 정확한 위치 특정

#### 4. Selective Body Inclusion
- **카테고리**: 워크플로우
- **설명**: `include_body=true` 옵션으로 필요한 메서드 본문만 선택적으로 가져옴. 전체 파일을 읽지 않아 토큰 절약
- **적용 상황**: 대용량 파일에서 특정 메서드만 분석해야 할 때, AI 토큰 비용 절약

#### 5. AST-based Relationship Mapping
- **카테고리**: 워크플로우
- **설명**: AST 기반으로 코드의 의미론적 구조를 이해하여 클래스 간 연결 관계 파악
- **적용 상황**: 복잡한 코드베이스에서 클래스/모듈 간의 의존 관계 파악, 수정의 영향 범위 분석

#### 6. Plan Mode for Code Analysis
- **카테고리**: 워크플로우
- **설명**: Claude Code의 plan mode에서 코드 수정 요청 시 AI가 문제를 분석하고 구체적인 수정 방안(파일 위치, 메서드명, 라인 번호, 수정 코드) 제시
- **적용 상황**: 코드 수정 전에 영향 범위와 수정 방안 검토, 복잡한 수정 작업의 계획 수립

---

### 206. Shifting-Left-AI-Defect-Detection-Agile (10개)

#### 1. 예측 분석 (Predictive Analytics)
- **카테고리**: 코드품질
- **설명**: AI가 버그 리포트와 코드 수정의 과거 데이터를 분석하여 발생할 수 있는 결함을 예측
- **적용 상황**: 레거시 코드베이스 분석, 고위험 코드 영역 식별, 릴리스 전 품질 예측

#### 2. AI 기반 자동화 테스트 케이스 생성
- **카테고리**: 도구활용
- **설명**: AI가 기존 코드 분석과 요구사항 평가를 결합하여 전체 테스트 케이스 스위트를 자동 생성
- **적용 상황**: 테스트 커버리지 빠른 확보, 새로운 기능 개발 시 단위 테스트 생성, 레거시 코드에 테스트 추가

#### 3. 테스트 갭 분석 (Test Gap Analysis)
- **카테고리**: 코드품질
- **설명**: AI를 활용하여 테스트 스위트 내에서 보이지 않는 커버리지 구멍 발견
- **적용 상황**: 테스트 커버리지 감사, 릴리스 전 품질 점검, 리팩토링 후 테스트 완전성 검증

#### 4. 이상 탐지 기반 결함 식별 (Anomaly Detection)
- **카테고리**: 코드품질
- **설명**: 머신러닝 알고리즘이 시스템 기능의 이상 패턴을 탐지하여 숨겨진 결함의 지표로 활용
- **적용 상황**: 런타임 버그 탐지, 성능 저하 조기 발견, 복잡한 시스템의 예상치 못한 동작 감지

#### 5. AI 기반 리스크 기반 테스팅 (Risk-Based Testing)
- **카테고리**: 워크플로우
- **설명**: AI가 결함이 발생하기 쉽고 가장 큰 영향을 미치는 고우선순위 영역을 식별하여 테스팅 리소스 집중
- **적용 상황**: 촉박한 릴리스 일정, 제한된 테스팅 리소스, 핵심 비즈니스 기능 우선순위 결정

#### 6. 자가 치유 테스트 (Self-Healing Tests)
- **카테고리**: 도구활용
- **설명**: 애플리케이션 변경 시 AI가 테스트를 자동으로 조정하여 유지보수 부담 감소
- **적용 상황**: 빈번한 UI 변경이 있는 프로젝트, E2E 테스트 유지보수 비용 절감, 지속적 배포 환경

#### 7. NLP 기반 요구사항 분석 (Requirements Analysis with NLP)
- **카테고리**: 워크플로우
- **설명**: NLP가 사용자 스토리와 수락 기준을 검토하여 모호성을 식별하고, 초기 단계에서 예비 테스팅 프레임워크 제안
- **적용 상황**: 스프린트 플래닝 시 사용자 스토리 검토, 요구사항 명세서 품질 검증, 수락 기준 완전성 확인

#### 8. CI/CD 파이프라인 AI 통합 (AI-Enhanced CI/CD)
- **카테고리**: 워크플로우
- **설명**: AI가 운영하는 테스트를 CI/CD 파이프라인에 통합하여 코드 제출 후 자동 실행
- **적용 상황**: DevOps 환경에서 지속적 통합, 자동화된 코드 리뷰, 배포 전 품질 게이트 구현

#### 9. AI 테스트 우선순위 최적화 (Test Prioritization)
- **카테고리**: 워크플로우
- **설명**: AI 테스트 관리 시스템이 리스크 평가에 따라 자동으로 테스트 케이스 우선순위 선택
- **적용 상황**: 대규모 테스트 스위트 관리, 회귀 테스트 최적화, 빠른 피드백 사이클

#### 10. AI 기반 코드 분석 (AI-Powered Code Analysis)
- **카테고리**: 코드품질
- **설명**: 정적 코드 분석 기법을 AI와 결합하여 워크플로우 내에서 직접 코드 테스트
- **적용 상황**: 코드 리뷰 자동화, 코딩 표준 준수 검증, 보안 취약점 조기 발견

---

### 207. Should-We-Revisit-XP-in-the-Age-of-AI (5개)

#### 1. Vibe Coding 리스크 관리
- **카테고리**: 코드품질
- **설명**: LLM의 컨텍스트 윈도우가 길어질수록 정확도가 떨어진다는 한계 인식. LLM은 컨텍스트 윈도우의 시작과 끝에서 가장 잘 수행되며, 중간 부분은 오류 발생 가능
- **적용 상황**: AI 코드 생성 도구를 장기간 사용하거나 큰 컨텍스트로 작업할 때

#### 2. AI + XP 하이브리드 워크플로우
- **카테고리**: 워크플로우
- **설명**: AI가 코드 생성을 자동화할수록, 페어 프로그래밍, 지속적인 피드백, 작은 배치 배포 등 XP의 실천법을 결합하여 검증되지 않은 로직의 축적 방지
- **적용 상황**: AI 코딩 도구를 팀에서 도입할 때, 코드 품질과 아키텍처 복잡성 관리

#### 3. 에이전틱 AI 제약 조건 설정
- **카테고리**: 워크플로우
- **설명**: 여러 자율 에이전트가 코드를 생성, 정제, 출시하는 시스템에서는 명시적인 제약이 없으면 검증되지 않은 로직이 빠르게 쌓임. 의도적인 마찰과 제약 도입 필요
- **적용 상황**: 자율 AI 에이전트를 개발 파이프라인에 도입할 때, 코드 리뷰 및 검증 게이트 설계

#### 4. AI 아웃풋 피드백 루프 구축
- **카테고리**: 코드품질
- **설명**: AI가 아웃풋을 가속화할수록 품질, 위험, 의도를 관리하기 위한 강한 피드백 루프 필요. 작은 배치, 지속적 통합, 자동화된 테스팅, 공유된 소유권 활용
- **적용 상황**: AI 코드 생성 도구를 CI/CD 파이프라인에 통합할 때, TDD와 결합하여 AI 코드 품질 관리

#### 5. 검증 우선 AI 활용
- **카테고리**: 코드품질
- **설명**: "검증할 수 있는 것보다 빠르게 소프트웨어를 생산하는 것"이 새로운 위험. AI 코드 생성 속도를 검증 속도에 맞춰 조절
- **적용 상황**: AI 도구로 빠르게 프로토타이핑할 때, 생성된 코드의 품질과 정확성 확보

---

### 208. Software Architect Assistant — How Gen AI can help in DDD (11개)

#### 1. RAG 기반 지식베이스 구축
- **카테고리**: 워크플로우
- **설명**: 프로젝트 관련 문서(에픽, 사용자 스토리, 비기능적 요구사항 등)를 RAG 시스템에 업로드하여 LLM과 통합
- **적용 상황**: 새 프로젝트 온보딩, 복잡한 도메인 이해

#### 2. AI 기반 도메인 용어집 자동 생성
- **카테고리**: 프롬프트엔지니어링
- **설명**: DDD 전문가 역할을 부여하고 문서 분석을 통해 도메인 특화 용어 100개의 용어집을 CSV 형식으로 생성
- **적용 상황**: 새 도메인 온보딩, 팀 간 공통 언어 수립

#### 3. AI 기반 요구사항 검증
- **카테고리**: 코드품질
- **설명**: AI에게 사양 문서 분석을 요청하여 모호성과 격차를 식별하고 실행 가능한 권장사항 제공
- **적용 상황**: 새 프로젝트 시작 전, 요구사항 검토 단계

#### 4. AI 기반 도메인 분해
- **카테고리**: 워크플로우
- **설명**: 사양 문서를 분석하여 핵심 도메인과 하위 도메인을 식별하고, 각각의 목적, 책임, 관계 정의
- **적용 상황**: 마이크로서비스 분해, 시스템 모듈화 설계

#### 5. AI 기반 Bounded Context 설계
- **카테고리**: 워크플로우
- **설명**: 특정 도메인에 대해 경계 컨텍스트를 정의하고, 의존성을 3가지로 분류(의존성 없음/업스트림-다운스트림/상호 의존적)
- **적용 상황**: 마이크로서비스 경계 결정, 서비스 분리 전략 수립

#### 6. AI 기반 Context Map 시각화
- **카테고리**: 도구활용
- **설명**: 경계 컨텍스트 간의 관계 유형, 통합 메커니즘, 의존성을 분석하여 PlantUML 다이어그램으로 시각화
- **적용 상황**: 아키텍처 문서화, 팀 간 의존성 파악

#### 7. AI 기반 전술적 DDD 모델링
- **카테고리**: 워크플로우
- **설명**: 특정 경계 컨텍스트에 대해 애그리게이트, 엔티티, 값 객체, 리포지토리를 식별하고 정의
- **적용 상황**: 도메인 모델 설계, 코드 구조 결정

#### 8. AI 기반 Event Storming
- **카테고리**: 워크플로우
- **설명**: 경계 컨텍스트 내의 도메인 특화 이벤트를 식별. 각 이벤트에 대해 이름, 설명, 도메인 컨텍스트 정의
- **적용 상황**: 이벤트 주도 아키텍처 설계, 비즈니스 프로세스 분석

#### 9. DDD 전문가 페르소나 활용
- **카테고리**: 프롬프트엔지니어링
- **설명**: 모든 프롬프트에서 "Eric Evans의 도메인 주도 설계(DDD) 전문성을 갖춘 소프트웨어 아키텍트로서"라는 역할 부여
- **적용 상황**: 전문적인 분석이나 설계 결과물이 필요할 때

#### 10. 출력 형식 명시적 지정
- **카테고리**: 프롬프트엔지니어링
- **설명**: 프롬프트에서 CSV, PlantUML, 분류 체계 등 원하는 출력 형식을 명시적으로 지정
- **적용 상황**: 문서화 자동화, 다이어그램 생성

#### 11. AI 초안 + 전문가 검토 협업
- **카테고리**: 협업
- **설명**: AI가 생성한 초안(용어집, 도메인 모델, 컨텍스트 맵 등)을 전문가가 검토, 도전, 정제하는 협업 워크플로우
- **적용 상황**: 복잡한 설계 작업, 시간이 제한된 상황

---

### 209. Solving the Hard Problems

**해당 없음** - 일반적인 소프트웨어 엔지니어링 원칙(점진적 설계, 반복, 테스트 가능성 등)을 다루며 AI 활용과 직접 관련 없음

---

### 210. Some thoughts on LLMs and Software Development (9개)

#### 1. 반복 질문 비교 기법 (Multiple Query Comparison)
- **카테고리**: 프롬프트엔지니어링
- **설명**: 같은 질문을 여러 번, 표현을 다르게 바꿔가며 물어보고 답변들을 비교. LLM의 비결정론적 특성 활용
- **적용 상황**: 중요한 의사결정, 정확한 정보 필요, LLM 답변의 신뢰성 검증

#### 2. LLM 자기 비교 요청 (Self-Comparison Request)
- **카테고리**: 프롬프트엔지니어링
- **설명**: 여러 번의 질문을 통해 얻은 답변들을 LLM 자체에게 비교 분석하도록 요청
- **적용 상황**: 복잡한 주제에 대한 다양한 관점 종합, 모순되는 답변 정리

#### 3. 숫자 답변 3회 검증 규칙 (Triple Verification for Numbers)
- **카테고리**: 코드품질
- **설명**: 숫자 관련 답변을 요청할 때 최소 3번 이상 물어봐서 변동성 파악. LLM의 환각 특성상 숫자 데이터는 특히 신뢰성이 낮음
- **적용 상황**: 통계 데이터, 성능 수치, 날짜, 버전 정보 등 정확한 숫자 필요 시

#### 4. 계산 위임 분리 원칙 (Calculation Delegation Principle)
- **카테고리**: 워크플로우
- **설명**: 결정론적으로 계산할 수 있는 답변을 LLM에게 직접 계산하도록 요청하지 말고, 계산하는 코드를 생성하도록 요청
- **적용 상황**: 수학 계산, 날짜 계산, 통계 분석 등 정확한 계산 필요 시

#### 5. 코드 직접 편집 워크플로우 (Direct Code Editing Workflow)
- **카테고리**: 워크플로우
- **설명**: 단순한 자동 완성을 넘어서, LLM이 소스 코드 파일을 직접 읽고 편집할 수 있는 접근 방식 활용
- **적용 상황**: 복잡한 리팩토링, 여러 파일에 걸친 변경, 코드베이스 이해가 필요한 작업

#### 6. LLM 출력 필수 검증 규칙 (Mandatory Output Verification)
- **카테고리**: 코드품질
- **설명**: LLM이 "모든 테스트가 통과했다"고 보고해도 반드시 직접 실행하여 검증
- **적용 상황**: 테스트 실행 결과, 코드 동작 확인, 배포 전 검증 등

#### 7. 실험 및 워크플로우 관찰 학습법 (Experimental Learning Approach)
- **카테고리**: 워크플로우
- **설명**: LLM 활용 능력을 높이기 위해 다른 사람들의 워크플로우 세부사항을 관찰하고, 직접 실험하며, 경험 공유
- **적용 상황**: AI 도구 도입 초기, 새로운 LLM 기능 탐색, 팀 내 AI 활용 역량 강화

#### 8. AI 에이전트 보안 삼위일체 체크 (Lethal Trifecta Security Check)
- **카테고리**: 코드품질
- **설명**: AI 에이전트 설계 시 "치명적인 삼위일체" 조건(개인 데이터 접근 + 신뢰할 수 없는 콘텐츠 노출 + 외부 통신 방법)이 동시에 충족되지 않도록 격리
- **적용 상황**: AI 에이전트 아키텍처 설계, 보안 검토, AI 기반 자동화 시스템 구축

#### 9. 비결정론 허용 오차 설계 (Non-deterministic Tolerance Design)
- **카테고리**: 워크플로우
- **설명**: LLM 기반 시스템에서도 비결정론적 출력에 대한 허용 오차를 설계에 반영. LLM의 출력 변동성을 예상하고 관리하는 메커니즘 구축
- **적용 상황**: LLM을 포함한 파이프라인 설계, AI 기반 자동화 워크플로우 구축

---

## 카테고리별 통계

| 카테고리 | 기법 수 |
|----------|---------|
| 워크플로우 | 27 |
| 코드품질 | 15 |
| 도구활용 | 10 |
| 프롬프트엔지니어링 | 8 |
| 협업 | 1 |
| **총계** | **61** |

---

## 핵심 테마

1. **RAG 기반 시스템 설계**: 벡터 검색, 문서 청킹, 하이브리드 검색, 캐싱 전략
2. **AI 안전/위험 관리**: Human-in-the-Loop, 최소 권한 원칙, 환경 분리, 롤백 계획
3. **AST 기반 코드 분석**: Serena MCP를 활용한 심볼 탐색, 패턴 검색, 선택적 코드 읽기
4. **AI 기반 QA**: 예측 분석, 테스트 자동 생성, 리스크 기반 테스팅, 자가 치유 테스트
5. **DDD + AI 통합**: 용어집 자동 생성, 도메인 분해, Bounded Context 설계, Event Storming
6. **LLM 활용 원칙**: 반복 질문 비교, 숫자 검증, 계산 위임, 출력 검증
7. **XP + AI 하이브리드**: Vibe Coding 한계 인식, 피드백 루프 강화, 검증 속도 맞추기
