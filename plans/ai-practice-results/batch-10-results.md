# Batch 10 Results - AI 활용 기법 추출 (91-100)

**처리일**: 2026-01-03
**배치 번호**: Batch 10
**문서 수**: 10개
**추출된 기법 수**: 76개

---

## 처리된 문서 목록

| 번호 | 문서명 | 추출 기법 수 |
|------|--------|-------------|
| 91 | Coding With Goose, An AI Agent.md | 10 |
| 92 | Conversation-LLMs and Building Abstractions.md | 7 |
| 93 | Cursor for development.md | 6 |
| 94 | Cursor-Obisidian.md | 10 |
| 95 | Deep Learning 강좌 - 김성훈.md | 0 (해당 없음) |
| 96 | Development with AI.md | 10 |
| 97 | DHH의 AI와 매몰 비용 오류 트윗.md | 10 |
| 98 | does-ai-write-better-code-than-humans.md | 6 |
| 99 | Embabel Agent Framework.md | 8 |
| 100 | Embabel-JVM을 위한 새로운 에이전트 플랫폼.md | 9 |

---

## 문서별 상세 결과

---

### 91. Coding With Goose, An AI Agent

#### 1. 탐색적 프로젝트 분석 (Exploratory Project Analysis)
- **카테고리**: AI 에이전트 활용법
- **상세 설명**: Goose는 탐색적 방식으로 작동하여 프로젝트 구조와 기능을 스스로 파악합니다. REST API 분석, 엔티티 구조 파악, 환경 설정 방법 탐지 등을 자동으로 수행하여 새로운 코드베이스에 빠르게 적응할 수 있습니다.
- **적용 예시**: `goose session` 실행 후 "이 프로젝트의 REST API 구조를 설명해줘"라고 요청하면, AI가 자동으로 코드를 분석하여 엔드포인트, 요청 형식, 상태 코드 등을 설명

#### 2. 구체적 프롬프트 작성 (Specific Prompt Engineering)
- **카테고리**: 프롬프트 엔지니어링 기법
- **상세 설명**: 프롬프트가 구체적일수록 결과가 더 좋습니다. 특정 클래스나 패턴을 명시적으로 언급하거나 프로젝트의 명명 규칙에 대한 지식을 공유하면 더 정확한 결과를 얻을 수 있습니다.
- **적용 예시**:
  - 일반적: "테스트를 만들어줘" (모호함)
  - 구체적: "StringExtensions 클래스에 대한 JUnit 5와 AssertJ를 사용하는 유닛 테스트를 생성해줘" (명확함)

#### 3. 점진적 대화형 개발 (Iterative Conversational Development)
- **카테고리**: AI 워크플로우/개발 방법론
- **상세 설명**: 테스트 생성 후 결과를 확인하고, 원하는 동작과 다른 부분을 발견하면 추가 요청을 통해 코드를 수정합니다.
- **적용 예시**: 테스트 생성 → 실행 → 동작 수정 요청 → 프로덕션+테스트 코드 수정

#### 4. 엣지 케이스 자동 식별 (Automatic Edge Case Identification)
- **카테고리**: 코드 품질/검증 방법
- **상세 설명**: AI 에이전트는 테스트 케이스 생성 시 다양한 긍정적, 부정적 사례와 엣지 케이스를 자동으로 식별합니다.
- **적용 예시**: 문자열 대문자화 테스트 시 일반/대문자/소문자/혼합/단일/빈/null 케이스 자동 생성

#### 5. 도구 확장 활성화 (Extension Activation)
- **카테고리**: 도구/플러그인 활용
- **상세 설명**: Goose는 Computer Controller와 Developer 확장 기능을 통해 실제 시스템 명령을 실행하고 개발 도구와 통합할 수 있습니다.
- **적용 예시**: `goose configure`로 확장 선택 후 `goose session` 시작

#### 6. 자동 다이어그램 생성 (Automatic Diagram Generation)
- **카테고리**: 생산성/자동화 기법
- **상세 설명**: AI가 `@Entity` 어노테이션 등 코드 패턴을 검색하여 엔티티와 관계를 파악하고, ER 다이어그램이나 아키텍처 다이어그램을 자동 생성합니다.
- **적용 예시**: "please create an ER diagram showing the database entities and their relationships"

#### 7. 스크립트 자동 생성 (Script Auto-Generation)
- **카테고리**: 생산성/자동화 기법
- **상세 설명**: AI에게 원하는 기능을 설명하면 컬러 출력, 체크마크 등을 포함한 정교한 쉘 스크립트를 자동 생성합니다.
- **적용 예시**: "모든 컨테이너가 건강하게 실행 중인지 확인하는 쉘 스크립트를 작성해줘"

#### 8. 테스트 데이터 자동 생성 (Test Data Generation)
- **카테고리**: 생산성/자동화 기법
- **상세 설명**: CSV 파일, JSON 데이터 등 다양한 형식의 테스트 데이터를 자연어 요청으로 생성할 수 있습니다.
- **적용 예시**: "please write a CSV file of English names in the format full name, first name, last name, date of birth"

#### 9. 보안 인식 사용 (Security-Aware Usage)
- **카테고리**: 코드 품질/검증 방법
- **상세 설명**: AI 에이전트가 실제 시스템 명령을 실행할 수 있으므로, 무엇이 실행되는지 항상 주의해야 합니다.
- **적용 예시**: Goose가 스크립트 실행을 제안할 때 내용을 먼저 확인 후 실행 결정

#### 10. LLM 백엔드 최적 선택 (LLM Backend Selection)
- **카테고리**: AI 에이전트 활용법
- **상세 설명**: 다양한 LLM 제공업체를 시도해 보고, 현재 작업에 가장 적합한 모델을 선택합니다.
- **적용 예시**: `goose configure` 명령으로 Anthropic Claude를 백엔드로 설정

---

### 92. Conversation-LLMs and Building Abstractions

#### 1. 우발적 복잡성 vs 본질적 복잡성 구분 활용
- **카테고리**: AI 워크플로우/개발 방법론
- **상세 설명**: Fred Brooks의 개념을 적용하여 LLM이 효과적으로 도울 수 있는 영역(우발적 복잡성: 보일러플레이트, 프레임워크 통합, 구문 작성)과 개발자가 주도해야 하는 영역(본질적 복잡성: 명세, 설계, 테스팅)을 구분합니다.
- **적용 예시**: CI/CD 파이프라인 설정은 LLM에 위임, 도메인 모델 설계는 개발자가 직접 수행

#### 2. 페어 프로그래밍 마인드셋 적용
- **카테고리**: AI 워크플로우/개발 방법론
- **상세 설명**: Pull Request 스타일보다 페어 프로그래밍 스타일(높은 빈도의 상호작용, 유동적 역할 교체)로 LLM과 작업할 때 더 효과적입니다.
- **적용 예시**: 작은 단위로 나누어 LLM과 대화하며 점진적으로 구현 방향을 조정

#### 3. 추상화 발견 시 LLM 브레인스토밍 파트너 활용
- **카테고리**: AI 에이전트 활용법
- **상세 설명**: 추상화 발견과 안정화 과정은 창의적 활동으로, LLM에 통제권을 넘기지 않고 개발자가 주도권을 유지하면서 브레인스토밍 파트너로 활용합니다.
- **적용 예시**: "이 도메인에서 어떤 추상화가 적절할지 몇 가지 옵션을 제안해줘" 요청 후 개발자가 최종 결정

#### 4. 안정된 추상화의 기계적 작업 위임
- **카테고리**: 생산성/자동화 기법
- **상세 설명**: 추상화가 안정된 후에는 새로운 사용 사례나 변형 구현과 같은 반복적이고 기계적인 코딩 작업을 LLM에 위임합니다.
- **적용 예시**: Repository 패턴이 확립된 후, 새로운 엔티티에 대한 Repository 구현은 LLM에 맡기고 개발자는 리뷰만 수행

#### 5. 도메인 어휘 명시 (Ubiquitous Language)
- **카테고리**: 프롬프트 엔지니어링 기법
- **상세 설명**: LLM과 작업할 때 팀의 공유 도메인 어휘를 명시적으로 제공하지 않으면, 모델이 의미를 추측해야 하므로 비효율적입니다.
- **적용 예시**: 프롬프트에 "우리 시스템에서 'Order'는 주문 생성부터 배송 완료까지의 전체 생명주기를 나타내며..."와 같이 도메인 용어 정의 포함

#### 6. 피드백 루프 기반 점진적 개발
- **카테고리**: AI 워크플로우/개발 방법론
- **상세 설명**: 컴파일러와의 상호작용처럼 LLM도 피드백 메커니즘으로 활용합니다. 첫 번째 명세는 가설로 취급하고 반복적 개선을 통해 발전시킵니다.
- **적용 예시**: 초기 구현을 LLM과 함께 빠르게 만들고, 실행 결과와 피드백을 바탕으로 설계를 점진적으로 개선

#### 7. 작업 어휘 구축 협업 (Growing a Language)
- **카테고리**: 프롬프트 엔지니어링 기법
- **상세 설명**: Guy Steele의 개념에 따라, 도메인에서 확립된 개념을 차용하고 잘 알려진 패턴을 활용하여 공유 언어 체계를 형성합니다.
- **적용 예시**: "Repository 패턴을 사용해서...", "Factory 메서드로 생성하고..." 등 표준화된 패턴 용어를 프롬프트에 활용

---

### 93. Cursor for development

#### 1. 계획 우선 개발 (Planning First Development)
- **카테고리**: AI 워크플로우/개발 방법론
- **상세 설명**: AI 코딩을 시작하기 전에 Figma, v0.ai 등을 활용해 시각적 프로토타입을 먼저 제작합니다. 최소 10-15개의 프롬프트를 사용하여 원하는 디자인에 근접하게 만든 후 코딩에 착수합니다.
- **적용 예시**: v0.ai에서 UI 프로토타입 10-15회 반복 개선 후 Cursor로 구현

#### 2. Cursor Rules 프롬프트 템플릿 활용
- **카테고리**: 프롬프트 엔지니어링 기법
- **상세 설명**: cursor.directory 사이트에서 사용 중인 기술 스택에 맞는 프롬프트 템플릿을 가져와 프로젝트 루트의 `cursor.rules` 파일에 적용합니다.
- **적용 예시**: cursor.directory에서 "React + TypeScript" 템플릿 선택 → 프로젝트 루트에 .cursor.rules 파일 생성

#### 3. 문서 태깅 (Documentation Tagging)
- **카테고리**: 도구/플러그인 활용
- **상세 설명**: 사용 중인 기술의 공식 문서 URL을 Cursor의 문서 추가 기능을 통해 프로젝트에 연결합니다.
- **적용 예시**: Next.js 공식 문서 URL을 Cursor에 태깅, Supabase 문서를 프로젝트 컨텍스트로 추가

#### 4. 멀티 AI 모델 앙상블
- **카테고리**: AI 에이전트 활용법
- **상세 설명**: Cursor에서 해결되지 않는 문제가 발생하면 같은 문제를 Claude, GPT 등 다른 AI 모델에 전달합니다.
- **적용 예시**: Cursor에서 에러 발생 → 시도한 해결책 기록 → Claude에 동일 문제 + 시도 내역 전달 → 새로운 해결책 도출

#### 5. AI 기반 코드 설명/문서화
- **카테고리**: 생산성/자동화 기법
- **상세 설명**: 기존 코드에 대한 설명을 AI에게 요청하여 학습하고, 문서화를 자동화합니다.
- **적용 예시**: "이 코드를 초보자도 이해할 수 있게 단계별로 설명해줘"

#### 6. 스타터 템플릿 활용
- **카테고리**: 생산성/자동화 기법
- **상세 설명**: 인증, 데이터베이스, 결제 시스템 등 공통 기능이 이미 구현된 스타터 템플릿을 활용하여 새 프로젝트를 시작합니다.
- **적용 예시**: SaaS 스타터 키트(인증 + DB + 결제 포함) 기반으로 시작

---

### 94. Cursor-Obsidian

#### 1. RAG 워크플로우 (Obsidian 노트 컨텍스트 활용)
- **카테고리**: AI 워크플로우/개발 방법론
- **상세 설명**: Obsidian vault를 Cursor에서 열고, `@` 멘션을 통해 파일/폴더를 AI 대화에 포함시켜 개인 지식베이스 기반 RAG를 구현합니다.
- **적용 예시**: `@폴더명` 또는 `@파일명.md`로 Obsidian 노트를 멘션하고 "이 내용을 바탕으로 요약해줘"

#### 2. Codebase Indexing 활용
- **카테고리**: 도구/플러그인 활용
- **상세 설명**: Cursor의 `codebase` 기능을 활용하여 전체 vault/프로젝트를 인덱싱하고, 자연어 질문으로 관련 문서를 검색합니다.
- **적용 예시**: "내가 최근 TDD에 대해서 작성한 토론이 뭔지 알려줘" + codebase 버튼 클릭

#### 3. .cursorignore 인덱싱 최적화
- **카테고리**: 생산성/자동화 기법
- **상세 설명**: `.cursorignore` 파일을 생성하여 AI 인덱싱에서 제외할 파일 패턴을 지정합니다.
- **적용 예시**: `*.excalidraw.md`, `*.avif`, `node_modules/` 패턴 추가

#### 4. 다중 문서 통합 글쓰기
- **카테고리**: AI 워크플로우/개발 방법론
- **상세 설명**: 3개 이상의 관련 노트를 AI에게 전달하고 "통합된 내용으로 새로운 글을 작성해줘"라고 요청합니다.
- **적용 예시**: `@파일1.md @파일2.md @파일3.md` 멘션 후 "이 3개의 글을 합쳐서 통합된 내용으로 새로운 글을 작성해줘"

#### 5. 선택적 콘텐츠 개선
- **카테고리**: 코드 품질/검증 방법
- **상세 설명**: 문서의 특정 영역을 선택한 후 AI에게 개선을 요청하고, 제안된 수정사항 중 OK/NO를 선택합니다.
- **적용 예시**: 코드 블록 드래그 선택 → Cmd+K로 개선 요청 → 원하는 변경사항만 Accept

#### 6. Prompt Generator 활용
- **카테고리**: 프롬프트 엔지니어링 기법
- **상세 설명**: OpenAI Playground나 Anthropic Console을 사용하여 System Instructions를 설정하고 프롬프트를 테스트합니다.
- **적용 예시**: "워크샵 주제를 입력하면 해당 워크샵의 기획안을 작성하세요"와 같은 시스템 프롬프트 설계

#### 7. 검색 모드 전환 (R @, RR @)
- **카테고리**: 생산성/자동화 기법
- **상세 설명**: `R @`(짧은 글)와 `RR @`(긴 글) 접두어를 사용하여 검색 결과의 상세 수준을 조절합니다.
- **적용 예시**: 빠른 개요: `R @TDD 핵심 원칙`, 상세 분석: `RR @TDD 테스트 작성 방법론`

#### 8. AI 기반 브레인스토밍
- **카테고리**: AI 워크플로우/개발 방법론
- **상세 설명**: 기존 노트와 아이디어를 AI에게 제공하고 새로운 콘텐츠 제안, 관련 주제 탐색, 문서 구조화 제안을 받습니다.
- **적용 예시**: "이 주제와 관련된 다른 관점은 뭐가 있을까?", "이 3개 문서의 공통점과 차이점을 분석해줘"

#### 9. Maps of Content (MOC) 관리
- **카테고리**: AI 워크플로우/개발 방법론
- **상세 설명**: Obsidian의 폴더 구조(Inbox → Notes → Assets → MOC)와 AI를 결합하여 지식을 체계적으로 조직화합니다.
- **적용 예시**: Inbox에 빠르게 노트 작성 → AI에게 "이 노트가 어떤 MOC에 포함되어야 할지 분석해줘" 요청

#### 10. 대화 중 문서 전환 (동적 컨텍스트 전환)
- **카테고리**: AI 에이전트 활용법
- **상세 설명**: AI와 대화를 진행하다가 특정 문서를 `@`로 멘션하여 참조 문서를 동적으로 변경합니다.
- **적용 예시**: 일반 질문 → 답변 확인 → `@specific-doc.md 이 문서에서 관련 내용을 찾아줘`

---

### 95. Deep Learning 강좌 - 김성훈

**해당 없음**

이 문서는 머신러닝/딥러닝의 기초 이론(Supervised Learning, Linear Regression, Cost Function, Gradient Descent 등)을 다루는 학습 노트로, LLM 활용이나 프롬프트 엔지니어링과 같은 실무적 AI 활용 기법은 포함되어 있지 않습니다.

---

### 96. Development with AI

#### 1. AI 도구 조합 프레임워크 (V0 + Claude + Cursor)
- **카테고리**: AI 워크플로우/개발 방법론
- **상세 설명**: V0는 UI 컴포넌트 생성, Claude AI는 코드 구조화, Cursor AI는 기능 개발 및 디버깅에 특화하여 각 도구의 강점을 조합합니다.
- **적용 예시**: V0로 초기 UI → Claude로 컴포넌트 분리 → Cursor로 기능 추가

#### 2. 이미지 기반 UI 생성
- **카테고리**: 프롬프트 엔지니어링 기법
- **상세 설명**: Webflow 템플릿이나 직접 그린 스케치 이미지를 AI에 첨부하여 동일한 디자인을 생성하도록 요청합니다.
- **적용 예시**: 스케치 첨부 후 "첨부한 이미지대로 똑같이 디자인 해줘"

#### 3. 점진적 UI 개선 프롬프트 시퀀스
- **카테고리**: 프롬프트 엔지니어링 기법
- **상세 설명**: UI를 한 번에 완성하지 않고 초기 UI → 섹션 추가 → 애니메이션 → 디자인 개선 순서로 점진적으로 요청합니다.
- **적용 예시**: landing page 생성 → testimonial section 추가 → CTA 추가 → shadcn ui 스타일 적용

#### 4. 코드 구조화 요청 패턴
- **카테고리**: 프롬프트 엔지니어링 기법
- **상세 설명**: 코드 구조화 시 사용하는 프레임워크(Next.js 14), 라우터 방식(App Router), 언어(TypeScript) 등을 명시적으로 지정합니다.
- **적용 예시**: "please use nextjs 14 standards not the pages router but app router"

#### 5. 스크린샷 기반 디버깅
- **카테고리**: 코드 품질/검증 방법
- **상세 설명**: 버그가 발생한 UI 상태를 스크린샷으로 캡처하여 AI에 첨부하고 수정을 요청합니다.
- **적용 예시**: "look at the header navbar this is how it looks please fix it" (스크린샷 첨부)

#### 6. 외부 리소스 URL 참조
- **카테고리**: 생산성/자동화 기법
- **상세 설명**: Pixabay 등 무료 이미지 사이트의 URL을 직접 참조하여 AI에게 에셋 통합을 요청합니다.
- **적용 예시**: `@https://cdn.pixabay.com/... 이 이미지를 히어로 섹션의 배경이미지로 넣어줘`

#### 7. Cursor Composer 활용
- **카테고리**: 도구/플러그인 활용
- **상세 설명**: Cursor의 Composer 기능(Cmd + I)을 사용하여 프로젝트 전체의 TypeScript 오류를 일괄 수정합니다.
- **적용 예시**: Cmd + I → "Fix all the typescript errors on my page"

#### 8. 파일 구조 자동 생성
- **카테고리**: 생산성/자동화 기법
- **상세 설명**: Claude AI가 제안한 파일 구조를 Cursor AI에게 전달하여 디렉토리와 파일을 자동으로 생성합니다.
- **적용 예시**: "create a file structure as follows and create the files with boilerplate"

#### 9. 프레임워크 특화 요청
- **카테고리**: 프롬프트 엔지니어링 기법
- **상세 설명**: shadcn/ui, Tailwind CSS 등 특정 UI 라이브러리 스타일을 명시하여 일관된 디자인 언어로 컴포넌트를 생성합니다.
- **적용 예시**: "please make them look more shadcn ui's... minimalistic feel but premium startup"

#### 10. 모달/인터랙션 동적 추가
- **카테고리**: 프롬프트 엔지니어링 기법
- **상세 설명**: 정적 UI를 먼저 완성한 후, 클릭 이벤트, 모달, 애니메이션 등 동적 기능을 별도 요청으로 추가합니다.
- **적용 예시**: "When you click on one of the table elements, open a modal with the information inside each row editable"

---

### 97. DHH의 AI와 매몰 비용 오류 트윗

#### 1. 언제 멈출지 아는 것 (When to Stop Prompting)
- **카테고리**: AI 워크플로우/개발 방법론
- **상세 설명**: AI가 문제를 해결하지 못할 때 프롬프트를 계속 시도하는 대신, 직접 해결하기로 전환하는 시점을 판단하는 능력이 중요합니다.
- **적용 예시**: AI가 3-5번의 시도에도 해결되지 않으면 타이머를 설정하고, 10분 내 해결되지 않으면 공식 문서를 직접 읽거나 수동으로 해결

#### 2. 매몰 비용 오류 인식 (Sunk-Cost Fallacy Awareness)
- **카테고리**: 생산성/자동화 기법
- **상세 설명**: "한 번만 더 프롬프트를 시도하면 될 것 같다"는 생각으로 계속 시간을 투자하는 심리적 함정을 인식해야 합니다.
- **적용 예시**: AI 세션마다 타임박스(15-30분)를 설정하고, 시간이 초과되면 전략을 전환

#### 3. AI 실패를 학습 기회로 전환
- **카테고리**: AI 워크플로우/개발 방법론
- **상세 설명**: AI가 해결책을 제시하지 못했을 때, 그 과정에서 시스템이 실제로 어떻게 작동하는지 이해하는 기회로 활용합니다.
- **적용 예시**: AI가 파티션 오프셋 계산에 실패했을 때, 직접 관련 문서를 읽고 원리를 이해

#### 4. 단계별 검토 프롬프팅 (Step-by-Step Review)
- **카테고리**: 프롬프트 엔지니어링 기법
- **상세 설명**: AI에게 단순히 "고쳐라"라고 명령하는 대신, 코드를 단계별로 검토하고 문제점을 식별하도록 요청합니다.
- **적용 예시**: "이 코드를 단계별로 검토하고, 각 단계에서 발생할 수 있는 문제점을 식별해줘"

#### 5. 페어 프로그래밍 방식의 AI 협업
- **카테고리**: AI 에이전트 활용법
- **상세 설명**: 엔지니어와 페어 프로그래밍할 때처럼 AI와 협력하여 근본 원인을 찾고, 문제를 이해하며, 수정사항을 반복적으로 개선합니다.
- **적용 예시**: "이 문제의 근본 원인이 무엇이라고 생각해? 함께 분석해보자"

#### 6. 피드백 메커니즘 구축
- **카테고리**: 코드 품질/검증 방법
- **상세 설명**: LLM에게 적절한 피드백을 제공하는 메커니즘(타입 에러, 임시 스크립트, 유닛 테스트, e2e 테스트 등)을 구축합니다.
- **적용 예시**: AI가 생성한 코드를 즉시 타입 체커로 검증, 유닛 테스트 결과를 AI에게 피드백

#### 7. AI 강점/약점 영역 구분
- **카테고리**: AI 워크플로우/개발 방법론
- **상세 설명**: AI가 잘하는 영역과 실패하는 영역을 명확히 구분하여 적재적소에 활용합니다.
- **적용 예시**:
  - AI에게 맡기기 좋은 작업: 새 앱 스캐폴딩, 기본 테스트 작성, 리팩토링
  - 직접 하는 것이 나은 작업: 복잡한 시스템 수준 작업, 도메인 특화 로직

#### 8. 아키텍처 수준 유지
- **카테고리**: AI 워크플로우/개발 방법론
- **상세 설명**: AI와 작업할 때 너무 세부적인 버그 수정에 빠지지 않고 높은 수준의 아키텍처 관점을 유지합니다.
- **적용 예시**: 특정 버그 수정을 여러 번 요청하기보다, "이 모듈의 전체 구조를 검토하고 개선 방안을 제안해줘"로 수준을 높임

#### 9. 도구로서의 AI 인식 (AI as Efficiency Tool)
- **카테고리**: AI 워크플로우/개발 방법론
- **상세 설명**: 수동 작업 방법을 이미 알고 있을 때 AI를 효율성 도구로 활용하는 것이 최선입니다. AI를 대체재가 아닌 보조 도구로 인식합니다.
- **적용 예시**: 먼저 수동으로 해당 작업을 수행하는 방법을 이해한 후, 반복적인 부분만 AI에게 위임

#### 10. 비결정적 특성 인식 및 방향 수정
- **카테고리**: AI 워크플로우/개발 방법론
- **상세 설명**: AI의 비결정적(non-deterministic) 특성을 이해하고, 같은 프롬프트에도 다른 결과가 나올 수 있음을 인지합니다.
- **적용 예시**: AI 출력을 맹신하지 않고 항상 검증, 여러 번 실행하여 일관된 패턴 탐색

---

### 98. does-ai-write-better-code-than-humans

#### 1. AI 역할 한정 전략 (AI as Gap Filler)
- **카테고리**: AI 워크플로우/개발 방법론
- **상세 설명**: AI를 생산성 향상 도구로 활용하되, 아키텍처나 비즈니스 로직이 아닌 기술적 세부사항(boilerplate, 표준 패턴 구현)을 채우는 용도로 제한합니다.
- **적용 예시**: 인증/인가 모듈 초기 구현을 AI에게 맡기고, 비즈니스 규칙은 개발자가 직접 추가

#### 2. AI 코드 검증 습관화
- **카테고리**: 코드 품질/검증 방법
- **상세 설명**: AI가 생성한 코드의 오류를 식별하고 수정할 수 있는 능력이 필수입니다. 모든 AI 생성 코드는 철저한 리뷰가 필요합니다.
- **적용 예시**: AI 생성 코드에 대해 보안 취약점 검토 수행, 비즈니스 요구사항과의 일치 여부 확인

#### 3. 프롬프트 엔지니어링 역량 구축
- **카테고리**: 프롬프트 엔지니어링 기법
- **상세 설명**: AI 도구의 효과는 프롬프트 품질에 크게 좌우됩니다. 비즈니스 맥락과 사용자 요구사항을 AI에게 명확하게 전달하는 능력을 개발해야 합니다.
- **적용 예시**: 요구사항을 구체적이고 구조화된 형태로 프롬프트에 포함, 프로젝트 컨텍스트, 제약조건, 기대 결과물 명시

#### 4. 하이브리드 개발 워크플로우
- **카테고리**: AI 워크플로우/개발 방법론
- **상세 설명**: AI와 인간의 강점을 명확히 구분하여 역할을 분담합니다. AI는 반복적인 작업, 인간은 아키텍처 설계, 보안, 확장성 고려를 담당합니다.
- **적용 예시**:
  - AI: 테스트 코드 초안 작성, 리팩토링 제안, 문서화
  - 인간: 시스템 설계 결정, 보안 검토, 성능 최적화 전략

#### 5. AI 보조 도구 인식 (지원 도구 vs 의존 도구)
- **카테고리**: AI 워크플로우/개발 방법론
- **상세 설명**: AI를 지원 도구로 사용하되 의존성을 갖지 않도록 주의해야 합니다. 최종 판단은 항상 인간이 내려야 합니다.
- **적용 예시**: AI 제안을 그대로 수용하지 않고 항상 검토, 핵심 비즈니스 로직은 직접 작성

#### 6. AI 도구 학습 곡선 관리
- **카테고리**: 생산성/자동화 기법
- **상세 설명**: 초기에는 AI가 생성한 코드를 수정하는 데 더 많은 시간이 소요될 수 있음을 인지합니다. 지속적인 학습과 적응을 통해 최적의 활용 방안을 모색합니다.
- **적용 예시**: 간단한 작업부터 AI 활용 시작, 점진적으로 복잡한 작업으로 확장

---

### 99. Embabel Agent Framework

#### 1. 목표-조건-행동 기반 에이전트 설계 (GOAP)
- **카테고리**: AI 에이전트 활용법
- **상세 설명**: 에이전트를 Actions(행동), Goals(목표), Conditions(조건), Domain Model(도메인 모델), Plan(계획)의 다섯 가지 핵심 개념으로 구조화합니다.
- **적용 예시**: `@Agent` 클래스에 `@Goal`, `@Condition`, `@Action` 메서드를 정의하여 에이전트 흐름을 선언적으로 구성

#### 2. OODA 루프 기반 동적 재계획
- **카테고리**: AI 워크플로우/개발 방법론
- **상세 설명**: 각 Action 완료 후 시스템이 조건을 재평가하고 새로운 정보에 적응하여 재계획합니다.
- **적용 예시**: 에이전트가 데이터 수집 후 예상치 못한 결과를 발견하면 자동으로 대안 경로를 선택

#### 3. 하이브리드 계획 시스템 (Non-LLM AI)
- **카테고리**: AI 에이전트 활용법
- **상세 설명**: 계획 단계에서 LLM이 아닌 전통적인 AI 알고리즘을 사용하여 정교한 계획을 수립합니다.
- **적용 예시**: 새로운 Action을 추가하면 플래너가 자동으로 기존 워크플로우에 통합

#### 4. 다중 LLM 조합 활용 (LLM Mixing)
- **카테고리**: 생산성/자동화 기법
- **상세 설명**: 서로 다른 LLM의 강점을 활용하여 작업별로 최적의 모델을 혼합 사용합니다.
- **적용 예시**: 단순 분류 작업에는 경량 모델, 복잡한 추론에는 고성능 모델을 자동 선택

#### 5. 타입 안전 프롬프트-코드 연동
- **카테고리**: 코드 품질/검증 방법
- **상세 설명**: 프롬프트와 수동 작성 코드가 강타입 도메인 모델을 통해 깔끔하게 상호작용합니다.
- **적용 예시**: Kotlin/Java 클래스로 도메인 객체를 정의하고 IDE의 리팩토링 기능을 활용

#### 6. 어노테이션 기반 에이전트 구성
- **카테고리**: AI 에이전트 활용법
- **상세 설명**: Spring MVC와 유사한 어노테이션 기반 모델을 사용하여 에이전트 흐름을 정의합니다.
- **적용 예시**:
```kotlin
@Agent
class MyAgent {
    @Goal fun achieveResult(): Boolean = ...
    @Action fun performStep(): Result = ...
}
```

#### 7. 에이전트 테스트 용이성 설계
- **카테고리**: 코드 품질/검증 방법
- **상세 설명**: 처음부터 테스트 용이성을 고려하여 설계되었습니다. 단위 테스트와 종단간 테스트 모두 쉽게 수행할 수 있습니다.
- **적용 예시**: 개별 Action을 모킹하여 단위 테스트, 전체 에이전트 플로우를 시뮬레이션하여 통합 테스트

#### 8. 플랫폼 추상화 계층
- **카테고리**: AI 워크플로우/개발 방법론
- **상세 설명**: 프로그래밍 모델과 플랫폼 개념을 분리하여 애플리케이션 코드 변경 없이 로컬부터 고품질 서비스 환경까지 전환 가능합니다.
- **적용 예시**: 개발 시 로컬에서 테스트하고, 프로덕션에서는 클라우드 기반 고가용성 환경으로 배포

---

### 100. Embabel-JVM을 위한 새로운 에이전트 플랫폼

#### 1. 비LLM AI 알고리즘 기반 자동 계획 (GOAP)
- **카테고리**: AI 워크플로우/개발 방법론
- **상세 설명**: LLM에 의존하지 않는 AI 알고리즘을 사용하여 계획을 수립합니다. 결정론적이고 설명 가능한 계획을 제공합니다.
- **적용 예시**: 복잡한 비즈니스 워크플로우에서 상태 머신을 수동으로 연결하지 않고 시스템이 자동으로 최적 경로를 계획

#### 2. 작업별 최적 모델 선택 (Model Mixing)
- **카테고리**: AI 에이전트 활용법
- **상세 설명**: 단일 "신과 같은" 모델에 의존하지 않고, 작업 특성에 따라 로컬, 저렴한, 프라이빗 모델을 혼합하여 사용합니다.
- **적용 예시**: 민감하지 않은 텍스트 분류는 로컬 모델로, 복잡한 추론은 클라우드 LLM으로 라우팅

#### 3. 가드레일 주입 (Guardrails Injection)
- **카테고리**: 코드 품질/검증 방법
- **상세 설명**: AI 에이전트 플로우의 어느 지점에서든 가드레일을 주입하여 안전성을 확보합니다.
- **적용 예시**: 에이전트가 DB 쓰기 작업 전 반드시 검증 단계를 거치도록 가드레일 삽입

#### 4. 설명 가능한 AI (Explainable AI)
- **카테고리**: AI 워크플로우/개발 방법론
- **상세 설명**: 에이전트가 문제를 해결할 때 왜 그런 선택이 이루어졌는지 설명할 수 있어야 합니다.
- **적용 예시**: 비즈니스 의사결정 에이전트에서 각 단계의 선택 이유를 로그로 기록

#### 5. MCP 도구 통합 및 발견 가능성
- **카테고리**: 도구/플러그인 활용
- **상세 설명**: MCP는 도구 통합에 중요하지만, 어느 시점에서 올바른 도구를 찾고 모델이 도구들 사이에서 혼란스러워하지 않도록 하는 "발견 가능성" 문제를 해결해야 합니다.
- **적용 예시**: 사용자 의도에 따라 적합한 MCP 도구를 자동 선택하고, 도구 간 충돌을 방지하는 라우팅 로직

#### 6. 타입 안전 프롬프트 (Type-Safe Prompts)
- **카테고리**: 프롬프트 엔지니어링 기법
- **상세 설명**: Kotlin 데이터 클래스나 Java 레코드를 사용하여 풍부한 도메인 모델을 구축하고, 프롬프트를 타입 안전하게 구성합니다.
- **적용 예시**: `data class StoryRequest(val theme: String, val characters: List<String>)` - 클래스가 자동으로 프롬프트 구조로 변환

#### 7. 에이전트 연합 (Agent Federation)
- **카테고리**: AI 에이전트 활용법
- **상세 설명**: 대규모에서 플로우의 조합 가능성을 통해 에이전트 연합체를 구성합니다.
- **적용 예시**: 주문 처리, 고객 서비스, 재고 관리 에이전트가 각각 독립적으로 운영되면서 협력하는 연합 시스템

#### 8. 템플릿 기반 에이전트 프로젝트 생성
- **카테고리**: 생산성/자동화 기법
- **상세 설명**: 단일 명령어로 JVM 기반 AI 에이전트 프로젝트를 생성할 수 있습니다.
- **적용 예시**: `uvx --from git+https://github.com/embabel/project-creator.git project-creator` → 1분 내 실행 가능한 에이전트 프로젝트 생성

#### 9. 에이전트 플로우 실행 제어 및 복원력
- **카테고리**: AI 워크플로우/개발 방법론
- **상세 설명**: 에이전트 플로우의 실행을 관리하고 더 큰 복원력을 도입합니다. 실패 시 재시도, 폴백 전략, 상태 지속성 등을 통해 안정적 운영을 보장합니다.
- **적용 예시**: 외부 API 호출 실패 시 자동 재시도, 중간 상태 저장을 통한 장애 복구

---

## 카테고리별 기법 요약

| 카테고리 | 기법 수 | 주요 기법 |
|----------|---------|----------|
| 프롬프트 엔지니어링 | 14 | 구체적 프롬프트, 도메인 어휘 명시, 이미지 기반 UI 생성, 타입 안전 프롬프트 |
| AI 워크플로우/개발 방법론 | 23 | 점진적 대화형 개발, 페어 프로그래밍 마인드셋, 계획 우선 개발, GOAP, OODA 루프, 매몰 비용 인식 |
| AI 에이전트 활용법 | 13 | 탐색적 프로젝트 분석, LLM 백엔드 선택, 멀티 AI 앙상블, 에이전트 연합, Model Mixing |
| 도구/플러그인 활용 | 7 | Cursor Composer, Codebase Indexing, MCP 도구 발견, 문서 태깅 |
| 코드 품질/검증 방법 | 10 | 엣지 케이스 자동 식별, 피드백 메커니즘, 가드레일 주입, 타입 안전 연동 |
| 생산성/자동화 기법 | 9 | 스크립트 자동 생성, 다이어그램 자동 생성, .cursorignore 최적화, 템플릿 기반 생성 |

---

## 핵심 테마

1. **도구 선택 전략**: AI 도구의 강점/약점을 파악하여 적재적소에 활용 (V0 + Claude + Cursor 조합, Model Mixing)
2. **점진적 접근법**: 한 번에 완성하지 않고 단계별로 요청하여 결과를 확인하며 개선
3. **페어 프로그래밍 마인드셋**: AI와 일방적 명령이 아닌 협업적 대화로 작업
4. **매몰 비용 인식**: AI가 해결하지 못할 때 언제 멈출지 아는 것이 중요
5. **타입 안전성**: 강타입 도메인 모델을 통해 프롬프트와 코드를 안전하게 연동
6. **GOAP 패턴**: 목표 지향적 에이전트 설계로 결정론적이고 설명 가능한 계획 수립
7. **지식베이스 통합**: Obsidian + Cursor 조합으로 개인 지식을 AI 컨텍스트로 활용
